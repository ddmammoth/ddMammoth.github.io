<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>猛犸象翻译组</title>
  
  <subtitle>2019，行者无疆</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hongruqi.github.io/"/>
  <updated>2019-03-25T12:28:56.134Z</updated>
  <id>https://hongruqi.github.io/</id>
  
  <author>
    <name>猛犸象</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://hongruqi.github.io/2019/03/25/JavaScript%20%E7%AE%97%E6%B3%95/"/>
    <id>https://hongruqi.github.io/2019/03/25/JavaScript 算法/</id>
    <published>2019-03-25T09:57:11.337Z</published>
    <updated>2019-03-25T12:28:56.134Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-算法"><a href="#JavaScript-算法" class="headerlink" title="JavaScript 算法"></a>JavaScript 算法</h1><p><img src="https://cdn-images-1.medium.com/max/800/1*CMYOFHdAKR7pNWE2F-zIHA.jpeg" alt></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>传统的 <strong>面试过程</strong> 通常以最基本的如何编写 <em>手机屏幕页面</em> 问题为开始，然后通过全天的 <em>现场工作</em> 来检验 <em>编码能力</em> 和 <em>文化契合</em> 度。 几乎无一例外，决定性的因素还是 <strong>编码能力</strong>。 毕竟，工程师是靠一天结束之时产出可使用的软件来获得报酬的。一般来说，我们会使用 _白板_ 来测试这种编码能力。比获得正确答案更重要的是清晰明了的思考过程。编码和生活一样，正确的答案不总是显而易见的，但是好的论据通常是足够好的。 _有效_ 的 _推理_ 能力标志着学习，适应和发展的潜力。最好的工程师总是在成长，最好的公司总是在不断创新。</p><p><strong>算法挑战</strong> 是有效的锻炼能力的方法，因为总有不止一种的方法来解决它们。这为决策和演算决策提供了可能性。当解决算法问题的时候，我们应该挑战自我，从多个角度来看 <em>问题的定义</em> ，然后权衡各种方式的 _益处_  和 _缺陷_ 。通过足够的联系，我们甚至可以一瞥宇宙的真理； <em>没有“完美”的解决方案</em> 。</p><p>真正掌握 <strong>算法</strong> 就是去理解 <strong>数据</strong> 和 <strong>结构</strong> 之间的关系。数据结构和算法之间的关系，就如同“阴”之于“阳”， <em>玻璃杯</em> 之于 _水_ 。没有玻璃杯，水就无法被承载。没有数据结构，我们就没有可以用于逻辑的对象。没有水，玻璃杯会因为缺乏物质而变空。没有算法，对象就无法被转化或者“消费”。</p><p><em>关于数据结构深入分析，可以参考：</em> <a href="https://medium.com/siliconwat/data-structures-in-javascript-1b9aed0ea17c" target="_blank" rel="noopener"><em>Data Structures in JavaScript</em></a>_:_</p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>应用于代码中，一个算法只是一个把确定的 <em>数据结构</em> 的 <strong>输入</strong> 转化为一个确定的 <em>数据结构</em> 的 <strong>输出</strong> 的 <code>function</code> 。算法 _内在_ 的 <strong>逻辑</strong> 决定了如何转换。首先，输入和输出应该被 _明确_ 定义为 <strong>单元测试</strong>。这需要完全的理解手头的问题，这是不容小觑的，因为彻底分析问题可以无需编写任何代码，就自然地解决问题。</p><p>一旦彻底掌握问题的领域，就可以开始对解决方案进行 <strong>头脑风暴</strong> 。 <em>需要哪些变量？需要多少循环以及哪些类型的循环？有没有巧妙的内置的方法可以提供帮助？需要考虑哪些边缘情况？</em> 复杂和重复的逻辑只会徒增阅读和理解的难度。 <em>帮助函数可以被抽象或者抽离吗？</em> 算法通常需要是可扩展的。 <em>随着输入规模的增加，函数将如何执行？</em> <em>是否应该有某种缓存机制？</em> 而性能优化（时间）通常需要牺牲内存空间（增加内存消耗）。</p><blockquote><p>为了使问题更具体，让我们来绘制一个 <strong>图表</strong> ！</p></blockquote><p>当解决方案中的高级结构开始出现时，我们就可以开始写 <strong>伪代码</strong> 了。为了给面试官留下真正的印象，<br>请 _优先_ 考虑代码的重构和 <strong>复用</strong> 。有时，行为类似的函数可以合并成一个可以接受额外参数的更通用的函数。其他时候，去参数化会更好。保持函数的 <strong>纯净</strong> 以便于测试和维护也是很有先见之明的。换言之，设计算法时，将 <strong>架构</strong> 和 <strong>设计模式</strong> 纳入到你的考虑范围内。</p><blockquote><p>如果有任何不清楚的地方，请 _提问_ 以便说明！</p></blockquote><h4 id="Big-O（算法的复杂度）"><a href="#Big-O（算法的复杂度）" class="headerlink" title="Big O（算法的复杂度）"></a>Big O（算法的复杂度）</h4><p>为了估算算法运行时的复杂度，在计算算法所需的 <em>操作次数</em> 之前，我们通常把 <em>输入大小</em> 外推至无穷来估算算法的可扩展性。在这种最坏情况的运行时上限情况下，我们可以忽略系数以及附加项，只保留主导函数的因子。因此，只需要几种类型就可以描述几乎所有的可扩展算法。</p><p>最优最理想的算法，是在时间和空间维度以 _常数_ 速率变化。这就是说它完全不关心输入大小的变化。次优的算法是对时间或空间以 _对数_ 速率变化，再次分别是 _线性_ ， <em>线性对数</em> ， _二次_ 和 _指数_ 型。最糟糕的是对时间或空间以 _阶乘_ 速率变化。在 <strong>Big-O</strong> 表示法中：</p><ol><li><strong>常数</strong>: O(1)</li><li><strong>对数</strong>: O(log n)</li><li><strong>线性</strong>: O(n)</li><li><strong>线性对数</strong>: O(n log n)</li><li><strong>二次</strong>: O(n²)</li><li><strong>指数</strong>: O(2^n)</li><li><strong>阶乘</strong>: O(n!)</li></ol><p><img src="https://cdn-images-1.medium.com/max/800/1*-j3Q4EiyBgc1tDTR5uKTnQ.png" alt></p><p>图表: <a href="http://bigocheatsheet.com/" target="_blank" rel="noopener">http://bigocheatsheet.com</a></p><p>当我们考虑算法的时间和空间复杂性之间的权衡时，Big-O <em>渐近分析</em> 是不可或缺的工具。然而，Big O 忽略了在实际实践中可能有影响的常量因素。此外，优化算法的时间和空间复杂性可能会增加现实的开发时间或对代码可读性产生负面影响。在设计算法的结构和逻辑时，对真正可忽略不计的东西的直觉同样重要。</p><h4 id="Arrays（数组）"><a href="#Arrays（数组）" class="headerlink" title="Arrays（数组）"></a>Arrays（数组）</h4><p>最干净的算法通常会利用语言中固有的 _标准_ <strong>对象</strong>。可以说计算机科学中最重要的是<code>Arrays</code>。在JavaScript中，没有其他对象比数组拥有更多的实用工具方法。值得记住的数组方法是： <code>sort</code>， <code>reverse</code>， <code>slice</code>， 以及 <code>splice</code>。数组从 <em>第0个索引</em> 开始插入数组元素。这意味着最后一个数组元素的位置是 <code>array.length — 1</code>。数组是 _索引_ (推入) 的最佳选择，但对于 _插入_, _删除_ (不弹出), 和 _搜索_ 等动作非常糟糕。在 JavaScript 中, 数组可以 _动态_ 增长。</p><p>对应的 <strong>Big O</strong> :</p><ul><li><strong>索引</strong>: O(1)</li><li><strong>插入</strong>: O(n)</li><li><strong>删除</strong>: O(n)</li><li><strong>暴力搜索</strong>: O(n)</li><li><strong>优化搜索</strong>: O(log n)</li></ul><p>这些 <code>Array</code> 方法在代码中的示例：</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="xPGmVX" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Arrays in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/xPGmVX/" target="_blank" rel="noopener"><br>  Arrays in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><p>完整的阅读 MDN 有关 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noopener"><strong><em>Arrays</em></strong></a> 的文档也是值得的。</p><p>类似数组的还有 <code>Sets</code> 和 <code>Maps</code>. 在 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank" rel="noopener">set</a> 中，元素一定是 _唯一_ 的。在 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank" rel="noopener">map</a> 中，元素由字典式关系的 _键_ 和 _值_ 组成。当然，<code>Objects</code> (and their literals) 也可以储存键值对，但键必须是 <code>strings</code> 类型。</p><blockquote><p><strong>Object</strong> Object构造函数创建一个对象包装器<br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noopener">developer.mozilla.org</a></p></blockquote><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>与 <code>Arrays</code> 密切相关的是使用循环 <strong>遍历</strong> 它们。在 JavaScript 中，我们可以用 _五种_ 不同的 <em>控制结构</em> 来迭代。可定制化程度最高的是 <code>for</code> 循环，我们几乎可以用它以任何顺序来遍历数组 _索引_ 。如果无法确定 <em>迭代次数</em> ，我们可以使用 <code>while</code> 和 <code>do while</code> 循环，直到遇到一个满足确定条件的情况。对于任何对象，我们可以使用 <code>for in</code> 和 <code>for of</code> 循环来分别迭代它的“键”和“值”。要同时获取“键”和“值”，我们可以使用它的 <code>entries()</code> 方法。我们可以通过 <code>break</code>语句随时 <em>中断循环</em>  <code>break</code>, 或者使用 <code>continue</code> 语句 _跳到_ 。在大多数情况下，通过 <code>generator</code> 函数来控制迭代是最好的选择。</p><p>原生的遍历所有数组项的方法是： <code>indexOf</code>， <code>lastIndexOf</code>， <code>includes</code>， <code>fill</code> 和 <code>join</code>。 另外，我们可以为以下方法提供 <code>回调函数</code> ： <code>findIndex</code>， <code>find</code>， <code>filter</code>， <code>forEach</code>， <code>map</code>， <code>some</code>， <code>every</code> 和 <code>reduce</code>。</p><p>这些 <code>Array</code> 方法在代码中的示例：</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="JOdwKM" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Objects in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/JOdwKM/" target="_blank" rel="noopener"><br>  Objects in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>在一篇开创性的论文 <a href="https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis" target="_blank" rel="noopener">Church-Turing Thesis</a> 中，证明了任何迭代函数都可以用递归函数重写，反之亦然。有时，递归方法更简洁，更清晰，更优雅。就用这个 <code>factorial</code> 阶乘迭代函数来举例：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const **<span class="built_in">factorial</span>** = number =&gt; &#123;  </span><br><span class="line">  <span class="built_in">let</span> <span class="built_in">product</span> = <span class="number">1</span>;  </span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> i = <span class="number">2</span>; i &lt;= number; i++) &#123;  </span><br><span class="line">    <span class="built_in">product</span> *= i;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="built_in">return</span> <span class="built_in">product</span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用 <code>recursive</code> 递归函数来写，只需要 _一行_ 代码！</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> **factorial** = <span class="function"><span class="params">number</span> =&gt;</span> &#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">number</span> &lt; <span class="number">2</span> ? <span class="number">1</span> : <span class="built_in">number</span> * factorial(<span class="built_in">number</span> - <span class="number">1</span>);  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所有递归函数都有一个 <em>通用模式</em> 。它们总是由一个调用自身的 <em>递归部分</em> 和一个不调用自身的 <em>基本情形</em> 组成。当一个函数调用自己的时候，它就会将一个新的 <code>执行上下文</code> 推送到 <code>执行堆栈</code> 里。这种情况会一直持续进行下去，直到遇到 <em>基本情形</em> ，然后 _堆栈_ 逐个弹出展开成 <em>各个上下文</em>。因此，草率的依赖递归会导致可怕的运行时 <code>堆栈溢出</code> 错误。</p><p><code>factorial</code> 阶乘函数的代码示例:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="vWXNPN" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Factorial in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/vWXNPN/" target="_blank" rel="noopener"><br>  Factorial in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><p>终于，我们准备好接受任何算法挑战了！😉</p><h3 id="热门的算法问题"><a href="#热门的算法问题" class="headerlink" title="热门的算法问题"></a>热门的算法问题</h3><p>在本节中，我们将按照难度顺序浏览22个 <em>经常被问到的</em> 算法问题。我们将讨论不同的方法和它们的利弊以及运行中的时间复杂性。最优雅的解决方案通常会利用特殊的 “技巧” 或者敏锐的洞察力。记住这一点，让我们开始吧！</p><h4 id="1-反转字符串"><a href="#1-反转字符串" class="headerlink" title="1. 反转字符串"></a>1. 反转字符串</h4><p>把一个给定的 <code>一串字符</code> 当作 _输入_ ，编写一个函数，将传入字符串 _反转_ 字符顺序后返回。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"String Reversal"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should reverse string**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">reverse</span>(<span class="string">"Hello World!"</span>), <span class="string">"!dlroW olleH"</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>:</p><p>如果我们知道“技巧”，那么解决方案就不重要了。技巧就是意识到我们可以使用 _数组_ 的内置方法 <code>reverse</code> 。首先，我们对 <em>字符串</em> 使用 <code>split</code> 方法生成一个 <em>字符数组</em> ，然后我们可以用 <code>reverse</code> 方法，最后用 <code>join</code> 方法将字符数组重新组合回一个 <em>字符串</em>。这个解决方案可以用一行代码来完成！虽然不那么优雅，但也可以借助最新的语法和帮助函数来解决问题。使用新的 <code>for of</code> 循环迭代字符串中的每一个字符，可以展示出我们对最新语法的熟悉情况。或者，我们可以用数组的 <code>reduce</code> 方法，它使我们不再需要保留临时基元。</p><p>对于给定的字符串的每个字符都要被“访问”一次。虽然这中访问会多次发生，但是 _时间_ 可以被归一化为 _线性_ 时间。并且因为没有单独的内部状态需要被保存，因此 _空间_ 是 _恒定_ 的。</p><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="VryYBp" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="String Reversal in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/VryYBp/" target="_blank" rel="noopener"><br>  String Reversal in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="2-回文"><a href="#2-回文" class="headerlink" title="2. 回文"></a>2. 回文</h4><p>_回文_ 是指一个 <code>单词</code> 或 <code>短语</code> <em>正向和反向</em> 阅读都是一样的。写一个函数来验证给定输入值是否是回文。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Palindrome"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should return true**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">isPalindrome</span>(<span class="string">"Cigar? Toss it in a can. It is so tragic"</span>), true)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should return false**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">isPalindrome</span>(<span class="string">"sit ad est love"</span>), false)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>:</p><p>这里的关键点是意识到：我们基于在前一个问题中学到的东西来解决。除此之外，我们需要返回一个 <code>布尔</code> 值。这就像对 <em>原始字符串</em> 返回 <em>三重等式</em> 检查一样简单。我们还可以在 _数组_ 上使用新的 <code>every</code> 方法来检查 <em>第一个</em> 和 <em>最后一个</em> 字符是否按顺序 <em>以中心为对称点</em> 匹配。然而，这会使检查次数超过必要次数的两倍。与前一个问题类似，这个问题的时间和空间的运行时复杂性都 是相同的。</p><p>如果我们想扩展我们的功能以测试整个 _短语_ 怎么办？我们可以创造一个 <em>帮助函数</em> ，它对 <code>字符串</code> 使用 <strong>正则表达式</strong> 和 <code>replace</code> 方法来剔除非字母字符。如果不允许使用正则表达式，我们就创造一个由 <em>可接受字符</em> 组成的 <code>数组</code> 用作过滤器。</p><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="EwBeKq" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Palindrome in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/EwBeKq/" target="_blank" rel="noopener"><br>  Palindrome in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="3-整数反转"><a href="#3-整数反转" class="headerlink" title="3. 整数反转"></a>3. 整数反转</h4><p>给定一个 <code>整数</code>， _反转_ 数字的顺序。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Integer Reversal"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should reverse integer**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">reverse</span>(<span class="number">1234</span>), <span class="number">4321</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">reverse</span>(<span class="name">-1200</span>), <span class="number">-21</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>:</p><p>这里的技巧是先把数字通过内置的 <code>toString</code> 方法转化为一个 <code>字符串</code> 。然后，我们可以简单的复用 <em>反转字符串</em> 的算法逻辑。在数字反转之后，我们可以使用全局的 <code>parseInt</code> 函数将字符串转换回整数，并使用 <code>Math.sign</code> 来处理数字的符号。这种方法可以简化为一行代码！</p><p>由于我们复用了 <em>反转字符串</em> 的算法逻辑，这个算法的时间和空间的运行时复杂度也与之前相同。</p><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="RjxxZK" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Integer Reversal"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/RjxxZK/" target="_blank" rel="noopener"><br>  Integer Reversal</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="4-Fizz-Buzz"><a href="#4-Fizz-Buzz" class="headerlink" title="4. Fizz Buzz"></a>4. Fizz Buzz</h4><p>给定一个 <code>数字</code> 作为输入值, 打印出从 1 到给定数字的所有整数。 但是，当整数可以被 2 整除时，打印出“Fizz”; 当它可以被3整除时，打印出“Buzz”; 当它可以同时被2和3整除时，打印出“Fizz Buzz”。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Fizz Buzz"</span>, () =&gt; &#123;  </span><br><span class="line"> beforeEach(() =&gt; (<span class="name">output</span> = fizzBuzz(<span class="number">30</span>)))<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should output number**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">output</span>\[<span class="number">0</span>\], <span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should output Fizz**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">output</span>\[<span class="number">1</span>\], <span class="string">"Fizz"</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should output Buzz**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">output</span>\[<span class="number">2</span>\], <span class="string">"Buzz"</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should output Fizz Buzz**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">output</span>\[<span class="number">5</span>\], <span class="string">"Fizz Buzz"</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>:</p><p>当我们意识到 <em>模运算符</em> 可用于检查可分性(是否能被整除)时，这个经典算法的挑战就变得非常简单了。模运算符对两个数字求余，返回两数相除的余数。因此我们可以简单的遍历每个整数，检查它们对2、3整除的余数是否等于 <code>0</code>。这展现了我们的数学功底，因为我们知道当一个数可以同时被 <code>a</code> 和 <code>b</code>整除时，它也可以被它们的 <em>最小公倍数</em> 整除。</p><p>同样，这个算法的时间和空间的运行时复杂度也与之前相同，因为每一个整数都被访问和检查过一次但不需要保存内部状态。</p><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="PJgewe" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Fizz Buzz in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/PJgewe/" target="_blank" rel="noopener"><br>  Fizz Buzz in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="5-最常见字符"><a href="#5-最常见字符" class="headerlink" title="5. 最常见字符"></a>5. 最常见字符</h4><p>给定一个由字符组成的 <code>字符串</code>，返回字符串中 <em>出现频次最高</em> 的 <code>字符</code> 。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Max Character"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should return max character**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">max</span>(<span class="string">"Hello World!"</span>), <span class="string">"l"</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>:</p><p>这里的技巧是创建一个表格，用来记录遍历字符串时每个字符出现的次数。这个表格可以用 <code>对象字面量</code> 来创建，用 <code>字符</code> 作为对象字面量的 _键_ ，用字符出现的 <code>次数</code> 作为 _值_ 。然后，我们遍历表格，通过一个保存每个键值对的 _临时_ <code>变量</code> 来找到出现频次最大的字符。</p><p>虽然我们使用了两个独立的循环来遍历两个不同的输入值（ <em>字符串</em> 和 <em>字符映射</em> ），但时间复杂度仍然是 _线性_ 的。虽然循环是对于字符串，但最终，字符映射的大小会有一个极限，因为任何一种语言的字符都是 _有限_ 个的。出于同样的原因，虽然要保存内部状态，但不管输入字符串如何增长，空间复杂度也是 _恒定_ 的。临时基元在大尺度上看也是可以忽略不计的。</p><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="qVppxO" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Max Character"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/qVppxO/" target="_blank" rel="noopener"><br>  Max Character</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="6-Anagrams"><a href="#6-Anagrams" class="headerlink" title="6. Anagrams"></a>6. Anagrams</h4><p>Anagrams是包含 <em>相同字符</em> 的 <code>单词</code> 或 <code>短语</code> 。写一个检查此功能的 <code>函数</code>。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Anagrams"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should implement anagrams**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">anagrams</span>(<span class="string">"hello world"</span>, <span class="string">"world hello"</span>), true)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">anagrams</span>(<span class="string">"hellow world"</span>, <span class="string">"hello there"</span>), false)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">anagrams</span>(<span class="string">"hellow world"</span>, <span class="string">"hello there!"</span>), false)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>:</p><p>一种显而易见的方法是创建一个 <em>字符映射</em> ，该映射计算每个输入字符串的字符数。之后，我们可以比较映射来看他们是否相同。创建字符映射的逻辑可以抽离成一个 <em>帮助函数</em> 从而更方便的复用。为了更缜密，我们应该首先把字符串中所有非字符删掉，然后把剩下的字符变成小写。</p><p>正如我们所见，字符映射具有 _线性_ 时间复杂度和 _恒定_ 的空间复杂度。更确切地说，这种方法对于时间具有 <code>O(n + m)</code> 复杂度，因为检查了两个不同的字符串。</p><p>另一种更优雅的方法是我们可以简单的对输入值 <code>排序</code> ，然后检查它们是否相等！然而，它的缺点是排序通常需要 _线性_ 时间。</p><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="wPyZGo" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Anagrams"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/wPyZGo/" target="_blank" rel="noopener"><br>  Anagrams</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="7-元音"><a href="#7-元音" class="headerlink" title="7. 元音"></a>7. 元音</h4><p>给定一个 <code>字符串</code> 类型的单词或短语， _计算_ <code>元音</code> 的个数.</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Vowels"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should count vowels**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">vowels</span>(<span class="string">"hello world"</span>), <span class="number">3</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>:</p><p>最简单的办法是使用 <em>正则表达式</em> 取出所有的元音字母，然后计算它们的数量。如果不允许使用正则表达式，我们可以简单的遍历每一个字符，检查它是否是原因字母。不过首先要把字符串转化为 _小写_ 。</p><p>两种方法都是 _线性_ 时间复杂度和 _恒定_ 空间复杂度，因为每一个字符都需要被检查一次，而临时基元可以忽略不计。</p><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="gXzXEy" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Vowels"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/gXzXEy/" target="_blank" rel="noopener"><br>  Vowels</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="8-数组块"><a href="#8-数组块" class="headerlink" title="8. 数组块"></a>8. 数组块</h4><p>对于一个给定 <code>大小</code> 的 <code>数组</code> ，将数组 _元素_ 分割成一个给定大小的 _数组_ 类型的 <code>列表</code> 。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Array Chunking"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should implement array chunking**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.deepEqual(chunk(\[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>\], <span class="number">2</span>), \[\[<span class="number">1</span>, <span class="number">2</span>\], \[<span class="number">3</span>, <span class="number">4</span>\]\]);  </span><br><span class="line">  assert.deepEqual(chunk(\[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>\], <span class="number">3</span>), \[\[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>\], \[<span class="number">4</span>\]\]);  </span><br><span class="line">  assert.deepEqual(chunk(\[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>\], <span class="number">5</span>), \[\[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>\]\]);  </span><br><span class="line"> &#125;);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>分析</strong>:</p><p>一个显而易见的方法是保持一个对最后一个“块”的引用，并在遍历数组元素时检查其大小来判断是否应该向最后一个块中放元素。更优雅的解决方案是使用内置的 <code>slice</code> 方法。这样就不需要“引用”，从而使代码更清晰。这可以通过 <code>while</code> 循环或 <code>for</code> 循环来实现，该循环以给定大小的step递增。</p><p>这些算法都具有 _线性_ 时间复杂度，因为每个数组项都需要被访问一次。它们也都有 _线性_ 的空间复杂度，因为需要保存一个内在的 “块” 类型数组，该数组大小会随着输入值变化而变化。</p><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="BmYVMM" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Array Chunking"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/BmYVMM/" target="_blank" rel="noopener"><br>  Array Chunking</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="9-反转数组"><a href="#9-反转数组" class="headerlink" title="9. 反转数组"></a>9. 反转数组</h4><p>给定一个任意类型的 <code>数组</code> ， _反转_ 数组的顺序。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Reverse Arrays"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should reverse arrays**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.deepEqual(reverseArray(\[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>\]), \[<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>\]);  </span><br><span class="line">  assert.deepEqual(reverseArray(\[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>\]), \[<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>\]);  </span><br><span class="line"> &#125;);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>分析</strong>:</p><p>当然最简单的解决办法是使用内置的 <code>reverse</code> 方法。但这也太赖皮了！如果不允许使用这种方法，我们可以简单循环数组的一般，并 _交换_ 数组的开头和结尾的元素。这意味着我们要在内存里暂存 _一个_ 数组元素。为了避免这种对暂存的需要，我们可以对数组对称位置的元素使用 <em>结构赋值</em> 。</p><p>虽然只遍历了输入数组的一半，但时间复杂度仍然是 _线性_ 的，因为 Big O 近似地忽略了系数。</p><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="eezgYy" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Reverse Arrays in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/eezgYy/" target="_blank" rel="noopener"><br>  Reverse Arrays in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="10-反转单词"><a href="#10-反转单词" class="headerlink" title="10. 反转单词"></a>10. 反转单词</h4><p>给定一个 <code>词组</code>， _反转_ 词组中每个单词的字符顺序。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Reverse Words"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should reverse words**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">reverseWords</span>(<span class="string">"I love JavaScript!"</span>), <span class="string">"I evol !tpircSavaJ"</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>:</p><p>我们可以使用split方法创建单个单词的数组。然后对每一个单词，我们使用 <em>反转字符串</em> 的逻辑来反转它的字符。另一种方法是 _反向_ 遍历每个单词，并将结果存储在临时变量中。无论哪种方式，我们都需要暂存所有反转的单词，最后再把它们拼接起来。</p><p>由于每一个字符都被遍历了一遍，并且所需的临时变量大小与输入字符串成比例，所以时间和空间复杂度都是 _线性_ 的。</p><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="RjRoYd" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Reverse Words in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/RjRoYd/" target="_blank" rel="noopener"><br>  Reverse Words in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="11-首字母大写转换"><a href="#11-首字母大写转换" class="headerlink" title="11. 首字母大写转换"></a>11. 首字母大写转换</h4><p>给定一个 <code>词组</code>，对每一个单词进行 <em>首字母大写</em> 。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Capitalization"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should capitalize phrase**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">capitalize</span>(<span class="string">"hello world"</span>), <span class="string">"Hello World"</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>:</p><p>一种解决方法是遍历每个字符，当遍历字符的前一个字符是 _空格_ 时，就对当前字符使用 <code>toUpperCase</code> 方法使其变成大写。由于 <strong>字符串文字</strong> 在 JavaScript 中是 <em>不可变</em> 的，所以我们需要使用适当的大写转化方法重建输入字符串。这种方法要求我们始终将第一个字符大写。另一种更简洁的方法是将输入字符串 <code>split</code> 成一个 <em>由单词组成的数组</em> 。然后，遍历这个数组，将每个元素第一个字符大写，最后将单词重新连接在一起。出于相同的不可变原因，我们需要在内存里保存一个 <em>临时数组</em> 来保存被正确大写的单词。</p><p>两种方式都是 _线性_ 的时间复杂度，因为每个字符串都被遍历了一次。它们也都是 _线性_ 的空间复杂度，因为保存了一个临时变量，该变量与输入字符串成比例增长。</p><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="NwMvNN" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Capitalization"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/NwMvNN/" target="_blank" rel="noopener"><br>  Capitalization</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="12-恺撒密码"><a href="#12-恺撒密码" class="headerlink" title="12. 恺撒密码"></a>12. 恺撒密码</h4><p>给定一个 <code>短语</code>， 通过将每个字符 _替换_ 成字母表向前或向后移动一个给定的 <code>整数</code> 的新字符。如有必要，移位应绕回字母表的开头或结尾。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Caesar Cipher"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should shift to the right**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">caesarCipher</span>(<span class="string">"I love JavaScript!"</span>, <span class="number">100</span>), <span class="string">"E hkra FwrwOynelp!"</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">it(<span class="string">"**Should shift to the left**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">caesarCipher</span>(<span class="string">"I love JavaScript!"</span>, <span class="number">-100</span>), <span class="string">"M pszi NezeWgvmtx!"</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>:</p><p>首先，我们需要创建一个 <em>字母表字符</em> 组成的 <code>数组</code> ，以便计算移动字符的结果。这意味着我们要在遍历字符之前先把 <code>输入字符串</code> 转化为小写。我们很容易用常规的 <code>for</code> 循环来跟踪当前索引。我们需要构建一个包含每次迭代移位后的字符的 <code>新字符串</code> 。注意，当我们遇到非字母字符时，应该立即将它追加到我们的结果字符串的末尾，并使用 <code>continue</code> 语句跳到下一次迭代。有一个关键点事要意识到我们可以使用 <code>模运算符</code> 模拟当移位超过26时，循环计数到字母表数组的开头或结尾的行为。最后，我们需要在将结果追加到结果字符串之前检查原始字符串中的大小写。</p><p>由于需要访问每一个输入字符串的字符，并且需要根据输入字符串新建一个结果字符串，因此这个算法的时间和空间复杂度都是 _线性_ 的。</p><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="JOKboJ" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Caesar Cipher in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/JOKboJ/" target="_blank" rel="noopener"><br>  Caesar Cipher in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="13-Ransom-Note"><a href="#13-Ransom-Note" class="headerlink" title="13. Ransom Note"></a>13. Ransom Note</h4><p>给定一个 <code>magazine段落</code> 和一个 <code>ransom段落</code>，判断 <em>magazine段落</em> 中是否包含每一个 <em>ransom段落</em> 中的单词 。</p><p>const <strong>magazine</strong> =<br> “<em>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum</em>“;</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Ransom Note"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should return true**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">ransomNote</span>(<span class="string">"sit ad est sint"</span>, magazine), true)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">it(<span class="string">"**Should return false**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">ransomNote</span>(<span class="string">"sit ad est love"</span>, magazine), false)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">it(<span class="string">"**Should return true**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">ransomNote</span>(<span class="string">"sit ad est sint in in"</span>, magazine), true)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">it(<span class="string">"**Should return false**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">ransomNote</span>(<span class="string">"sit ad est sint in in in in"</span>, magazine), false)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>:</p><p>显而易见的做法是把magazine段落和ransom段落分拆成由单个单词组成的 _数组_ ，然后检查每个ransom单词是否存在于magazine段落中。然而，这种方法的时间复杂度是 _二次_ 的，或者说是 <code>O(n * m)</code> 的，这说明这种方法性能不好。如果我们首先创建一个magazine段落的单词表格，然后检查ansom段落中的每个词是否存在于这张表格中，我们就可以实现 _线性_ 时间复杂度。这是因为在 <em>映射对象</em> 中的查找总是可以在 _恒定_ 时间内完成。但是我们将会牺牲空间复杂度，因为需要把映射对象保存在内存里。</p><p>在代码中，这意味着我们需要创建每个magazine段落中单词的计数，然后检查 “hash 表格” 是否包含正确数量的ransom单词。</p><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="gGNzde" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Ransom Note in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/gGNzde/" target="_blank" rel="noopener"><br>  Ransom Note in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="14-平均值，中位数和Mode-出现次数最多的数字"><a href="#14-平均值，中位数和Mode-出现次数最多的数字" class="headerlink" title="14. 平均值，中位数和Mode(出现次数最多的数字)"></a>14. 平均值，中位数和Mode(出现次数最多的数字)</h4><p>给定一个数字组成的 <code>数组</code> ，计算这些数的 <em>平均值</em> ， <em>中位数</em> 和 <em>Mode</em> 。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const **stat1** = new Stats(\[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>\])<span class="comment">;  </span></span><br><span class="line">const **stat2** = new Stats(\[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>\])<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">"Mean"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should implement mean**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">Stats</span>.round(<span class="name">stat1</span>.mean()), <span class="number">3.43</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">Stats</span>.round(<span class="name">stat2</span>.mean()), <span class="number">2.5</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">"Median"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should implement median**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">stat1</span>.median(), <span class="number">4</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">stat2</span>.median(), <span class="number">2.5</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">"Mode"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should implement mode**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.deepEqual(<span class="name">stat1</span>.mode(), \[<span class="number">4</span>, <span class="number">5</span>\])<span class="comment">;  </span></span><br><span class="line">  assert.deepEqual(<span class="name">stat2</span>.mode(), \[\])<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>:</p><p>从难度方面讲，找到数字集合 <em>平均值</em> 的算法是最简单的。统计学上， <code>平均值</code> 的定义是数字集合的 _和_ 除以数字集合的 _数量_ 。因此，我们可以简单的使用数组的 <code>reduce</code> 方法来对它求和，然后除以它的 <code>长度</code>。这个算法的运行时复杂度对时间是 _线性_ 的，对空间是  _恒定_ 的。因为每一个数字在遍历的过程中都需要被求和但不需要在内存里保存变量。</p><p>找到集合 <em>中位数</em> 的算法困难度是中等的。首先，我们需要给数组排序，但如果集合的长度是基数，我们就需要额外的逻辑来处理中间的两个数字。这种情况下，我们需要返回这两个数字的 <em>平均值</em> 。这个算法因为需要排序，所以具有 <em>线性对数</em> 时间复杂度，同时因为需要内存来保持排序的数组，所以具有 _线性_ 的空间复杂度。</p><p>找到 <em>mode</em> 的算法是最为复杂的。由于 <code>mode</code> 被定义为最常出现的一个或多个数字，我们需要在内存中维护一个 <em>频率表</em> 。更复杂的是，如果每个值出现的次数都相同，则没有mode。这意味着在代码中，我们需要创建一个 <em>哈希映射</em> 来计算每一个“数”出现的频率；然后遍历这个映射来找到最高频的一个或多个数字，当然也可能没有mode。因为每个数字都需要在内存中保留和计数，所以这个算法具有 _线性_ 的时间和空间复杂度。</p><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="ooLrpR" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Mean, Median, Mode in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/ooLrpR/" target="_blank" rel="noopener"><br>  Mean, Median, Mode in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="15-多重求和"><a href="#15-多重求和" class="headerlink" title="15. 多重求和"></a>15. 多重求和</h4><p>给定一组数字，返回满足“两数字之和等于给定 <code>和</code> ”的 <em>所有组合</em> 。每个数字可以被使用不止一次。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Two Sum"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should implement two sum**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.deepEqual(twoSum(\[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>\], <span class="number">4</span>), \[\[<span class="number">2</span>, <span class="number">2</span>\], \[<span class="number">3</span>, <span class="number">1</span>\]\]);  </span><br><span class="line"> &#125;);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>分析</strong>:</p><p>显而易见的解决方案是创建 <em>嵌套循环</em> ，该循环检查每一个数字与同组中其他数字。那些满足求和之后满足给定和的组合可以被推入到一个 <em>结果数组</em> 中。然而，这种嵌套会引起 _指数_ 型的时间复杂度，这对于大输入值而言非常不适用。</p><p>一个讨巧的办法是在我们遍历输入数组时维护一个包含每个数字的 “对应物” 的数组，同时检查每个数字的对应物是否已经存在。通过维护这样的数组，我们牺牲了空间效率来获得 _线性_ 的时间复杂度。</p><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="aVmbpj" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Two Sum in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/aVmbpj/" target="_blank" rel="noopener"><br>  Two Sum in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="16-利润最大化"><a href="#16-利润最大化" class="headerlink" title="16. 利润最大化"></a>16. 利润最大化</h4><p>给定一组按照时间顺序给出的股票价格，找到 _最低_ <code>买入价</code> 和 _最高_ <code>卖出价</code> 使得 <em>利润最大化</em> 。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Max Profit"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should return minimum buy price and maximum sell price**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.deepEqual(maxProfit([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]), [<span class="number">1</span>, <span class="number">5</span>]);  </span><br><span class="line">  assert.deepEqual(maxProfit([<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>]), [<span class="number">1</span>, <span class="number">5</span>]);  </span><br><span class="line">  assert.deepEqual(maxProfit([<span class="number">2</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>]), [<span class="number">2</span>, <span class="number">10</span>]);</span><br><span class="line">  assert.deepEqual(maxProfit([<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">11</span>]), [<span class="number">1</span>, <span class="number">11</span>]);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>分析</strong>:</p><p>同样，我们可以构建 <em>嵌套循环</em> ，该循环检查买入价和卖出价的每种可能组合，看看哪一对产生最大的利润。实际操作中我们不能在购买之前出售，所以不是每个组合都需要被检查。具体而言，对于给定的买入价格，我们可以忽略卖出价格之前的所有价格。因此，该算法的时间复杂度优于 _二次_ 型。</p><p>不过稍微考虑一下，我们可以对价格数组只使用一次循环来解决问题。关键点是要意识到卖价绝不应低于买入价; 如果是这样，我们应该以较低的价格购买股票。就是说在代码中，我们可以简单的维护一个 <em>临时布尔值</em> 来表示我们应该在下一次迭代时更改买入价格。这种优雅的方法只需要一个循环，因此具有 _线性_ 的时间复杂度和 _恒定_ 的空间复杂度。</p><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="dZOyer" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Max Profit in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/dZOyer/" target="_blank" rel="noopener"><br>  Max Profit in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="17-Sieve-of-Eratosthenes"><a href="#17-Sieve-of-Eratosthenes" class="headerlink" title="17. Sieve of Eratosthenes"></a>17. Sieve of Eratosthenes</h4><p>对于给定的 <code>数字</code> ，找到从零到该数字之间的所有 _素数_ 。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Sieve of Eratosthenes"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should return all prime numbers**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.deepEqual(<span class="name">primes</span>(<span class="number">10</span>), \[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>\])<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>:</p><p>乍一看，我们可能想要遍历每个数字，只需使用模数运算符来检查所有可能的可分性。然而，很容易想到这种方法非常低效，时间复杂度比二次型还差。值得庆幸的是，地理学的发明者 <em>Eratosthenes of Cyrene</em> 还发现了一种有效的识别素数的方法。</p><p>在代码中，第一步是创建一个与给定数字一样大的数组，并将其每个元素初始化为 <code>true</code> 。换句话说，数组的 _索引_ 代表了所有可能的素数，并且每个数都被假定为 <em>true</em> 。然后我们建立一个 <code>for</code> 循环来遍历从 2 到给定数字的 <em>平方根</em> 之间的数，使用数组的 <em>键插值</em> 来把每个被遍历数的小于给定数的倍数对应的元素值设为 <em>false</em> 。根据定义，任何整数的乘积都不能是素数，这里忽略0和1，因为它们不会影响可分性。最后我们可以简单的筛掉所有 _假值_ ，以得出所有素数。</p><p>通过牺牲空间效率来维护一个内部的 “hash表”，这个Eratosthenes的 _筛子_ 在时间复杂度上会优于 _二次_ 型，或者说是 <code>O(n * log (log n))</code>。</p><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="NwbWqP" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Sieve of Eratosthenes in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/NwbWqP/" target="_blank" rel="noopener"><br>  Sieve of Eratosthenes in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="18-斐波那契通项公式"><a href="#18-斐波那契通项公式" class="headerlink" title="18. 斐波那契通项公式"></a>18. 斐波那契通项公式</h4><p>实现一个返回给定 <code>索引</code> 处的 <em>斐波纳契数</em> 的 <code>函数</code>。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Fibonacci"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should implement fibonacci**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">fibonacci</span>(<span class="number">1</span>), <span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">fibonacci</span>(<span class="number">2</span>), <span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">fibonacci</span>(<span class="number">3</span>), <span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">fibonacci</span>(<span class="number">6</span>), <span class="number">8</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">fibonacci</span>(<span class="number">10</span>), <span class="number">55</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>:</p><p>由于斐波纳契数是前两者的总和，最简单的方法就是使用 _递归_ 。斐波纳契数列假定前两项分别是1和1; 因此我们可以基于这个事实来创建我们的 <em>基本情形</em> 。对于索引大于2的情况，我们可以调用自身函数的前两项。虽然看着很优雅，这个递归方法的效率却非常糟糕，它具有 _指数_ 型的时间复杂度和 _线性_ 的空间复杂度。因为每个函数调用都需要调用堆栈，所以内存使用以指数级增长，如此一来它会很快就会崩溃。</p><p>迭代的方法虽然不那么优雅，但是时间复杂度却更优。通过循环，建立一个完整的斐波纳契数列前N项目(N为给定索引值)，这可以达到 _线性_ 的时间和空间复杂度。</p><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="JObPvJ" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Fibonacci in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/JObPvJ/" target="_blank" rel="noopener"><br>  Fibonacci in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="19-Memoized-Fibonacci"><a href="#19-Memoized-Fibonacci" class="headerlink" title="19. Memoized Fibonacci"></a>19. Memoized Fibonacci</h4><p>给斐波纳契数列实现一个 _高效_ 的递归函数。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Memoized Fibonacci"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should implement memoized fibonacci**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">fibonacci</span>(<span class="number">6</span>), <span class="number">8</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">fibonacci</span>(<span class="number">10</span>), <span class="number">55</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>:</p><p>由于斐波纳契数列对自己进行了冗余的调用，因此它可以戏剧性的从被称为 <em>记忆化</em> 的策略中获益匪浅。换句话说，如果我们在调用函数时 _缓存_ 所有的输入和输出值，则调用次数将减少到 _线性_ 时间。当然，这意味着我们牺牲了额外的内存。</p><p>在代码中，我们可以在函数本身内部实现 <em>记忆化</em> 技术，或者我们可以将它抽象为高阶效用函数，该函数可以装饰任何 <em>记忆化</em> 函数。</p><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="LObPvQ" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Memoized Fibonacci in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/LObPvQ/" target="_blank" rel="noopener"><br>  Memoized Fibonacci in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="20-画楼梯"><a href="#20-画楼梯" class="headerlink" title="20. 画楼梯"></a>20. 画楼梯</h4><p>对于给定长度的 <code>步幅</code> ，使用 _#_ and <em>‘ ’</em> 打印出一个 “楼梯” 。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Steps"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should print steps**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">steps</span>(<span class="number">3</span>), <span class="string">"#  \\n## \\n###\\n"</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">_steps</span>(<span class="number">3</span>), <span class="string">"#  \\n## \\n###\\n"</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>:</p><p>关键的见解是要意识到，当我们向下移动步幅时，<code>#</code> 的数量会不断 _增加_ ，而 ‘ ‘ 的数量会相应 _减少_ 。如果我们有 <code>n</code> 步要移动，全局的范围就是 <code>n</code> 行 <code>n</code> 列。这意味着运行时复杂度对于时间和空间都是 _二次_ 型的。</p><p>同样，我们发现这也可以使用递归的方式来解决。除此之外，我们需要传递 <em>额外的参数</em> 来代替必要的临时变量。</p><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="KyRvxX" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Staircase"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/KyRvxX/" target="_blank" rel="noopener"><br>  Staircase</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="21-画金字塔"><a href="#21-画金字塔" class="headerlink" title="21. 画金字塔"></a>21. 画金字塔</h4><p>对于给定数量的 <code>阶层</code> ，使用 _#_ 和 <em>‘ ‘</em> 打印出 “金字塔”。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Pyramid"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should print pyramid**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">pyramid</span>(<span class="number">3</span>), <span class="string">"  #  \\n ### \\n#####\\n"</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">_pyramid</span>(<span class="number">3</span>), <span class="string">"  #  \\n ### \\n#####\\n"</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>:</p><p>这里的关键时要意识到当金字塔的高度是 <code>n</code> 时，宽是 <code>2 * n — 1</code>。然后随着我们往底部画时，只需要以中心对称不断 _增加_ _#_ 的数量，同时相应 _减少_ <em>‘ ‘</em> 的数量。由于该算法以 <code>2 * n  -  1</code> * <code>n</code> 遍历构建出一个金字塔，因此它的运行时时间复杂度和空间复杂度都是 <code>二次</code> 型的。</p><p>同样，我们可以发现这里的递归调用可以使用之前的方法：需要传递一个 <em>附加变量</em> 来代替必要的临时变量。</p><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="zPjPBB" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Pyramid"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/zPjPBB/" target="_blank" rel="noopener"><br>  Pyramid</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="22-螺旋方阵"><a href="#22-螺旋方阵" class="headerlink" title="22. 螺旋方阵"></a>22. 螺旋方阵</h4><p>创建一个给定 <code>大小</code> 的 _方阵_ ，使方阵中的元素按照 <em>螺旋顺序</em> 排列。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Matrix Spiral"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should implement matrix spiral**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.deepEqual(spiral(<span class="number">3</span>), \[\[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>\], \[<span class="number">8</span>, <span class="number">9</span>, <span class="number">4</span>\], \[<span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>\]\]);  </span><br><span class="line"> &#125;);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>分析</strong>:</p><p>虽然这是一个很复杂的问题，但技巧其实只是对 <em>当前行</em> 和 <em>当前列</em> 的 _开头_ 以及 _结尾_ 的位置分别创建一个 <code>临时变量</code> 。这样，我们就可以按螺旋方向 _递增_ 遍历 <code>起始行</code> 和 <code>起始列</code> 并 _递减_ 遍历 <code>结束行</code> 和 <code>结束列</code> 直至方阵的中心。</p><p>因为该算法迭代地构建给定大小的 <em>正方形</em> 矩阵，它的运行时复杂度对时间和空间都是 _二次_ 型的。</p><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="mqKrZJ" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Matrix Spiral"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/mqKrZJ/" target="_blank" rel="noopener"><br>  Matrix Spiral</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h3 id="数据结构算法"><a href="#数据结构算法" class="headerlink" title="数据结构算法"></a>数据结构算法</h3><p>既然数据结构式构建算法的 “砖瓦” ，那么非常值得深入探索常见的数据结构。</p><p><em>再一次，想要快速的高层次的分析，请查看:</em></p><blockquote><p><strong>Data Structures in JavaScript</strong><br><em>For Frontend Software Engineers</em><br><a href="https://medium.com/siliconwat/data-structures-in-javascript-1b9aed0ea17c" target="_blank" rel="noopener">medium.com</a></p></blockquote><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>给定两个 <code>队列</code> 作为输入，通过将它们“编织”在一起来创建一个 _新_ 队列。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Weaving with Queues"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should weave two queues together**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const one = new Queue()<span class="comment">;  </span></span><br><span class="line">  one.enqueue(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  one.enqueue(<span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  one.enqueue(<span class="number">3</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  const two = new Queue()<span class="comment">;  </span></span><br><span class="line">  two.enqueue(<span class="string">"one"</span>)<span class="comment">;  </span></span><br><span class="line">  two.enqueue(<span class="string">"two"</span>)<span class="comment">;  </span></span><br><span class="line">  two.enqueue(<span class="string">"three"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  const result = weave(<span class="name">one</span>, two)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">result</span>.dequeue(), <span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">result</span>.dequeue(), <span class="string">"one"</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">result</span>.dequeue(), <span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">result</span>.dequeue(), <span class="string">"two"</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">result</span>.dequeue(), <span class="number">3</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">result</span>.dequeue(), <span class="string">"three"</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">result</span>.dequeue(), undefined)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>:</p><p><code>队列</code> 类至少需要有一个 <code>入列（enqueue）</code> 方法，一个 <code>出列（dequeue）</code> 方法，和一个 <code>peek</code> 方法。然后，我们使用 <code>while</code> 循环，该循环判断 <em>peek</em> 是否存在，如果存在，我们就让它执行 _出列_ ，然后 _入列_ 到我们的新 <code>队列</code> 中。</p><p>这个算法的时间和空间复杂度都是 <code>O(n + m)</code> 没因为我们需要迭代两个不同的集合，并且要存储它们。 </p><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="japeQZ" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Weaving with Queues"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/japeQZ/" target="_blank" rel="noopener"><br>  Weaving with Queues</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h4><p>使用两个 _堆栈_ 实现 <code>Queue</code> 类。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Queue from Stacks"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should implement queue using two stacks**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const queue = new Queue()<span class="comment">;  </span></span><br><span class="line">  queue.enqueue(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  queue.enqueue(<span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  queue.enqueue(<span class="number">3</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">queue</span>.peek(), <span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">queue</span>.dequeue(), <span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">queue</span>.dequeue(), <span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">queue</span>.dequeue(), <span class="number">3</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">queue</span>.dequeue(), undefined)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>:</p><p>我们可以从一个初始化两个堆栈的 <em>类构造函数</em> 开始。因为在 _堆栈_ 中，最 _后_ 插入的记录会最 _先_ 被取出，我们需要循环到最后一条记录执行 “出列” 或者 “peek” 来模仿 _队列_ 的行为：最 _先_ 被插入的记录会最 _先_ 被取出。我们可以通过使用第二个堆栈来 _临时_ 保存第一个堆栈中所有的元素直到结束。在 “peek” 或者 “出列” 之后，我们只要把所有内容移回第一个堆栈即可。对于 “入列” 一个记录，我们可以简单的把它push到第一个堆栈即可。</p><p>虽然我们使用两个堆栈并且需要循环两次，但是该算法在时间和空间复杂度上仍然是渐近 _线性_ 的。<br>Though we use two stacks and need to loop twice, this algorithm is still asymptotically <em>linear</em> in time and space.</p><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="bYjmXY" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Queue from Stacks"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/bYjmXY/" target="_blank" rel="noopener"><br>  Queue from Stacks</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>单向链表通常具有以下功能：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Linked List"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should implement insertHead**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">chain</span>.head.data, <span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should implement size**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">chain</span>.size(), <span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should implement getHead**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">chain</span>.getHead().data, <span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should implement getTail**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">chain</span>.getTail().data, <span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should implement clear**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  chain.clear()<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">chain</span>.size(), <span class="number">0</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should implement removeHead**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  chain.removeHead()<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">chain</span>.size(), <span class="number">0</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should implement removeTail**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  chain.removeTail()<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">chain</span>.size(), <span class="number">0</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should implement insertTail**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertTail(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">chain</span>.getTail().data, <span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should implement getAt**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">chain</span>.getAt(<span class="number">0</span>).data, <span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should implement removeAt**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  chain.removeAt(<span class="number">0</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">chain</span>.size(), <span class="number">0</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should implement insertAt**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertAt(<span class="number">0</span>, <span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">chain</span>.getAt(<span class="number">0</span>).data, <span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should implement forEach**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  chain.forEach((<span class="name">node</span>, index) =&gt; (<span class="name">node</span>.data = node.data + index))<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">chain</span>.getTail().data, <span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should implement iterator**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  for (<span class="name">let</span> node of chain) node.data = node.data + <span class="number">1</span><span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">chain</span>.getTail().data, <span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="qVyLWm" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Linked List"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/qVyLWm/" target="_blank" rel="noopener"><br>  Linked List</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><p><strong>挑战 #1: 中点</strong></p><p>在不使用计数器的情况下，返回链表的 <em>中间值</em> </p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Midpoint of Linked List"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should return midpoint of linked list**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">3</span>)<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">4</span>)<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">5</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">midpoint</span>(<span class="name">chain</span>).data, <span class="number">3</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>:</p><p>这里的技巧是同时进行 _两次_ 链表遍历，其中一次遍历的速度是另一次的 _两倍_。当快速的遍历到达结尾的时候，慢速的就到达了中点！</p><p>这个算法的时间复杂度是 _线性_ 的，空间复杂度是 _恒定_ 的。</p><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="OOoQGb" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Midpoint of Linked List"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/OOoQGb/" target="_blank" rel="noopener"><br>  Midpoint of Linked List</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><p><strong>Challenge #2: 循环</strong></p><p>在不保留节点引用的情况下，检查链表是否为 _循环_ 。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Circular Linked List"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should check for circular linked list**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">3</span>)<span class="comment">;  </span></span><br><span class="line">  chain.head.next.next.next = chain.head<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">circular</span>(<span class="name">chain</span>), true)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>:</p><p>很多的链表功能都基于链表有 _明确_ 的结束节点这个断言。因此，确保链表不是循环的这一点很重要。这里的技巧也是同时进行两次遍历，其中一次遍历的速度是另一次的两倍。如果链表是循环的，那么最终，较快的循环将与较慢的循环重合。这样我们就可以返回 <code>true</code>。否则，遍历会遇到结束点，我们就可以返回 <code>false</code>。</p><p>这个算法同样具有 _线性_ 时间复杂度和 _恒定_ 空间复杂度。</p><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="xPajLd" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Circular Linked List"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/xPajLd/" target="_blank" rel="noopener"><br>  Circular Linked List</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><p><strong>Challenge #3: From Tail</strong></p><p>在不使用计数器的情况下，返回链表距离链表末端给定 <code>步数</code> 的节点的 _值_ 。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"From Tail of Linked List"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should step from tail of linked list**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">3</span>)<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">4</span>)<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">5</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">fromTail</span>(<span class="name">chain</span>, <span class="number">2</span>).data, <span class="number">3</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>:</p><p>这里的技巧和之前类似，我们同时遍历链表两次。不过，在这个问题中，速度“快”的遍历比速度“慢”的遍历 _早_ <code>给定步数</code> 开始。然后，我们以相同的速度沿着链表向下走，直到更快的一个到达终点。这时，慢的遍历刚好到达距离结尾正确距离的位置。</p><p>这个算法同样具有 _线性_ 时间复杂度和 _恒定_ 空间复杂度。</p><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="GOXdQY" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="From Tail of Linked List"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/GOXdQY/" target="_blank" rel="noopener"><br>  From Tail of Linked List</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>树型结构通常具有以下功能：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Trees"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should add and remove nodes**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const root = new Node(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  root.add(<span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">root</span>.data, <span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">root</span>.children\[<span class="number">0</span>\].data, <span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  root.remove(<span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">root</span>.children.length, <span class="number">0</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should traverse by breadth**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const tree = new Tree()<span class="comment">;  </span></span><br><span class="line">  tree.root = new Node(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  tree.root.add(<span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  tree.root.add(<span class="number">3</span>)<span class="comment">;  </span></span><br><span class="line">  tree.root.children\[<span class="number">0</span>\].add(<span class="number">4</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  const numbers = \[\]<span class="comment">;  </span></span><br><span class="line">  tree.traverseBF(<span class="name">node</span> =&gt; numbers.push(<span class="name">node</span>.data))<span class="comment">;  </span></span><br><span class="line">  assert.deepEqual(<span class="name">numbers</span>, \[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>\])<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should traverse by depth**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const tree = new Tree()<span class="comment">;  </span></span><br><span class="line">  tree.root = new Node(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  tree.root.add(<span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  tree.root.add(<span class="number">3</span>)<span class="comment">;  </span></span><br><span class="line">  tree.root.children\[<span class="number">0</span>\].add(<span class="number">4</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  const numbers = \[\]<span class="comment">;  </span></span><br><span class="line">  tree.traverseDF(<span class="name">node</span> =&gt; numbers.push(<span class="name">node</span>.data))<span class="comment">;  </span></span><br><span class="line">  assert.deepEqual(<span class="name">numbers</span>, \[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>\])<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="mqzwye" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Trees"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/mqzwye/" target="_blank" rel="noopener"><br>  Trees</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><p><strong>Challenge #1: 树的广度</strong></p><p>对于给定的 <code>树</code> ，返回每个级别的 _广度_ 。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Width of Tree Levels"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should return width of each tree level**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const root = new Node(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  root.add(<span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  root.add(<span class="number">3</span>)<span class="comment">;  </span></span><br><span class="line">  root.children\[<span class="number">1</span>\].add(<span class="number">4</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  assert.deepEqual(<span class="name">treeWidths</span>(<span class="name">root</span>), \[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>\])<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>:</p><p>一个树可以通过 <code>堆栈</code> 对其所有的 _切片_ 进行 <em>深度优先</em> 的遍历，也可以通过 <code>队列</code> 的帮助对其所有的 _层级_ 进行 <em>广度优先</em> 的遍历。由于我们是想要计算每个级别的多有节点的个数，我们需要以 <em>深度优先</em> 的方式，借助 <code>队列</code> 对其进行 <em>广度优先</em> 的遍历。这里的技巧是往队列中插入一个特殊的 <code>标记</code> 来使我们知道当前的级别被遍历完成，所以我们就可以 _重置_ <code>计数器</code> 给下一个级别使用。</p><p>这种方法具有 _线性_ 的时间和空间复杂度。尽管我们的 <code>计数器</code> 是一个数组，但是它的大小永远不会比线性更大。</p><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="LOgLgp" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Width of Tree Levels"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/LOgLgp/" target="_blank" rel="noopener"><br>  Width of Tree Levels</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><p><strong>Challenge #2: 树的高度</strong></p><p>对于给定的 <code>树</code> ，返回它的 _高度_ （树的最大层级）。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Height of Tree"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should return max number of levels**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const root = new Node(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  root.add(<span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  root.add(<span class="number">3</span>)<span class="comment">;  </span></span><br><span class="line">  root.children\[<span class="number">1</span>\].add(<span class="number">4</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  assert.deepEqual(<span class="name">treeHeight</span>(<span class="name">root</span>), <span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>:</p><p>我们可以直接复用第一个挑战问题的逻辑。但是，在这个问题中，我们要在遇到 <code>“reset”</code>的时候增加我们的 <code>计数器</code> 。这两个逻辑几乎是相同的，所以这个算法也具有 _线性_ 的时间和空间复杂度。这里，我们的 <code>计数器</code> 只是一个整数，因此它的大小更可以忽略不计。</p><p><strong>代码</strong>:</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="wpKEQe" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Height of Tree"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/wpKEQe/" target="_blank" rel="noopener"><br>  Height of Tree</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h4><p>请等待后续补充! (谢谢)</p><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>我们可以使用许多种算法对数据集合进行排序。幸运的是，面试官只要求我们了解基础知识和第一原则。例如，最佳算法可以达到 _恒定_ 空间复杂度和 _线性_ 时间复杂度。本着这种精神，我们将按照困难度由简到难效率由低到高的顺序分析最受欢迎的几个算法。</p><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>这个算法是最容易理解的，但效率是最差的。它将每一个元素和其他所有元素做 _比较_ ， _交换_ 顺序，直到较大的元素 “冒泡” 到顶部。这种算法需要 _二次_ 型的时间和 _恒定_ 的空间。</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="POGzYM" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Bubble Sort in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/POGzYM/" target="_blank" rel="noopener"><br>  Bubble Sort in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>和冒泡排序一样，每一个元素都要与其他所有元素做比较。不同的是，这里的操作不是交换，而是 “拼接” 到正确的顺序中。事实上，它将保持重复项目的原始顺序。这种“贪婪”算法依然需要 _二次_ 型的时间和 _恒定_ 的空间。</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="YEGMxq" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Insertion Sort in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/YEGMxq/" target="_blank" rel="noopener"><br>  Insertion Sort in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>当循环遍历集合时，该算法查找并“选择”具有 <em>最小值</em> 的索引，并将起始元素与索引位置的元素交换。算法也是需要 _二次_ 型的时间和 _恒定_ 的空间。</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="MOzoPq" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Selection Sort in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/MOzoPq/" target="_blank" rel="noopener"><br>  Selection Sort in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>该算法递归的选择一个元素作为 _轴_ ，迭代集合中其他元素，将所有更小的元素向左边推，将所有更大的元素向右边推，直到所有元素都被正确排序。该算法具有 _二次_ 时间复杂度和 _对数_ 空间复杂度，因此在实践中它通常是 <em>最快度</em> 的。因此，大多数编程语言内置都用该算法进行排序。</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="GOjZqB" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Quick Sort in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/GOjZqB/" target="_blank" rel="noopener"><br>  Quick Sort in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>虽然这是效率最高的算法之一，但这种算法却难以理解。它需要一个 _递归_ 部分，将一个集合分成单个单元；并且需要一个 _迭代_ 部分，它将单个单元按正确的顺序重新组合在一起。这个算法需要 <em>线性对数</em> 时间和 _线性_ 空间。</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="jaMrBB" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Merge Sort in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/jaMrBB/" target="_blank" rel="noopener"><br>  Merge Sort in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p>如果我们用某种方式知道了 <em>最大值</em> ，我们就可以用这个算法在 _线性_ 时间和空间里对集合排序！最大值让我们创建该大小的数组来 _计算_ 每个 <em>索引值</em> 出现的次数。然后，只需将所有具有 _非零_ 计数的索引位置的元素提取到结果数组中。通过对数组进行 <em>恒定时间</em> 查找，这个类似哈希的算法是最有效的算法。</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="xPPKyz" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Counting Sort in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/xPPKyz/" target="_blank" rel="noopener"><br>  Counting Sort in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="其他的排序算法"><a href="#其他的排序算法" class="headerlink" title="其他的排序算法"></a>其他的排序算法</h4><p><img src="https://cdn-images-1.medium.com/max/800/1*7ErHjLrOGhdkmMm_nQfo-g.png" alt></p><p>图表: <a href="http://bigocheatsheet.com/" target="_blank" rel="noopener">http://bigocheatsheet.com</a></p><h3 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h3><p>最糟糕的算法需要搜索集合中的每个项目，需要花费 <code>O(n)</code> 时间。如果某个集合已经被排序，那么每次迭代只需要一半的检查次数，花费 <code>O(log n)</code> 时间，这对于非常大的数据集来说是一个巨大的性能提升。</p><h4 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h4><p>当一个集合被排序时，我们可以 _遍历_ 或 _递归_ 地检查我们的被检索值和中间项，丢弃一半我们想要的值不在的部分。事实上，我们的目标可以在 _对数_ 时间和 _恒定_ 空间情况中被找到。</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="NwRrZv" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Binary Search in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/NwRrZv/" target="_blank" rel="noopener"><br>  Binary Search in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>另一种排序集合的方法是从中生成一个 <em>二叉搜索树</em> (BST) 。对一个 BST 的搜索和二分搜索一样高效。以类似的方式，我们可以在每次迭代中丢弃一半我们知道不包含期望值的部分。事实上，另一种对集合进行排序的方法是按 _顺序_ 对这棵树进行 深度优先 遍历！</p><p>BST 的创建发生在 _线性_ 时间和空间中，但是搜索它需要 _对数_ 时间和 _恒定_ 空间。</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="yPRPgj" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Binary Search Tree"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/yPRPgj/" target="_blank" rel="noopener"><br>  Binary Search Tree</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><p>要验证二叉树是否为BST，我们可以递归检查每个左子项是否总小于根（最大可能），并且每个右子项总大于 <em>每个根</em> 上的根（最小可能）。这种歌方法需要 _线性_ 时间和 _恒定_ 空间。</p><p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="ooaoPb" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Validate a Binary Search Tree"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/ooaoPb/" target="_blank" rel="noopener"><br>  Validate a Binary Search Tree</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在现代Web开发中，<strong>函数</strong> 是Web体验的核心。<strong>数据结构</strong> 被函数接受和返回，而 <strong>算法</strong> 则决定了内部的机制。算法的数据结构的数量级由 <em>空间复杂度</em> 描述，计算次数的数量级由 <em>时间复杂度</em> 描述。在实践中，运行时复杂性表示为 <strong>Big-O</strong> 符号，可帮助工程师比较所有可能的解决方案。最有效的运行时是 _恒定_ 时间，不依赖于出入值的大小；最低效的方法需要运算 _指数_ 时间和空间。真正掌握算法和数据结构是指可以同时 _线性_ 和 _系统_ 的推理。</p><p>理论上说，每一个问题都具有 <strong>迭代</strong> 和 <strong>递归</strong> 的解决方案。迭代算法是从底部开始 _动态_ 的接近解决方案。递归算法是从顶部开始分解 <em>重复的子问题</em> 。通常，递归方案更直观且更易于实现，但是迭代方案更容易理解，且对内存需求更小。通过 <em>一流的函数</em> 和 <em>控制流</em> 结构，JavaScript 天然支持这两种方案。通常来说，为了达到更好的性能会牺牲一些空间效率，或者需要牺牲性能来减少内存消耗。正确的平衡两者，需要根据实际上下为和环境来决定。值得庆幸的是，大多数面书馆都更关注 <em>计算推理过程</em> 而不是结果。</p><p>为了给你的面试官留下深刻的印象，要尽量寻找机会利用 <strong>架构设计</strong> 和 <strong>设计模式</strong> 来提升 <em>可复用性</em> 和 <em>可维护性</em> 。如果你正在寻找一个资深职位，对基础知识和第一原则的掌握与系统级设计的经验同样重要。不过，最好的公司也会评估 <em>文化契合</em> 度。因为没有人是完美的，所以合适的团队是必不可少的。更重要的是，这世上的一些事是不可能凭一己之力达到的。大家共同创造的东西往往是最令人满意和最有意义的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaScript-算法&quot;&gt;&lt;a href=&quot;#JavaScript-算法&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 算法&quot;&gt;&lt;/a&gt;JavaScript 算法&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn-imag
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用 RIBs 重构 Uber 司机端</title>
    <link href="https://hongruqi.github.io/2019/02/22/%E4%BD%BF%E7%94%A8%20RIBs%20%E9%87%8D%E6%9E%84%20Uber%20%E5%8F%B8%E6%9C%BA%E7%AB%AF/"/>
    <id>https://hongruqi.github.io/2019/02/22/使用 RIBs 重构 Uber 司机端/</id>
    <published>2019-02-21T16:00:00.000Z</published>
    <updated>2019-02-23T06:43:38.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-RIBs-重构-Uber-司机端"><a href="#使用-RIBs-重构-Uber-司机端" class="headerlink" title="使用 RIBs 重构 Uber 司机端"></a>使用 RIBs 重构 Uber 司机端</h1><p><a href="https://eng.uber.com/wp-content/uploads/2018/11/Carbon_architecture_feature_169.png" target="_blank" rel="noopener"><img src="https://eng.uber.com/wp-content/uploads/2018/11/Carbon_architecture_feature_169-696x392.png" alt="Uber新司机端RIBs架构" title="Architecting Uber&#39;s New Driver App in RIBs feature image"></a></p><p><em>本文是 Uber 的客户端工程师团队是如何开发最新版本司机端的系列文章中的第二篇，代号 <a href="https://eng.uber.com/tag/carbon/" target="_blank" rel="noopener">Carbon</a> ，是我们拼车业务的一个核心组件。除了其他新功能之外，司机端 APP 还为超过 300万 司机提供收入，引导他们挣钱。2017年我们结合司机的反馈开始对司机端进行重新设计，并在2018年9月份启动了该项目。</em></p><p>重新编写一个APP会引发关于新架构和新设计相关的许多问题。迄今为止，大多数开发者只关注应用程序如何正常工作。虽然以用户为中心的设计理念已经成为软件开发中的一些主流，但是辨别真实有效的用户需求并不容易。</p><p>一旦决定 <a href="https://eng.uber.com/rewrite-uber-carbon-app/" target="_blank" rel="noopener">重构Uber司机端</a>, 我们必须以广泛多样的用户群里为基准，寻找如何设计更适用的工作流和保留最适用的产品功能。 我们收集全世界各个城市的Uber司机的反馈，将这些反馈作为我们用户体验的重要初衷。</p><p>与此同时，我们也必须考虑到，成百数千的工程师们，他们需要重构APP的同时也要功能迭代。一个经过深思熟虑的APP架构需要帮助工程师，在保证可靠性的同时高效、快速的工作。</p><p>幸运的是，Carbon 在满足这些服务时并没有发生冲突，这些服务包括更实用的应用流程，改善司机体验功能，为开发者提供灵活稳定的架构，事实证明，它们结合的非常好。</p><p>本篇文章，阐述了我们是为了适应新司机端（代码Carbon）如何提出核心需求，并且讨论使用<a href="https://github.com/uber/RIBs" target="_blank" rel="noopener">RIBs架构</a>和插件设计，来满足司机端应用逻辑。</p><h2 id="规模发展"><a href="#规模发展" class="headerlink" title="规模发展"></a>规模发展</h2><p>自2013年发版以来，Uber司机端积累了需要功能。在未来的四年之后Uber司机端将成为司机的核心工具。随着应用程序的日益复杂，Uber确实做到组织化。上百个功能由横跨公司40多个不同子团队开发和维护。截止2017年1月，Android司机端已经拥有由近200个工程师编写出428,685行代码。iOS司机端由200多工程师贡献720,273行代码。更为重要的是，我们的APP安装在超过300万的设备中，每天超过100个国家中的100万个司机使用。</p><p>对于Carbon的成功，我们知道我们需要及时更新所有现有功能（已经一些新功能）的同时，也需要并行更新架构。</p><h3 id="一起建设"><a href="#一起建设" class="headerlink" title="一起建设"></a>一起建设</h3><p>产品开发需要时刻记住用户。为此，我们想和Uber司机一起创建构建我们的应用。在开发的最初阶段，我们在用户调研上投入大量资金。在11个国家，12个城市中采访了500位司机。</p><p><a href="https://www.youtube.com/watch?v=_6gQxnpwdw4" target="_blank" rel="noopener"></a></p><p>这些访谈对象帮我们设计新司机端的用户体验，确定最重要的功能。但是，除非司机在在真实条件下在实际道路中使用APP，否则无法获取完整的用户体验。我们需要一种方法，它可以允收集用户反馈，快递迭代并每周发布新版本。</p><p><a href="https://eng.uber.com/wp-content/uploads/2018/11/Carbon_architecture_Figure_01.png" target="_blank" rel="noopener"><img src="https://eng.uber.com/wp-content/uploads/2018/11/Carbon_architecture_Figure_01.png" alt="Uber司机App的三种设计"></a></p><p>图一：在测试期间，为APP使用最初设计。</p><h3 id="实现可靠性"><a href="#实现可靠性" class="headerlink" title="实现可靠性"></a>实现可靠性</h3><p>最难并且最重要的挑战是，在实际测试中的稳定性。当接触一个新APP，在Alpha和Beta测试阶段可以接受错误和问题。Uber司机端在Beta阶段，真实的司机已经可以在实际道路中可以使用它挣钱了。实现可靠性是Carbon的关键目标。所以，进入首次测试阶段时，我们必须确保Carbon像现有程序一样可靠。</p><h2 id="解耦规模化开发"><a href="#解耦规模化开发" class="headerlink" title="解耦规模化开发"></a>解耦规模化开发</h2><p>阐述了现在工程的限制后，我们采用了分段性方法，将项目分为四个阶段。每个阶段的目标是开启下个阶段的开发。</p><h3 id="第一阶段-基础设施"><a href="#第一阶段-基础设施" class="headerlink" title="第一阶段: 基础设施"></a>第一阶段: 基础设施</h3><p>我们拥有一个通用模板，来描述我们的APP必须包含哪些因素。这个模板包括网络库，存储库，<a href="http://reactivex.io/" target="_blank" rel="noopener">ReactiveX</a>，分析追踪，崩溃上报和我们的自研的应用架构Ribs。利用这个模板，我们构建了具备初始化架构的程序，包括存储能力，网络，崩溃上报和基础组件。然儿，在这个阶段。程序缺少司机业务功能，这仅仅是我们构建特性的框架。</p><h3 id="第二阶段-应用层设施"><a href="#第二阶段-应用层设施" class="headerlink" title="第二阶段: 应用层设施"></a>第二阶段: 应用层设施</h3><p>使用RIBs框架的一个好处是，它如何将业务逻辑作为应用程序体系结构的核心。在Carbon阶段，一个好的起点是为司机定义高标准的用户状态。这将导致我们为RIBs定义一些基础:</p><ul><li><strong>Root</strong>: 当启动应用时，Root启动基于RIBs应用程序的所有必要文件。</li><li><strong>Logged Out</strong>: 如果用户没有有效的会话时，我们需要一个RIBs为用户创建一个账户，登录并且获取有效凭证。</li><li><strong>Logged In</strong>: 一旦用户身份验证通过，分离注销的RIBs，将登录的RIBs添加到有效的会话中</li><li><strong>Active</strong>: 有时一个司机用户可以登录，但是不能做其他操作（他们的账户由于各种原因被封锁）。这个RIBs确保他们有一个有效的会话_并且_允许使用程序。</li></ul><p>我们利用RIBs树图，如下图2所示，说明应用架构。这个简单的树形图展示了，如何使用RIBs组件相互关联。</p><p><a href="https://eng.uber.com/wp-content/uploads/2018/11/Carbon_architecture_Figure_02.gif" target="_blank" rel="noopener"><img src="https://eng.uber.com/wp-content/uploads/2018/11/Carbon_architecture_Figure_02.gif" alt="RIBs数"></a></p><p>图二:RIBs树图向我们展示了组件关联的可视化方法。</p><p>在关注用户阶段，我们可以将UI分离出来。这个方法可以促使从司机中吸取持续反馈建议，并将建议吸纳到设计中。同时促使我们维护用户程序的基本。</p><h3 id="第三阶段-功能框架"><a href="#第三阶段-功能框架" class="headerlink" title="第三阶段: 功能框架"></a>第三阶段: 功能框架</h3><p>在一些基础上，我们重点转移到协作中。在第三阶段，我们的目标是扩大规模，使大约40个团队在同一个APP中可靠无缝的并行工作。基于用户的反馈和设计、产品团队的协作，我们定义出更详细的RIBs组件。</p><ul><li><strong>任务</strong>: 当司机在线和工作时如果体验APP (例如, 导航到乘客位置, 开始行程, 乘客下车, 接另一个单, 等等.).</li><li><strong>行程 (行程规划)</strong>: 司机规划行程的关键地区。在此，他们可以清晰的看到他们需要做的：接驾乘客到送餐。如果它是空的，它会给司机从哪里什么时间提供服务的建议。</li><li><strong>个人中心</strong>: <strong>这是司机管理业务的区域。它包含实际行程之外的所有内容：重要通知，评级，收入等等</strong></li><li><strong>地图</strong>: 在司机端中许多和地图相关的功能，例如导航，热力图，和其他使用新RIBs开发的地图库。这是一个在地图框架上的抽象层。有趣的是，如下图展示。这个地图库在APP中视为非核心功能。这意味着，如果地图功能遇到灾难性问题（当然我们希望永远不要发生！），我们可以禁用它，允许司机继续使用。</li></ul><p>在合并了框架之后，RIBS树结构变大了，如下面的图三所示。</p><p><a href="https://eng.uber.com/wp-content/uploads/2018/11/Carbon_architecture_Figure_04-1.gif" target="_blank" rel="noopener"><img src="https://eng.uber.com/wp-content/uploads/2018/11/Carbon_architecture_Figure_04-1.gif" alt="RIBs树"></a></p><p>图三: 按照我们的定义在RIBs树中增加层级和新的功能框架。</p><p>在我们细分之前, 我们清晰下在使用的RIBs架构中的一些概念。</p><h4 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h4><p>这是一个对象，它直接关联到RIBs生命周期，具有启动/停止生命周期功能方法。换句话说，添加到RIBs的工作者从RIB连接时启动，RIB分离时停止。工作者确保交互(一个RIB的业务逻辑组件单元)不会太大，并且允许更好的分离关注点。(在我们的仓库中可以找到 <a href="https://github.com/uber/RIBs/blob/master/android/libraries/rib-base/src/main/java/com/uber/rib/core/Worker.java" target="_blank" rel="noopener">Android</a> 和 <a href="https://github.com/uber/RIBs/blob/master/ios/RIBs/Classes/Worker/Worker.swift" target="_blank" rel="noopener">iOS</a>)</p><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><p>插件是一种设计模式，插件允许我们用灵活的方式进行特征标记。(进一步了解Uber如果利用插件 <a href="https://eng.uber.com/plugins/" target="_blank" rel="noopener">上一篇文章</a>)。首先我们为集成的核心代码定义一个公用的API，然后开发者可以实现自己的API实例。这是因为他们了解代码由遵守这个架构的特征标记隐形保护。把每个插件点想象成微服务体系中一个服务，然后插件工厂作为该服务的消费者，这样将使得插件和API或者他们之间的契约相似。</p><p>结合RIBs，插件和工作者，可以定义出架构中的核心和非核心部分。核心组件是必须的组件，并且不能被标记成禁用。另一方面，如果非核心组件引入了重大问题或者导致回归，可以被禁用。在上面的图四种，Map和MyHub是非核心组件，他们可以在不关闭应用程序功能的基础上被禁用。</p><p>进一步查看图 4 中 RIBs 树图的细节功能，我们就能看到：如何使用核心 RIBs，Plugins，Workers， 以 worker/plugin 模式去实现 Agenda 的全部功能。Agenda 功能暴露了两个不同的插件点(plugin points): Agenda Worker 和 Agenda Section。 使用 Worker plugin point 集成非用户体验功能，Section plugin point 去扩展用户体验功能。</p><p><a href="https://eng.uber.com/wp-content/uploads/2018/11/Carbon_architecture_Figure_05.gif" target="_blank" rel="noopener"><img src="https://eng.uber.com/wp-content/uploads/2018/11/Carbon_architecture_Figure_05.gif" alt="RIBs树细节"></a></p><p>图四:仔细观察RIBs树的一部分，可以发现集成的多个领域，它允许在灵活添加特性，也允许并行开发。</p><p>使用这个设计模式，我们可以理解许多领域APP。例如一些工程师构建登录和注册界面，其他工程师重点开发非核心RIBs的地图架构。</p><h3 id="第四阶段-全员"><a href="#第四阶段-全员" class="headerlink" title="第四阶段: 全员"></a>第四阶段: 全员</h3><p>第四阶段，其他团队加入我们开放了Carbon的开发。由于想要确保每个功能彼此独立，我们创建到了插件框架，因此特性合并是一个相对顺畅的过程。如有必要，一些小RIBs上升为核心组件，但是我们大部分代码仍然包含在插件中，所以我们的架构中一些部分是可选性的（我们计划在后续章节中讨论一些令人兴奋的新特性）。</p><p><a href="https://eng.uber.com/wp-content/uploads/2018/11/Carbon_architecture_Figure_06.gif" target="_blank" rel="noopener"><img src="https://eng.uber.com/wp-content/uploads/2018/11/Carbon_architecture_Figure_06.gif" alt="RIBs架构到应用接口连接图"></a></p><p>图五: 如动画所示，RIBs生命周期与他们的各自单元相关</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>软件工程的架构是一个通常是在牺牲别的资源条件下去优化团队更为重要的一些指标。虽然我们的方法允许我们优化可靠性、可扩展性和模块化，但是其他方面我们必须妥协。在一个严谨的流程中，我们只允许少量的组件是核心组件。为了维护核心组件的质量，我们拥有一个内部审查团队，他们审查修改核心代码中每个代码。这个流程要求一些工程师投入一些时间去做核心代码审查，这也减慢了其他工程师的提交频率。</p><p>大多数应用开发者熟悉MVP或MVC模型。和他们相比，RIBs好像更冗长。RIBs有更多的组件，需要更多的前期规划。较小的软件开发团队也许不需要采用类似的流程。之前我们已经做完一个重构<a href="https://eng.uber.com/new-rider-app/" target="_blank" rel="noopener">重写我们的乘客端APP</a>，因此我对如何构建Carbon更清晰，我们将我们的学习总结如下：</p><ul><li><p><strong>按规模工作</strong>: 在Uber, _规模_ 既是最高限制也是最有价值资源. 300万司机在使用我们的APP，所以我们不能让他们失望。 同时, Uber作为一个技术组件公司，我们已经发展到数百万工程师一起构建应用程序。_规模_ 是我们从规划到推广决策的关键。</p></li><li><p><strong>RIBs to the rescue</strong>: Carbon通过使用RIBs和插件，我们在以下方面获得成绩:</p><ul><li><strong>模块化:</strong> 每个功能的开发不依赖于其他功能，除非它是核心RIBs。这个架构使得工程师们并行开发更便捷，不比担心影响其他RIBs。</li><li><strong>可扩展性:</strong> 树形结构可以通过添加子节点纵向扩展，可以通过添加兄弟节点横向扩展，也可以通过不同works将业务分离横向扩展。</li><li><strong>可靠性:</strong> 使用插件完成的核心和非核心概念允许我们禁用非核心代码，所以我们以最小损失代价进行快速转移。</li></ul></li><li><strong>共同构建</strong>: 如果没有司机的帮助，以及他们在用户调研和测试阶段给我们的建议，我们不可能做到这一点。</li></ul><h4 id="Index-of-articles-in-Uber-driver-app-series"><a href="#Index-of-articles-in-Uber-driver-app-series" class="headerlink" title="Index of articles in Uber driver app series"></a>Index of articles in Uber driver app series</h4><ol><li><a href="https://eng.uber.com/rewrite-uber-carbon-app/" title="Why We Decided to Rewrite Uber’s Driver App" target="_blank" rel="noopener">Why We Decided to Rewrite Uber’s Driver App</a></li><li>Architecting Uber’s New Driver App in RIBs</li><li><a href="https://eng.uber.com/driver-app-optimistic-mode/" target="_blank" rel="noopener">How Uber’s New Driver App Overcomes Network Lag</a></li><li><a href="https://eng.uber.com/driver-app-cash-payments/" target="_blank" rel="noopener">Scaling Cash Payments in Uber Eats</a></li><li><a href="https://eng.uber.com/carbon-dual-binary-mobile-app/" target="_blank" rel="noopener">How to Ship an App Rewrite Without Risking Your Entire Business</a></li><li><a href="https://eng.uber.com/building-a-scalable-and-reliable-map-interface-for-drivers/" target="_blank" rel="noopener">Building a Scalable and Reliable Map Interface for Drivers</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用-RIBs-重构-Uber-司机端&quot;&gt;&lt;a href=&quot;#使用-RIBs-重构-Uber-司机端&quot; class=&quot;headerlink&quot; title=&quot;使用 RIBs 重构 Uber 司机端&quot;&gt;&lt;/a&gt;使用 RIBs 重构 Uber 司机端&lt;/h1&gt;&lt;p&gt;&lt;a
      
    
    </summary>
    
      <category term="翻译" scheme="https://hongruqi.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Uber 新架构 RIBs 的前世今生</title>
    <link href="https://hongruqi.github.io/2019/02/22/Uber%20RIBs%20%E6%9E%B6%E6%9E%84/"/>
    <id>https://hongruqi.github.io/2019/02/22/Uber RIBs 架构/</id>
    <published>2019-02-21T16:00:00.000Z</published>
    <updated>2019-02-23T06:01:19.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Uber-新架构-RIBs-的前世今生"><a href="#Uber-新架构-RIBs-的前世今生" class="headerlink" title="Uber 新架构 RIBs 的前世今生"></a>Uber 新架构 RIBs 的前世今生</h1><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2016/12/new_rider_app.jpg" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2016/12/new_rider_app.jpg" alt title="new_rider_app"></a></p><h3 id="为什么-Uber-要重构移动端"><a href="#为什么-Uber-要重构移动端" class="headerlink" title="为什么 Uber 要重构移动端"></a>为什么 Uber 要重构移动端</h3><p>Uber 基于一个简单的概念：一键出行。 从最初优享到现在提供的一系列产品，每天在数百个城市协调数百万次乘车。 为了应对和支持2017年及以后的发展，我们迫切的需要重新设计我们的移动端架构。</p><p>但从哪里开始？ 我们决定重新开始。于是我们决定完全重构并重新<a href="https://medium.com/uber-design/designing-the-new-uber-app-16afcc1d3c2e#.wio2h7epr" target="_blank" rel="noopener">设计</a>我们的<a href="https://ride.uber.com/en_US/" target="_blank" rel="noopener">乘客端</a>。 由于不用被之前的设计和代码限制，在重构上我们有很大的发挥空间。<a href="https://newsroom.uber.com/newriderapp/" target="_blank" rel="noopener">结果就是你今天看到的这个时尚的新应用</a>, 它在iOS和Android上实现了新的移动架构。接下来的文章将介绍我们的新移动端架构 Riblets，让你了解为什么我们需要创建这种新架构模式，以及它如何帮助我们达成目标。</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>虽然共享出行仍然是 Uber 背后的驱动理念，但我们的产品已发展成为功能复杂的APP，我们原有的移动架构无法与之匹配。 随着乘客端App的新功能扩展，工程挑战和技术债务不断累积。增加了诸如<a href="https://newsroom.uber.com/us-california/its-a-beautiful-pool-day-in-the-neighborhood/" target="_blank" rel="noopener">拼车</a> ，<a href="https://www.uber.com/info/scheduled-rides/" target="_blank" rel="noopener">预约乘车</a> 和促销车辆视图等功能，导致工程的复杂性逐步升高。 我们的行程模块变得越来越大，难以测试。 加入小变化有可能影响到应用程序的其他部分，使得功能尝试增加额外调试任务，从而抑制了我们快速迭代和功能实验。 为了给所有 Uber 用户的高质量体验，我们需要一种方法，重新找回起点的简单，同时考虑今天的处境和未来的目标。</p><p>对于乘客和 Uber 工程师来说，新的应用程序必须简单。 为了适用于不同的群体，我们的两个主要目标是：持续增加有效的核心用户体验，并且允许在系列产品需求序列中做大胆实验。</p><h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><p>从工程方面来说，我们正在努力使 Uber 的行程主流程的可靠性达到 99.99％。 实现99.99％的可靠性意味着我们每年只能有一个累计小时的停机时间，一周的停机时间为一分钟，每10,000次运行只有一次失败。</p><p>为了实现这一目标，新架构定义并实现了核心和可选代码的框架。 核心代码包括注册，获取，完成或取消行程所需的一切代码。 对核心代码的更改和添加需要经过严格的审核流程。 可选代码可以降低审查力度，可以在不停止核心业务的情况下关闭。 这种代码隔离机制使我们能够尝试新功能，并在异常情况下自动关闭它们，而不会干扰乘车体验。</p><h4 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h4><p>我们需要一个平台，一百个不同的项目团队和数千名工程师可以快速构建高质量的功能，并在乘客端上进行创新，而不会影响核心用户体验。 因此，我们提供了新的移动端架构，具有跨平台兼容性，确保iOS和Android工程师都可以在统一的基础上工作。</p><p>从历史上看，在 iOS 和 Android 上发布最好的应用程序涉及不同的架构、库设计和分析方法。 但是，新架构致力于在两个平台上使用相同的最佳模式和实践。 这给了我们学习两个平台的机会。 由于一个平台的经验教训可以预先解决另一个平台上的问题，从而避免了同样的错误在两个平台重复出现。 因此，iOS 和 Android 工程师可以更轻松地进行协作，并且可以并行处理新功能。</p><p>虽然在某些情况下，平台之间可以也应该是不同的(例如 UI 实现)，但是 iOS 和 Android 移动平台都是从一致性出发。平台共享:</p><ul><li>核心架构</li><li>类名</li><li>业务逻辑单元之间的继承关系</li><li>业务逻辑如何划分</li><li>插件点 (名字, 存在,结构等)</li><li>响应式编程链</li><li>统一平台组件</li></ul><p>为了实现平台之间的这种通用蓝图，我们的新移动架构需要清晰的组织和分离业务逻辑，视图逻辑，数据流和路由。这种架构有助于降低复杂性，简化可测试性，从而提高工程效率和用户可靠性。 我们在其他架构模式上进行了创新以实现此目标。</p><h3 id="从-MVC-到-Riblets"><a href="#从-MVC-到-Riblets" class="headerlink" title="从 MVC 到 Riblets"></a>从 MVC 到 Riblets</h3><p>考虑到我们的两个目标，我们调查了旧架构可以改进的地方，并研究了可行的方案。Uber 旧的代码遵循[MVC 模式]（<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html）。我们调查了其他模式，特别是[VIPER]（https://mutualmobile.com/posts/meet-viper-fast-agile-non-lethal-ios-architecture-framework），我们最终用它来创建" target="_blank" rel="noopener">https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html）。我们调查了其他模式，特别是[VIPER]（https://mutualmobile.com/posts/meet-viper-fast-agile-non-lethal-ios-architecture-framework），我们最终用它来创建</a> Riblets。Riblets 的核心创新是业务逻辑驱动，而不是视图逻辑驱动。 如果您不熟悉 MVC 和 VIPER，请阅读一些[关于现代 iOS 架构模式的文章]（<a href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52#.ba5863nnx），然后回过头来看看在" target="_blank" rel="noopener">https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52#.ba5863nnx），然后回过头来看看在</a> Uber 采用它们的利弊。</p><h4 id="MVC-Model-View-Controller"><a href="#MVC-Model-View-Controller" class="headerlink" title="MVC (Model-View-Controller)"></a>MVC (Model-View-Controller)</h4><p>乘客端应是在大约四年前由少数几个工程师创建的。 虽然 MVC 模式在当时是有意义的，但随着程序的规模越来越大，也就越来越难以管理。 随着业务的增长和团队的扩大， MVC 的弊端越发明显。具体来说，有两大问题：</p><p>首先，成熟的 MVC 架构经常面临<a href="https://www.smashingmagazine.com/2016/05/better-architecture-for-ios-apps-model-view-controller-pattern/" target="_blank" rel="noopener">重量级视图控制器</a>的困境。例如，RequestViewController 刚开始有 300 行代码，由于处理了太多的功能（业务逻辑，数据操作，数据验证，网络逻辑，路由逻辑等），现在超过 3,000 行。它变得难以阅读和维护。</p><p>其次，MVC 架构的更新过程是不易维护和测试的。我们进行了大量实验，为用户推出了新功能。 这些实验归结为 if-else 语句。 每当将 if-else 语句构建在一个具有许多功能函数的类上时，导致几乎无法推理，更不用说测试了。 此外，由于像RequestViewController 和 TripViewController 代码巨大并且快速增长，因此对应用程序进行更新变得更加空难。 想象一下，进行更改并测试嵌套 if-else 实验的每种可能组合将是多么的困难。由于我们需要实验来继续添加新功能并增加 Uber 的业务，因此这种架构不具备可扩展性。</p><h4 id="VIPER"><a href="#VIPER" class="headerlink" title="VIPER"></a>VIPER</h4><p>在考虑 MVC 的替代方案时，我们受到 VIPER 架构的启发。<a href="https://mutualmobile.com/in-the-news/architecting-ios-apps-viper" target="_blank" rel="noopener">适用于</a> iOS 应用程序的<a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="noopener">简洁架构</a>。VIPER 为 MVC 提供了一些关键优化。首先，它提供了更多的抽象。Presenter 桥接视图逻辑和业务逻辑。Interactor 处理纯粹的数据操作和数据验证，包括向服务层发起调用，例如登录或者发单。最后，Router 启动跳转，例如将用户从首页带到确认页。其次，使用 VIPER 方法，Presenter 和 Interactor 是普通对象，因此我们可以进行简单的单元测试。</p><p>但我们也发现了 VIPER 的一些缺点。它是 iOS 独有架构，意味着我们必须为 Android 做出权衡。由于整个应用程序被固定在视图树上，也就意味着状态由视图驱动。 Interactor 必须通过 Presenter 操作应用程序的业务逻辑，因此需要暴露业务逻辑给 Presenter。至此，通过紧密耦合的视图树和业务树，很难实现仅包含业务逻辑或仅包含视图逻辑的业务节点，无法达到解藕的目的。</p><p>虽然 VIPER 对使用的 MVC 模式进行了重大改进，但它并没有完全满足，清晰的模块化定义，和高可扩展性。所以我们在兼顾 VIPER 优势，同时规避其架构模式缺点的基础上，实现了我们自己的架构： Riblets。</p><h3 id="Riblets-Uber-乘客端架构"><a href="#Riblets-Uber-乘客端架构" class="headerlink" title="Riblets: Uber 乘客端架构"></a>Riblets: Uber 乘客端架构</h3><p>在我们的新架构模式中，业务逻辑被分解为小的，可独立测试的单元，每个单元目的明确，遵循单一责任原则。 我们使用 Riblets 作为这些模块化部件，整个应用程序结构为 Riblets 树。</p><h4 id="Riblets-组件"><a href="#Riblets-组件" class="headerlink" title="Riblets 组件"></a>Riblets 组件</h4><p>通过 Riblets，我们将职责分配给六个不同的组件，进一步抽象业务和视图逻辑：</p><p><a href="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2016/12/riblets.png" target="_blank" rel="noopener"><img src="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2016/12/riblets.png" alt></a></p><p>Riblets 与 VIPER 和 MVC 的区别是什么？路由由业务逻辑而非视图逻辑引导。这意味着应用程序由信息流和决策流驱动，而不是 Presenter。在Uber，并非每个业务逻辑都与用户看到的视图相关。不是将业务逻辑集中到 MVC 中的 ViewController 或通过 VIPER 中的 Presenter 操作应用程序状态。我们可以为每个业务逻辑提供不同的 Riblets，这些 Ribltes 可以组合出不同意义的逻辑分组。 Riblet 模式被设计为​​跨平台的，达到统一 Android 和 iOS 架构的目的。</p><p>每个 Riblet 由 <strong>R</strong>outer，<strong>I</strong>nteractor 和 <strong>B</strong>uilder 及其 Component 和可选的 Presenters 和 Views 组成。Router 和 Interactor 处理业务逻辑，而 Presenter 和 View 处理视图逻辑。</p><p>让我们使用车型切换 Riblet 作为示例，确定每个 Riblet 单元负责的内容。</p><p><a href="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2016/12/product_selction.png" target="_blank" rel="noopener"><img src="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2016/12/product_selction.png" alt></a></p><p>新乘客端APP，车型切换功能。</p><h4 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h4><p>Builder 实例化所有主要 Riblet 单元并定义依赖关系。 在车型切换 Riblet 中，此单元定义城市流（特定城市的数据流）依赖关系。</p><h4 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h4><p>Component 获取并实例化 Riblet 的依赖项。 这包括服务，数据流以及其他不是主要 Riblet 单元的内容。 车型切换组件获取并实例化城市流依赖关系，将其与对应的网络事件进行关联，并将其注入到 Interactor。</p><h4 id="Routers"><a href="#Routers" class="headerlink" title="Routers"></a>Routers</h4><p>Routers 通过添加和删除 子Riblets 形成应用程序树，同时驱动组件内 Interactor 的生命周期。 这些决定由外部 Interactor 传递。路由器包含两个业务逻辑：</p><ol><li>添加和删除组件</li><li>子组件间状态切换</li></ol><p>车型切换 Riblet 没有任何子 Riblets。 其父 Riblet 的 Router， 确认 Riblet 负责添加车型切换的 Router 并将其 Views 添加到 View 层次结构中。 然后，一旦选择了车型，车型切换 Router 将停用其 Interactor。</p><h4 id="Interactors"><a href="#Interactors" class="headerlink" title="Interactors"></a>Interactors</h4><p>Interactors 执行业务逻辑：</p><ul><li>调用服务来启动操作，比如请求搭车</li><li>调用服务来获取数据</li><li>决定要转换到下一个的状态。 例如，如果根 Interactor 监听到用户的身份验证令牌过期，它会向其 Router 发送切换到 “欢迎” 状态的请求。</li></ul><p>车型切换 Interactor 包含城市流数据，包括该城市服务的车型，定价信息，预估行程时间和车辆视图。 它将此信息传递给 Presenter。 如果用户从拼车切换到优享，则 Interactor 会从 Presenter 接收此信息。 然后它会收集相关数据传给 View，这样它就可以显示 uberX 车辆和预估行程时间。 简而言之，Interactor 执行随后 View 中显示的所有业务逻辑。</p><h4 id="View-Controller"><a href="#View-Controller" class="headerlink" title="View (Controller)"></a>View (Controller)</h4><p>视图构建和更新UI，包括实例化和布局 UI 组件，处理用户交互，UI 组件数据填充和动画。 车型切换 Riblet 的 View 显示它从 Presenter 接收的数据（车型选项，定价，ETA，地图上的车辆视图）并反馈用户操作（即车型切换）。</p><h4 id="Presenter"><a href="#Presenter" class="headerlink" title="Presenter"></a>Presenter</h4><p>Presenters 管理 Interactors 和 Views 之间的通信。 从 Interactors 到 Views，Presenter 将业务模型转换为 View 可以显示的模型。 对于车型切换，这包括定价数据和车辆视图。 从 Views 到 Interactors，Presenters 将用户交互事件（例如，点击按钮选择车型）转换为 Interactors 中的相应操作。</p><h3 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h3><p>Riblets 只有一个 Router 和 Interactor，但可以有多个 View 部分。仅处理业务逻辑且没有用户界面元素的 Riblet 没有视图部分。 因此，Riblets 可以是单视图（一个 Presenter 和一个 View），多视图（一个 Presenter 和多个 Views，或多个 Presenter 和 Views），或者是无视图（没有 Presenter 和 View）。 这允许业务逻辑树的结构和深度与视图树不同，视图树将具有更平坦的层次结构。 这有助于简化页面切换。</p><p>例如，乘车 Riblet 是一个无视图的 Riblet，用于检查用户是否有有效的行程。如果已经开始行程，它添加行程 Riblet，将行程显示在地图上。如果没有，它将添加请求 Riblet，请求 Riblet 将在屏幕显示，允许用户请求行程。像乘车 Riblet 这样没有视图逻辑的 Riblet，通过分解业务逻辑驱动应用程序，在支持这种新体系结构的模块化方面，发挥了重要作用。</p><h3 id="Riblets-构建应用程序"><a href="#Riblets-构建应用程序" class="headerlink" title="Riblets 构建应用程序"></a>Riblets 构建应用程序</h3><p>Riblets 组成了应用程序树，并且经常需要进行通信以便更新信息或将用户带到下一阶段。 在我们讨论他们如何通信之前，让我们首先了解数据在一个 Riblet 中是如何流动的。</p><h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><p>Interactors 拥有状态的作用范围和业务逻辑。该单元进行服务调用获取数据。 在新架构中，数据是单方向流动的。 它从 Service 到 Model Stream，然后从 Model Stream 到 Interactor。 来自服务器的交互，调度和推送通知可以要求 Service 对 Model Stream 进行更改。Model Stream 生成不可变模型。 这强制要求 Interactors 类必须使用服务层来更改应用程序的状态。</p><p><a href="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2016/12/data_flow.png" target="_blank" rel="noopener"><img src="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2016/12/data_flow.png" alt></a></p><p>示例流程：</p><ul><li><p><strong>从后端服务到视图:</strong> 服务调用（如状态）从后端获取数据。 将数据放置在不可变 Model Stream 上。 Interactor 监听新数通知并将其传递给 Presenter。 Presenter 格式化数据并将其发送给 View。</p></li><li><p><strong>从视图到后端:</strong> 用户点击按钮（如登录），然后 View 将交互传递给 Presenter。 Presenter 在 Interactor 上调用登录方法，该方法调用 Service 进行登录。 返回的令牌由 Service 在数据流上发布。 Interactor 监听数据流，收到通知后 Interactor 切换 Riblet 到首页 Riblet。</p></li></ul><h4 id="Riblets-间通信"><a href="#Riblets-间通信" class="headerlink" title="Riblets 间通信"></a>Riblets 间通信</h4><p><a href="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2016/12/riblet_comms.png" target="_blank" rel="noopener"><img src="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2016/12/riblet_comms.png" alt></a></p><p>当 Interactor 做出业务逻辑决策时，它可能需要通知另一个 Riblet（例如，完成）并发送数据。为实现此目的，做出业务逻辑决策的 Interactor 调用另一个 Riblet 的 Interactor 。</p><p>通常，如果通信是 Riblet 树上，从子 Riblet 传递到父 Riblet 的 Interactor，则该接口被定义为侦听器。侦听器几乎总是由父 Riblet 的 Interactor 实现。如果通信向下传递给子 Riblet，则应将接口定义为代理，并由子 Riblet 的 Interactor 实现。代理仅用于 Riblet 单元之间的同步通信，例如父 Interactor 与子 Interactor 之间的同步。</p><p>特别是对于向下通信，作为代理的替代方法, 父 Riblet 可以选择将可观察的数据流暴露给子 Riblet 的 Interactor。然后，父 Riblet 的 Interactor 可以通过此流将数据发送到子 Riblet 的 Interactor。在大多数用于发送数据的向下通信中，这应该是首选的通信方法。</p><p>例如，车型切换 Interactor 确定已选择车型时，它会调用其侦听器以传递所选的车辆视图 ID。侦听器由确认 Interactor实现。然后，确认 Interactor 存储车辆视图 ID，以便可以在服务请求中发送，调用其 Router 分离车型切换 Riblet。</p><p>通过以上方式构建 Riblets 内部和 Riblets 之间的数据流通信，我们能够确保在正确的页面正确的时间出现正确的数据。因为 Riblets 基于业务逻辑形成应用程序树，所以我们可以通过业务逻辑（而不是视图逻辑）来路由通信。这对我们的业务意义重大，并最终有助于代码隔离，防止应用程序开发变得过于复杂。</p><h3 id="回到起点"><a href="#回到起点" class="headerlink" title="回到起点"></a>回到起点</h3><p>当我们重新开始乘客端时，希望提高乘客体验的可靠性和为未来的应用程序开发建立标准规范。创建新架构对于实现这两个目标至关重要。</p><h4 id="如何提高乘车体验的可靠性"><a href="#如何提高乘车体验的可靠性" class="headerlink" title="如何提高乘车体验的可靠性 ?"></a>如何提高乘车体验的可靠性 ?</h4><p>Riblets 有明确的职责划分，因此测试更加简单。每个 Riblet 都是可独立测试的。通过更充分的测试，当推出更新时，我们可以对应用的可靠性更有信心。由于每个 Riblet 只负责一个任务，因此很容易将 Riblet 及其依赖项分离到核心代码和可选代码中。通过对核心代码进行更严格的审查，我们可以对核心流程的可用性更有信心。</p><p>我们提供了核心流程全局回滚到可用状态的能力。所有可选代码都具备开关能力，如果部分功能有问题，可以将其关闭。在最糟糕的情况下，我们可以关闭全部可选代码，保留默认的核心流程。由于我们在核心代码上有超高的标准，可以确保我们的核心流程始终有效。</p><h4 id="如何为开发建立标准规范"><a href="#如何为开发建立标准规范" class="headerlink" title="如何为开发建立标准规范 ?"></a>如何为开发建立标准规范 ?</h4><p>Riblets 帮助我们尽可能缩小和分离功能。清晰的分离业务和视图逻辑，将有助于防止我们的代码库变得过于复杂并使其易于工作。由于新架构与平台无关，因此 iOS 和 Android 工程师可以轻松了解对方如何开发，从一方的错误中吸取教训，并共同推动 Uber 向前发展。由于 Riblets 帮助我们将可选代码与核心代码分开，因此实验将不太容易对核心体验产生附带影响。我们将能够在 Riblet 架构中将新功能作为插件进行尝试，而不必担心它们可能会意外地将 uberX 和 uberPOOL 体验置于bug 的风险之中。</p><p>由于 Riblets 加强了抽象和责任分离，并且有明确的数据流和通信路径，因此持续开发变得很容易。这种架构将在未来几年内为我们服务。</p><h3 id="星辰大海"><a href="#星辰大海" class="headerlink" title="星辰大海"></a>星辰大海</h3><p>我们的新架构使我们为未来的发展做好了准备。最新的重构意味着完全重做乘客端的代码，重新实现以前存在的内容，执行用户研究，案例研究，A/B 测试以及编写新功能。最重要的是，我们希望进行全球推广，以便更快地将新应用程序交付给用户，因此我们从设计，功能，本地化，设备和测试角度考虑了全球变化。 虽然已经投放市场，但我们新架构下的工作才刚刚开始。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Uber-新架构-RIBs-的前世今生&quot;&gt;&lt;a href=&quot;#Uber-新架构-RIBs-的前世今生&quot; class=&quot;headerlink&quot; title=&quot;Uber 新架构 RIBs 的前世今生&quot;&gt;&lt;/a&gt;Uber 新架构 RIBs 的前世今生&lt;/h1&gt;&lt;p&gt;&lt;a
      
    
    </summary>
    
      <category term="翻译" scheme="https://hongruqi.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
  <entry>
    <title>为什么我们决定重构 Uber 司机端</title>
    <link href="https://hongruqi.github.io/2019/02/21/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E5%86%B3%E5%AE%9A%E9%87%8D%E6%9E%84%20Uber%20%E5%8F%B8%E6%9C%BA%E7%AB%AF/"/>
    <id>https://hongruqi.github.io/2019/02/21/为什么我们决定重构 Uber 司机端/</id>
    <published>2019-02-20T16:00:00.000Z</published>
    <updated>2019-02-23T06:30:54.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么我们决定重构-Uber-司机端"><a href="#为什么我们决定重构-Uber-司机端" class="headerlink" title="为什么我们决定重构 Uber 司机端"></a>为什么我们决定重构 Uber 司机端</h1><p><a href="https://eng.uber.com/wp-content/uploads/2018/10/Carbon_rewrite_feature_image_lrg.png" target="_blank" rel="noopener"><img src="https://eng.uber.com/wp-content/uploads/2018/10/Carbon_rewrite_feature_image_lrg-696x417.png" alt="Why We Decided to Rewrite Uber&#39;s Driver App" title="Driver App Rewrite: Why - feature image"></a></p><p><strong>本文是 Uber 的客户端工程师团队是如何开发最新版本司机端的系列文章中的第一篇，代号 <a href="https://eng.uber.com/tag/carbon/" target="_blank" rel="noopener">Carbon</a> ，是我们拼车业务的一个核心组件。除了其他新功能之外，司机端 APP 还为超过 300万 司机提供收入，引导他们挣钱。2017年我们结合司机的反馈开始对司机端进行重新设计，并在2018年9月份启动了该项目。</strong></p><p>2017年初，我们决定对司机端进行重构。这就是 StackOverflow 的 CEO Joel Spolsky <a href="https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/" target="_blank" rel="noopener">曾经</a> 说过的“任何一家软件公司都可能犯下的一个巨大的错误”的决定。</p><p>重构风险极高，需要集中大量资源，花费大量时间才能给用户带来收益。这次重要的重构，除了设计师、PM、数据分析师、运营、法务和市场之外，有几百名工程师参与。实际上，我们花费了一年半的时间才完成并推广到全球。</p><p>我们的情况是一个所有部门的工程师都面临的一个极端问题。如果你是一个正在准备编写或者准备重构某些代码或者一个功能的工程师，你或许会问：“我们有多少开发的时间？”，如果你在一个大的部门下面的一个小团队里面，你或许会问：“对一个没有开发的一个功能，是否值得做这么大的改变？”，一个出色的的工程师和一个出色的团队在准备接受重构的挑战的之前将会认真的研究一下这些广泛的问题。</p><p>因此，虽然重构过程中会涉及一些重要的技术决策（后续文章会有涉及），但需要综合技术考虑和广泛的业务问题来决定。虽然这些问题很难回答，但针对上述问题还是需要一个好的答案来向你的团队或者部门证明重构是合理的。</p><p>最后，这些决策不是凭空而来的。我们之所以决定重构 APP，并不是基于理论架构思维（“我们的代码可能会更好，如果我们……”），而是需要长达三个月的集中研究数百页的文档和广泛的跨组织的支持。在下面的章节中，我们将探讨重构 Uber 司机端的决定和我们在这个过程中发现了什么。</p><h2 id="奠定基础"><a href="#奠定基础" class="headerlink" title="奠定基础"></a>奠定基础</h2><p>重构的需要并不总是自然而然地来自于对新体系结构的简单认识。重构的代价是巨大的，虽然工程组织经常想要重构代码，但是工程师的时间还需要做新需求，而不是一遍又一遍的重构同一个功能。对于司机端来说，有以下三个趋势有助于推动重构的决定：</p><h3 id="技术债务"><a href="#技术债务" class="headerlink" title="技术债务"></a>技术债务</h3><p>首先，司机端本身存在技术债务。这些债务是优步快速增长的结果，也是产品需求变化的结果（下一节讨论）。不仅如此， 技术债务还来自于修复以前的技术债务：应用本身陷入了多次持续迁移，使得功能看起来越来越复杂。</p><p>值得指出的是司机端存在的技术债务不只是理论上的。由于持续的中断和维护成本导致开发人员生产力下降，我们看到了真正的业务影响。2016 年底，我们不得不暂停 APP 的开发，以修复多个功能退化。在我们解决这些问题之前，开发和启动新功能都变得非常困难。</p><p>任何中断对于我们司机端来说都是一个巨大的问题，因为用户依赖它谋生。我们认为，任何事都不能让可用时长低于 99.99% ，然而我们经常发布在应用核心流程中出现严重问题的版本。</p><h3 id="产品挑战"><a href="#产品挑战" class="headerlink" title="产品挑战"></a>产品挑战</h3><p>我们面临一个最大的问题就是司机端之前的版本无法很好地适用新的业务场景。早期只是简单的按照优选轿车去设计和迭代的司机端，但是现在我们的业务已经发展到还包含拼车、特价车和服务于市场线下现金交易体验等等。</p><p>我们发现除了打车业务，司机还需要其他的功能来管理他们的资产和私人业务。例如，收入和透明的评分对司机的体验至关重要，而在优步司机端的早期版本中这方面投资不足。我们需要提供类似这样功能的可扩展性，来提升产品体验。</p><p><a href="https://eng.uber.com/wp-content/uploads/2018/10/Figure_1_Carbon_rewrite.png" target="_blank" rel="noopener"><img src="https://eng.uber.com/wp-content/uploads/2018/10/Figure_1_Carbon_rewrite-1024x759.png" alt="Two screenshots of the previous driver app"></a></p><p>图一：司机端之前的版本中，底部的功能标签超出了之前的预期（左）。地图超负荷的承载了许多业务大头针和线路图（右）也超出了之前的预期。</p><p>我们在 2015年 和 2016年 采取了一些初步的步骤来减少这些痛点，发布了一个更新版本。不幸的是，我们为不同的团队设计了一些 UI ，而不是围绕司机的需求和工作流程设计。如果你在这段时间仔细看了我们的 UI ，你就会发现主页下面有四个标签：收入、评分、设置和首页。每个功能标签都变得越来越臃肿，并且收入和评分标签经常为了需求改变意图，而违背了设计初衷。</p><p>我们从 APP 的迭代中得到的教训，以及向着我们长期的产品规划，实际上已经促使我们彻底重新思考司机端应该如何寻找我们的司机合作伙伴。即使重构不是必然的，也需要重新设计。</p><h3 id="工程对齐"><a href="#工程对齐" class="headerlink" title="工程对齐"></a>工程对齐</h3><p>我们的研发团队预先在新的方向做了一些投入。特别是，伴随着 2016年 <a href="https://eng.uber.com/new-rider-app/" target="_blank" rel="noopener">乘客端的重构</a> 我们引进了一个新的移动端架构，我们叫做 <a href="https://github.com/uber/RIBs/wiki" target="_blank" rel="noopener">RIBs</a>（<a href="https://github.com/MindorksOpenSource/iOS-Viper-Architecture" target="_blank" rel="noopener">VIPER</a> 架构的一个演进），来帮助我们处理日益增长的规模。它能够解决在司机端的大多数问题：框架的可扩展性、强大的应用架构和有说服力的内存管理模块。我们在 2017年 开源了 RIBs 架构。</p><p>随着 RIBs 架构确实改进了我们的乘客端，同时它也代表了我们移动端组织一个新的方向。未来我们的核心平台将会主要投入在 RIBs 架构上。相比使用标准化的 RIBs 架构而言，每个应用都使用自己的架构将会花费更多的资金。</p><h2 id="决策过程"><a href="#决策过程" class="headerlink" title="决策过程"></a>决策过程</h2><p>拿到新的 UI 设计和一个新的架构，我们本质上有三个不同的做法：不使用 RIBs 架构重新设计司机端、让现有的司机端去适配 RIBs 架构和基于 RIBs 架构完全对司机端重构。</p><h3 id="不使用-RIBs-架构"><a href="#不使用-RIBs-架构" class="headerlink" title="不使用 RIBs 架构"></a>不使用 RIBs 架构</h3><p>第一个方法就是我们不使用 RIBs 架构重新设计。原因是我们考虑到迁移 RIBs 架构是资源密集型。虽然 RIBs 引入了大量新的代码库，但也是构建应用的一种新方式：将业务逻辑和显示逻辑解耦。RIBs 架构很有说服力，但浸入性非常强。</p><p>首先，我们考虑现有的应用是否能够处理我们正在考虑的主要的产品变更。我们发现，由于一部分逻辑在视图控制器里，导致许多业务逻辑和视图展示层是强耦合的。这也就意味着 UI 层面的重新设计必然会牵扯到许多业务逻辑的修改。</p><p>其次，正如前面所说，现有的司机端架构一些问题需要解决。这些问题部分正好与 app 的逻辑有关，有一些地方（特别是 Android ）都用一个模式开发是移动开发者的一个通病：不同版本的 MVC，都存在臃肿的视图控制器问题，我们大部分的核心代码都写在一个几千行的控制器文件里。因此，我们不愿意把现有架构变得更糟，变得越来越复杂和难以维护。</p><p>最后，虽然旧版本司机端的架构曾经是完美的，但是长远战略考虑适配 RIBs 架构能够避免在优步不同 app 的架构分歧。一种强有力的架构，能够给我们的平台带来双倍的收益，在一个团队（比如乘客端）写的代码还能在另一个团队（比如司机端）复用。</p><p>如果适配 RIBs，我们该怎么做呢？</p><h3 id="适配"><a href="#适配" class="headerlink" title="适配"></a>适配</h3><p>许多团队喜欢小心翼翼地迁移，这样能够允许他们在系统的架构变更的时候继续开发新功能。在大多数情况下这种方法是完美有效的，在这里我们讨论下优步这样做出现的一些问题。</p><p>首先，我们分析了过去几年在优步实施的十个主要的适配，发现它们的失败率很高。正如他们所说，我们将要开始适配一个基础库，但是彻底失败了。新功能是基于新的库开发的，一些旧的功能也适配了，但是基础库里面仍然有一些遗留代码在运行。</p><p>在进一步调查研究之后，我们发现司机端的许多技术债务的根本原因是这样的适配引起的。例如，我们有竞争条件因为我们的应用程序的发布订阅模式在安卓上是一分为二的。我们核心的应用架构最初是利用安卓的<code>fragments</code>，后来部分适配了内部框架。这种不完整的适配导致适配层和一般开发者的困惑。这些不完整的架构推进将会最后导致运行中断直接影响到我们的用户。</p><p>其次，我们经常发现在适配时造成大量的不稳定。我们有许多次宕机都是由于打算改善底层应用框架，例如网络协议。从技术上讲，这些不会对我们的用户造成直接的影响，但是最终会影响 app 的核心功能。</p><p>最后，在我们的经验中，甚至连继续开发功能的承诺都没有实现。如果一个团队依赖一个正在进行的适配，则经常会被阻塞直到适配工作完成。它还导致：回滚适配通常意味着我们还必须回滚大量的功能。</p><p>因此，当我们对是否进行完整的产品重新设计和采用 RIBs 架构评估后，不完整的适配或无止境的适配层极大的增加了应用程序的不稳定性的风险太高了。</p><h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p>在某种程度上，我们作出这个决定是通过否定（其他选项，不使用 RIBs 架构和适配，是不合理的），但是重构有决定的好处，它提高了我们做最后决定的信心。</p><p>第一，重构能够提高我们对重新设计 app 的生产力，而不需要受先理解以前是怎么工作的。也就意味着它的设计可以更加通用。</p><p>第二，选择重构也意味着我们的架构将会更加清晰，因为它将从一开始就会有一个令人信服的策略方向。如果我们选择适配，我们可能会被出于方便重用或者便利的遗留代码所卡住。</p><p>第三，对 app 的重构会促使我们走到画板面前更加完整的思考我们想要的产品方向。结果，app 中的某些主要框架将被重构。</p><p>对于一个工程师来说，重构是一个挑战自我的机会，我们迫不及待的要开始了。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>值得强调的是重构司机端的决定并不是基于“如果我们能重做就会更好”这样的想法。事实上，一些工程师肯能会惊讶的听到，即使在重构之后，我们发布的 app 不仅使用了新的功能和新的架构，甚至还有一点新的技术债务。</p><p>也就是说，你不可能把事情处理的非常完美。阅读了这篇文章的工程师应该对“适配不合理，重构才能写出完美的代码”这个结论质疑。相反，重要的是要意识到重构应该是在非常具体的组织，业务和技术需求下决定的。</p><p>如果我们没有在数月之前产出一个新的手机架构，或许不会重构。如果我们没有一个产品团队来调研的话，或许不会重构。如果优步之前的适配工作非常成功的话，我们或许不会重构。当然，促使我们重构的原因不是说重构一定是非常好的，甚至不是一个好主意。</p><p>反而，司机端的重构来自于想要为我们的用户创建一个更可靠和更强的产品体验，同时，在这个版本也增强了我们团队的能力。在做这个决定的过程中或许没有创建一个最佳抽象层那么兴奋，但它是成功的、完全的改进了手机应用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么我们决定重构-Uber-司机端&quot;&gt;&lt;a href=&quot;#为什么我们决定重构-Uber-司机端&quot; class=&quot;headerlink&quot; title=&quot;为什么我们决定重构 Uber 司机端&quot;&gt;&lt;/a&gt;为什么我们决定重构 Uber 司机端&lt;/h1&gt;&lt;p&gt;&lt;a hre
      
    
    </summary>
    
      <category term="翻译" scheme="https://hongruqi.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Uber Eats 支持现金支付</title>
    <link href="https://hongruqi.github.io/2019/02/20/Uber%20Eats%20%E6%94%AF%E6%8C%81%E7%8E%B0%E9%87%91%E6%94%AF%E4%BB%98/"/>
    <id>https://hongruqi.github.io/2019/02/20/Uber Eats 支持现金支付/</id>
    <published>2019-02-19T16:00:00.000Z</published>
    <updated>2019-02-23T06:46:09.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Uber-Eats-支持现金支付"><a href="#Uber-Eats-支持现金支付" class="headerlink" title="Uber Eats 支持现金支付"></a>Uber Eats 支持现金支付</h1><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/12/Carbon_Cash_feature_image.png" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/12/Carbon_Cash_feature_image-696x522.png" alt="Scaling Cash Payments in Uber Eats - feature_image" title="Scaling Cash Payments in Uber Eats - feature_image"></a></p><p>本文是 Uber 的客户端工程师团队讲述了如何开发最新版本司机端<a href="https://eng.uber.com/tag/carbon/" target="_blank" rel="noopener">系列</a>文章中的第四篇，该系列代号 Carbon ，是我们共享出行业务的核心。包括其它功能在内，Uber 司机端使得超过 300 万名司机可以查看费用、里程以及收益情况。2017 年我们结合司机的反馈开始对司机端进行重新设计，并在 2018 年 9 月份启动了该项目。 </p><p>Uber 作为全球性公司，努力使其服务保证可用。所以要利用技术做到功能本地化。其中关键的一项工作是使用户可以选择最有效的付款方式，无论是信用卡，借记卡，或者是当地特殊的支付方式，例如现金支付。</p><p>对于 Uber 的大部分市场来说，其出行业务和外卖业务所使用的普遍支付方式并不是信用卡和借记卡。直到 2016 年，这些线上支付方式是主要支持的类型，这使得那些只用现金支付的用户很难去使用我们的服务。首次<a href="https://eng.uber.com/india-payments/" target="_blank" rel="noopener">支持现金支付</a>是在孟买，这里的乘客只有少部分有信用卡。所以他们很欢迎使用现金支付，接着我们在印度，拉丁美洲，非洲也支持了这种方式。</p><p>然而，直到 2017 年 9 月，外卖服务才支持现金支付，首次支持的城市也是孟买。迟到 2 年的原因是: 外卖三方市场的复杂性，它包括餐厅，配送员和食客。</p><p>克服这项挑战，即要改变操作流程又要支持新的技术。尤其<a href="https://www.uber.com/newsroom/new-driver-app/" target="_blank" rel="noopener">我们新的司机端</a>( Carbon )支持扩展现金支付的能力。通过这些创新服务，我们能够给全球更多的用户提供外卖服务。</p><h2 id="现金收款的挑战"><a href="#现金收款的挑战" class="headerlink" title="现金收款的挑战"></a>现金收款的挑战</h2><p>在出行业务支持现金支付的城市，司机留下现金，然后从线上支付的订单中去支付 Uber 的费用。这种情况下，智能派单系统保证司机接到足够的线上支付订单，以此来支付之前属于 Uber 的现金单费用。司机非常乐意在行程结束时能够及时收取现金，同时这项功能对那些没有信用卡的用户也是非常重要的。</p><p>对于拥有三方市场的外卖业务来说，大部分属于餐厅的现金需要配送员去收取。并且，对于信用卡，借记卡使用率不高的地区，派发足够多线上支付的订单去抵消未收付的现金是不太现实的。比起让配送员把现金送回餐厅，我们需要一个可持续的方法在食客和餐厅之间进行现金转移。</p><p>首先我们尝试了第三方的现金收款服务，例如有合作关系的便利店，传统的银行存款，转账。这种方法的问题在于：支持 Uber 外卖的城市并不都支持这些服务，并且限制了现金支付的地方，需要配送员停下来去完成那些不属于配送过程中的任务。</p><p>理想中的现金收款方法需要适用于现在和将来所有支持外卖服务的地区，并且方便于配送员操作。更进一步，当现金支付的地区不具备可靠的网络环境，现金交换操作能够完全离线完成。</p><h2 id="我们新的方法"><a href="#我们新的方法" class="headerlink" title="我们新的方法"></a>我们新的方法</h2><p>产品方案很新颖：<strong>利用所有餐厅作为一个现金流动的分布式网络</strong>。配送员带着之前订单的现金去往有合作关系的餐厅，然后用现金去支付订单，这与食客的支付方式无关。为了避免取餐过程中不必要的冲突，支付金额与订单金额相等，因为收到不等的金额会给餐厅的出纳造成混乱。餐厅还是能保持所有现金收入，并且乐于看到及时付款。 Uber 将会从后续的线上订单中扣除配送和预约。</p><p>这个机制运行的不错，它在当前和未来的外卖市场都能进行扩展，并且操作集成到了每次配送中，使现金支付成为配送过程中的常规组成部分。我们下一个挑战是：<strong>确保餐厅欠款的收集能够离线完成</strong>.幸运的是，新司机端中的离线功能能够覆盖一些 Case，例如司机在网络情况差的地方结束订单。这个功能与我们现金支付的需求很吻合。</p><h2 id="利用乐观模式"><a href="#利用乐观模式" class="headerlink" title="利用乐观模式"></a>利用乐观模式</h2><p>在 Uber 运营的许多新兴市场，可靠的网络环境是不能保障的。之前的司机应用在整个行程中需要可靠的网络环境，这给我们的司机和配送员带来了令人沮丧的体验。例如，司机必须将乘客带到一个网络环境良好的地方才能结束订单。对于配送员来说，情况可能更糟，地下或建筑物内的交付和配送受网络环境影响更大。</p><p>新司机端的众多新功能中有一个是<a href="https://eng.uber.com/driver-app-optimistic-mode/" target="_blank" rel="noopener">乐观模式(Optimistic Mode)</a>,它允许功能在无网情况下使用。当开启的时候，无论网络请求是否成功，应用的状态会立马更新并保持响应。失败的请求会被记录，缓存，并在网络恢复连接后进行重试。不管实际网络延时情况，应用能快速响应，用户能够正常操作。使用乐观模式，行程可以在弱网或无网情况下开始和结束。对于外卖服务，配送员可以在无网情况下完成整个餐厅现金收付流程。</p><h2 id="餐厅欠款收集功能"><a href="#餐厅欠款收集功能" class="headerlink" title="餐厅欠款收集功能"></a>餐厅欠款收集功能</h2><p>如果希望餐厅能无缝从配送员那收集欠款，需要新版的 Android/iOS 司机端和餐厅端(使用 <a href="https://eng.uber.com/ubereats-react-native/" target="_blank" rel="noopener">React Native</a> 编写 )，以及新版的后端服务。我们构建了一个新的微服务( microservice )去支持餐厅的现金流服务，它的客户端( clients )有以下几个职责：</p><ul><li>决定餐厅现金支付的资格。</li><li>计算建议支付的现金总额。</li><li>使用状态机来维持现金支付流程中的状态。</li><li>在手机端和餐厅端中显示格式化后的数据。</li></ul><p>如图 1 所示，现金流包含以下几个状态:</p><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/12/Carbon_Cash_Figure-01.png" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/12/Carbon_Cash_Figure-01.png" alt="Graph of Uber Eats payment flow"></a></p><p>图 1: 映射现实世界中配送员如何在餐厅结算现金欠款机制的现金流状态机模型。</p><p> 在调度中时，配送员会默认选择完成现金支付的操作，之后的主动操作是需要网络连接时完成。如图 2，在配送开始时，会认为配送员是处于网络状态良好的环境中，否则，他们不会收到派送信息。之后我们会把流程结束的完整信息发送过去，这样后续操作不需要网络一直连接，并且会提醒餐厅可能是现金支付，如图 3 所示。配送员可能会退出现金支付页面并继续之后的派送流程，这时乐观模式( Optimistic Mode )会把失败请求存储到磁盘上。网络恢复连接后，会通知后端有临时跳过现金支付的决定。</p><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/12/Carbon_Cash_Figure-02.png" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/12/Carbon_Cash_Figure-02-175x300.png" alt="Mobile interface payment due"></a></p><p>图 2:配送应用上显示需要支付的金额和暂时跳过的选项，</p><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/12/Carbon_Cash_Figure-03.png" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/12/Carbon_Cash_Figure-03-1024x768.png" alt="App screen for restaurant"></a></p><p>图 3:取餐时餐厅收到可选现金支付的信息</p><p>服务支持配送员设置他们能支付的金额，如果配送员手上没有足够支付的金钱或者希望之后派送时再支付，这个功能会非常有用。然而，我们没有开启此功能，更多考虑的是餐厅会收到现金总额与订单总额不符的体验。在当前实践中，如果配送员选择完成现金支付，之后会进入支付状态交换，这时现金总额会自动设置为订单总额。</p><p>离线情况下我们如何进行现金支付交换呢？需要餐厅和配送员都能承认现金支付是令人安心的，可以预防潜在的欺诈。在双方确认后，不能依赖网络请求来提供及时通信，因此我们利用四位数验证码。</p><p>调度过程中，我们同时给司机端和餐厅端提供完成流程所需要的所有信息。如图 4，餐厅得到了一个随机生成的验证码，在现金交换时配送员会被提示去请求它。</p><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/12/Carbon_Cash_Figure-04.png" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/12/Carbon_Cash_Figure-04-1024x768.png" alt="App screen showing four digit sync code"></a></p><p>图 4:在调度时，餐厅得到一个四位验证码。</p><p>相反地，发给手机端的是此验证码<a href="https://en.wikipedia.org/wiki/SHA-2" target="_blank" rel="noopener">SHA256加盐</a>后的 Hash 值，然后在输入餐厅得到的验证码时，会和该验证码的加盐 hash 值进行比对。一旦成功，配送员可以继续完成现金交换流程，并开始下一次配送。hash 值相等性验证发生在线下。为了避免作弊，会限制频率和最大尝试次数。 此外，如果现金支付操作没有完成，验证码会在合理时间内到期。如果发现事务不一致，Uber 会进一步调查，可能会禁止平台内任何有不良行为的用户。</p><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/12/Carbon_Cash_Figure-05.gif" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/12/Carbon_Cash_Figure-05.gif" alt="Mobile screen showing payment flow"></a></p><p>图 5: 配送员输入验证码进行hash和验证。</p><p>如上图 5 所示，一旦验证码输入成功，配送员和餐厅应用会同时显示一个预填充确认的页面。如果网络又出现错误，乐观模式( Optimistic Mode )会缓存失败请求到磁盘，并在网络恢复时重试。配送员支付行为被记录为可信，餐厅的余额根据之后的线上收益进行调整，至此现金支付结束。</p><h2 id="伴随现金支付前进"><a href="#伴随现金支付前进" class="headerlink" title="伴随现金支付前进"></a>伴随现金支付前进</h2><p>虽然乐观模式( Optimistic Mode )设计的初衷是为了 Carbon 的核心出行流程，但是它为这套全新功能的实现提供了可能。Uber 的工程师和设计师团队在开发新功能时摆脱了网络环境的限制。由于现金交接需要多方的高度信任，所以仅依靠餐厅去核实现金交易是行不通的。同时，配送员网络连接状态可能阻塞行程的进行，从而停留在验证的流程中。乐观模式( Optimistic Mode )完美解决了这个问题，它允许现金交接操作在离线环境中进行，并稍后在网络连接恢复时通知后端事务。</p><p>认识到离线操作的价值后，其他的 Carbon 开发团队都是用了乐观模式( Optimistic Mode ),而且 Uber 的移动端网络组在框架中拓展了此功能。这些努力使得 Uber 应用摆脱了网络环境的依赖，成为能离线响应多方市场的应用。</p><h4 id="Index-of-articles-in-Uber-driver-app-series"><a href="#Index-of-articles-in-Uber-driver-app-series" class="headerlink" title="Index of articles in Uber driver app series"></a>Index of articles in Uber driver app series</h4><ol><li><a href="https://eng.uber.com/rewrite-uber-carbon-app/" target="_blank" rel="noopener">Why We Decided to Rewrite Uber’s Driver App</a></li><li><a href="https://eng.uber.com/driver-app-ribs-architecture/" target="_blank" rel="noopener">Architecting Uber’s New Driver App in RIBs</a></li><li><a href="https://eng.uber.com/driver-app-optimistic-mode/" target="_blank" rel="noopener">How Uber’s New Driver App Overcomes Network Lag</a></li><li>Uber Eats 支持现金支付</li><li><a href="https://eng.uber.com/carbon-dual-binary-mobile-app/" target="_blank" rel="noopener">How to Ship an App Rewrite Without Risking Your Entire Business</a></li><li><a href="https://eng.uber.com/building-a-scalable-and-reliable-map-interface-for-drivers/" target="_blank" rel="noopener">Building a Scalable and Reliable Map Interface for Drivers</a></li><li><a href="https://eng.uber.com/uber-beacon-bluetooth-mobile-app/" target="_blank" rel="noopener">Engineering Uber Beacon: Matching Riders and Drivers in 24-bit RGB Colors</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Uber-Eats-支持现金支付&quot;&gt;&lt;a href=&quot;#Uber-Eats-支持现金支付&quot; class=&quot;headerlink&quot; title=&quot;Uber Eats 支持现金支付&quot;&gt;&lt;/a&gt;Uber Eats 支持现金支付&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https
      
    
    </summary>
    
      <category term="翻译" scheme="https://hongruqi.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Uber 指示灯：帮助乘客快速寻找车辆</title>
    <link href="https://hongruqi.github.io/2019/02/19/Uber%20%E6%8C%87%E7%A4%BA%E7%81%AF%EF%BC%9A%E5%B8%AE%E5%8A%A9%E4%B9%98%E5%AE%A2%E5%BF%AB%E9%80%9F%E5%AF%BB%E6%89%BE%E8%BD%A6%E8%BE%86/"/>
    <id>https://hongruqi.github.io/2019/02/19/Uber 指示灯：帮助乘客快速寻找车辆/</id>
    <published>2019-02-18T16:00:00.000Z</published>
    <updated>2019-02-23T06:33:28.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Uber-指示灯：帮助乘客快速寻找车辆"><a href="#Uber-指示灯：帮助乘客快速寻找车辆" class="headerlink" title="Uber 指示灯：帮助乘客快速寻找车辆"></a>Uber 指示灯：帮助乘客快速寻找车辆</h1><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2019/02/Uber_Beacon_feature_image.jpg" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2019/02/Uber_Beacon_feature_image-696x522.jpg" alt="Uber Beacon app screen" title="Connecting Drivers and Riders with Uber Beacon feature image"></a></p><p><strong>本文是 Uber 的客户端工程师团队讲述了如何开发最新版本司机端系列文章中的第七篇，该系列代号 <a href="https://eng.uber.com/tag/carbon/" target="_blank" rel="noopener">Carbon</a> ，是我们共享出行业务的核心。包括其它功能在内，Uber 司机端使得超过 300 万名司机可以查看费用、里程以及收益情况。2017 年我们结合司机的反馈开始对司机端进行重新设计，并在 2018 年 9 月份启动了该项目。</strong></p><p>由于技术和物理因素，接驾对于乘客和司机来说都是一个特别难的痛点。技术方面，我们需要司乘两端达成相对的同步。物理方面，例如在一个夜间拥挤的街道，司机、乘客将彼此很难找寻到对方。对于平台来说，帮助乘客轻松辨识车辆是成功开启愉快行程的关键。</p><p><a href="https://eng.uber.com/uber-beacon/" target="_blank" rel="noopener">指示灯</a> 是我们应用程序进入现实世界的一种扩展，这是一个给司乘 2 方提供直观颜色匹配的设备，乘客可以选择光谱中的任何颜色进行设置。在黑暗和暴风雨的夜晚，选择一种颜色照亮司机车辆的挡风玻璃，可以让你更快速方便的找寻到车辆。事实上推动这种体验的工程设计并不简单。接下来让我们深入了解一下如何利用我们的 APP 实现这种体验。</p><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2019/02/Uber_Beacon_animgif.gif" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2019/02/Uber_Beacon_animgif.gif" alt="Animation showing how Uber Beacon works"></a></p><p>乘客通过指示灯功能来选择一种颜色，然后将其传输给汽车上的指示灯设备，这样乘客就可以快速方便的知道哪辆车是来接他的。</p><h2 id="足迹"><a href="#足迹" class="headerlink" title="足迹"></a>足迹</h2><p>指示灯的大部分功能是在我们司机端 APP 上使用。实现需要使用 2 组资源：Beacon SDK：负责通过蓝牙跟指示灯设备进行通信。<a href="https://eng.uber.com/driver-app-ribs-architecture/" target="_blank" rel="noopener">RIBs架构</a> 中的一系列功能模块利用 Beacon SDK 实现司机端的功能。</p><h3 id="Beacon-SDK"><a href="#Beacon-SDK" class="headerlink" title="Beacon SDK"></a>Beacon SDK</h3><p>Beacon SDK 几乎实现了指示灯设备的所有用户体验功能，它利用蓝牙实现了司机端 APP 和指示灯设备之间连接跟数据沟通的功能。在设计 Beacon SDK 时，我们遵循了三个原理：</p><ul><li><strong>跨平台</strong></li><li><strong>应用独立性</strong></li><li><strong>响应式接口</strong></li></ul><h4 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h4><p>因为 Uber 的移动端架构是跨平台的，同时支持 iOS 跟安卓设备，所以 Beacon SDK 的架构设计也必须是跨平台的。在跨平台方面之后，我们可以更快速的迭代并提供给其他团队更方便的接入方式。</p><h4 id="应用独立性"><a href="#应用独立性" class="headerlink" title="应用独立性"></a>应用独立性</h4><p>SDK 开发最关键的原则是去掉 SDK 对应用的依赖。随着我们逐步开发新司机端 APP，这点显得尤其重要。SDK 的独立性使得我们在新旧司机端 APP 同时开发中可以通过迭代 SDK 的方式同步进行，避免中断。</p><h4 id="响应式接口"><a href="#响应式接口" class="headerlink" title="响应式接口"></a>响应式接口</h4><p>为了兼容 Uber 移动端响应式编程架构，在设计 Beacon SDK 时，必须暴露<a href="http://reactivex.io/documentation/observable.html" target="_blank" rel="noopener">可观察对象(Observable)</a>。使用这个 SDK 的工程师可以直接通过观察反应的方式与指示灯进行交互。使用这个 SDK 的工程师可以直接通过观察反应的方式与指示灯进行交互。蓝牙 API 的使用复杂性被抽象掉了。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>我们设计的 Beacon SDK 具有一系列的管理器对象（Manager），其中每个管理器负责指示灯功能的一部分，例如连接、LED 控制、无线下载（OTA）更新和传感器。每组管理器负责与指示灯设备的某个功能互通，司机端 APP 控制这些的管理器来操作指示灯设备。</p><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2019/02/Uber_Beacon_Figure_1.png" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2019/02/Uber_Beacon_Figure_1-1024x631.png" alt="Tree diagram showing how the core Beacon layer in the driver app connect to Beacon"></a></p><p>图 1：Beacon 被分解成多个逻辑管理器，管理器用来反映 Beacon 状态并提供特定功能。</p><p>管理器（Manager）定义了接口，SDK 提供了对应接口的实现。这些管理器封装了蓝牙 API 将命令从司机端传递到指示灯设备。</p><h3 id="工作者（Workers）"><a href="#工作者（Workers）" class="headerlink" title="工作者（Workers）"></a>工作者（Workers）</h3><p>由于 Beacon SDK 并没有提供专用的用户界面，因此几乎所有的 Beacon 功能都是通过 worker 提供的。Worker 是本质上是没有专用UI组件的交互者，因此逻辑与 APP 中的视图无关。在需要使用指定功能时，Carbon 将 worker 添加到 RIB 树中实现，当从 RIB 树中移除时，worker 被分离且被垃圾回收。</p><p>每个 worker 都依赖于一个或多个 Beacon SDK 管理器（Manager）。 管理器被添加给 RIB 里面的 Worker 对象。当一个 worker 被实例化时，worker 会添加由上游范围提供的管理器对象。通过这种方式，Beacon 的管理器可以在所有 worker 之间共享，并且 worker 不负责这些管理器的生命周期。</p><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2019/02/Uber_Beacon_Figure_2.png" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2019/02/Uber_Beacon_Figure_2-1024x873.png" alt="RIBs tree for driver app showing plugin points for Beacon"></a></p><p>图 2：在 Carbon 的 RIB 树的这一小节中，Beacon 的 Workers 都在 Active 和 Online 的时候才会生效。管理器在 Active 时被添加依赖并提供给下游 Workers。</p><p>RIB 树让我们根据 worker 是否使用 Beacon 功能来决定是启用还是禁用插件点（plugin points）。如果禁用 Beacon，插件点则禁用；如果 worker 不被创建，那么就不会初始化 Beacon SDK 的管理器，从根本上消除了 Beacon 运行时的内存空间。</p><p>如果启用 Beacon 功能，我们需要遵循协议，worker 才会被添加到 RIB 树中。例如 Beacon Alert 管理器，它是在应用内提供例如“低电量”或“指示灯未找到”这种提示窗的管理器。想象一下当司机在家的时候打开 APP 查看他们的收入，此时司机的状态是离线状态，因为司机并没有开始接单；此时司机并没有使用指示灯的需求，因此不需要收到类似的弹窗。我们只会在司机在路上接乘客的时候（在线时）才会接入 Beacon Alert 管理器，因为这个时候提示功能才有意义。</p><h2 id="颜色匹配"><a href="#颜色匹配" class="headerlink" title="颜色匹配"></a>颜色匹配</h2><p>有了 Beacon 框架，我们可以在司机端 APP 中实现颜色匹配功能。</p><p>以下流程都必须严格依赖司机端已连接到指示灯设备且此时是在线状态。当司机在线时，Beacon 的功能 worker 会添加到 RIB 树上，才能使用司机端的 Beacon 功能更新服务器。随着司机端的在线与离线，我们会相应的更新状态。当司机端断线时，后端会自动关闭该功能。</p><p>当司机端接到乘客的订单后，乘客端的 APP 就会收到司机的名字、车辆信息以及他们是否具有指示灯的能力。如果具有指示灯功能，我们会在乘客端 APP 中展示指示灯的图标。乘客端 APP 会自动给服务器发送之前选择过的颜色（如乘客从未选择颜色，则随机选择一种颜色），然后通知给司机端 APP 所选颜色。</p><p>在等待接驾时，乘客可以通过点击指示灯图标进入颜色选择页面（某些特定颜色因为安全合规被移除，例如红色、蓝色），在这里乘客可以选择任何他们中意的颜色。每当乘客选中了一个颜色，就会把这个色值传递给后端，后端又通知给司机端 APP。</p><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2019/02/Uber_Beacon_Figure_3.png" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2019/02/Uber_Beacon_Figure_3-1024x342.png" alt="Diagram of data flow between rider app, backend, and driver app"></a></p><p>图 3：当司机端与指示灯连接成功后，就会被通知给后端，当乘客匹配到这个车辆，乘客就可以选择一种指示灯颜色。</p><p>在司机端这边，当司机在线时，有个 Beacon Color Worker 一直在监听颜色变化的通知。当收到了一个新颜色，就会本地存储一份。这样，如果司机接受了多个调度，例如拼车场景，我们会记录每个被接驾的乘客所设置的颜色。</p><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2019/02/Uber_Beacon_Figure_4.png" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2019/02/Uber_Beacon_Figure_4-1024x487.png" alt="Diagram showing data flow from multiple rider apps to backend"></a></p><p>图 4：行程中有很多个拼车乘客，我们会存储这些乘客每个选择的颜色。</p><p>当后端通知我们已经在去接某个乘客路上时，我们会给 Beacon 控制颜色的管理器发送一条指令（-通过技术手段获得所匹配乘客选择的色值），告诉他显示这个乘客所选中的颜色。同时在接驾过程中，车辆会不断更新显示乘客之后更改的任何颜色，保持乘客端跟司机端的同步。</p><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2019/02/Uber_Beacon_Figure_5.png" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2019/02/Uber_Beacon_Figure_5-1024x400.png" alt="Diagram showing data flow from backend to driver app to Beacon"></a></p><p>图 5：当乘客被接驾时，我们会检索他们所选择的最后一种颜色。</p><h2 id="软硬件的结合"><a href="#软硬件的结合" class="headerlink" title="软硬件的结合"></a>软硬件的结合</h2><p>优步一直在寻找优化用户体验的方法。软硬件结合的方式将平台能力扩展到现实世界是一种自然的进步。软硬件结合的方式将平台能力扩展到现实世界带来了新的令人兴奋的挑战，优步指示灯只是如何在这个领域进行创新的一个例子。这也是优步的移动工程师最激动人心的时刻。</p><h4 id="Index-of-articles-in-Uber-driver-app-series"><a href="#Index-of-articles-in-Uber-driver-app-series" class="headerlink" title="Index of articles in Uber driver app series"></a>Index of articles in Uber driver app series</h4><ol><li><a href="http://way.xiaojukeji.com/article/13418" target="_blank" rel="noopener">为什么我们决定重构 Uber 司机端</a></li><li><a href="http://way.xiaojukeji.com/article/13454" target="_blank" rel="noopener">使用RIBs重构Uber司机端</a></li><li><a href="https://eng.uber.com/driver-app-optimistic-mode/" target="_blank" rel="noopener">新 Uber 司机端是如何克服网络延迟问题的</a></li><li><a href="https://eng.uber.com/driver-app-cash-payments/" target="_blank" rel="noopener">Scaling Cash Payments in Uber Eats</a></li><li><a href="https://eng.uber.com/carbon-dual-binary-mobile-app/" target="_blank" rel="noopener">How to Ship an App Rewrite Without Risking Your Entire Business</a></li><li><a href="https://eng.uber.com/building-a-scalable-and-reliable-map-interface-for-drivers/" target="_blank" rel="noopener">Building a Scalable and Reliable Map Interface for Drivers</a></li><li>Uber指示灯：帮助乘客快速寻找车辆</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Uber-指示灯：帮助乘客快速寻找车辆&quot;&gt;&lt;a href=&quot;#Uber-指示灯：帮助乘客快速寻找车辆&quot; class=&quot;headerlink&quot; title=&quot;Uber 指示灯：帮助乘客快速寻找车辆&quot;&gt;&lt;/a&gt;Uber 指示灯：帮助乘客快速寻找车辆&lt;/h1&gt;&lt;p&gt;&lt;a
      
    
    </summary>
    
      <category term="翻译" scheme="https://hongruqi.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
  <entry>
    <title>新 Uber 司机端是如何克服网络延迟问题</title>
    <link href="https://hongruqi.github.io/2019/02/19/%E6%96%B0%20Uber%20%E5%8F%B8%E6%9C%BA%E7%AB%AF%E6%98%AF%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98/"/>
    <id>https://hongruqi.github.io/2019/02/19/新 Uber 司机端是如何克服网络延迟问题/</id>
    <published>2019-02-18T16:00:00.000Z</published>
    <updated>2019-02-23T06:45:24.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="新-Uber-司机端是如何克服网络延迟问题"><a href="#新-Uber-司机端是如何克服网络延迟问题" class="headerlink" title="新 Uber 司机端是如何克服网络延迟问题"></a>新 Uber 司机端是如何克服网络延迟问题</h1><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/11/Carbon_Optimistic_Mode_feature_image.jpg" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/11/Carbon_Optimistic_Mode_feature_image-696x392.jpg" alt="Carbon: Optimistic Mode article feature image" title="Carbon: Optimistic Mode article feature image"></a></p><p><strong>本文是 Uber 的客户端工程师团队讲述了如何开发最新版本司机端系列文章中的第三篇，该系列代号 <a href="https://eng.uber.com/tag/carbon/" target="_blank" rel="noopener">Carbon</a> ，是我们共享出行业务的核心。包括其它功能在内，Uber 司机端使得超过 300 万名司机可以查看费用、里程以及收益情况。2017 年我们结合司机的反馈开始对司机端进行重新设计，并在 2018 年 9 月份启动了该项目。</strong></p><p>城市建筑和无线数据技术的竞争意味着在城市中存在一些手机没有信号的黑色区域。这种黑色区域景区更为常见，导致网络质量和阻塞程度频繁的变化。这些问题尤其影响着那些接送乘客的司机们。</p><p>可以举一个合适的例子来说明这种问题。假设一个司机到达了非常拥挤的班加罗尔机场终点。乘客想支付现金，司机需要在应用里面操作完成订单来查看最终的金额。把车停在路边，司机端却无法联网。乘客匆忙赶飞机，不能联网就意味着司机就不能结束行程并查看最终的金额。司机可能会继续开下去，增加了额外的时间，也可能增加了行程花费，给司机和乘客都带来了不便。</p><p>为了处理这种网络覆盖漏洞和预防这类事件的发生，我们提出了 —— 乐观模式。新版本的司机端可以离线操作，这样司机就可以在没有网络的情况下用最后一次服务端的预估数据来结束行程。乐观模式下司机端可以任何网络下正常工作，极大的提高了司机和乘客的体验。</p><h2 id="乐观模式组件"><a href="#乐观模式组件" class="headerlink" title="乐观模式组件"></a>乐观模式组件</h2><p>我们之前的司机端版本中支持一些离线能力来收集失败的请求，一旦网络恢复就会上传到服务器进行整理。虽然这种功能有助于预防一些显示错误，但是不能智能的更新应用状态，不能将多个功能堆积在一起，也不能夸会话持久化状态。我们为新版本的司机端开发了下面这个组件来处理这些问题。</p><h3 id="乐观请求"><a href="#乐观请求" class="headerlink" title="乐观请求"></a>乐观请求</h3><p>司机端的任何组件都可以通过提交一个乐观请求来开始流转。一个乐观请求能够序列化储存到磁盘，对于一个普通的网络请求来说占用的内存非常小，并且每一个乐观请求都对应一个乐观转换。</p><h3 id="乐观转换"><a href="#乐观转换" class="headerlink" title="乐观转换"></a>乐观转换</h3><p>乐观模式的核心是转换，换句话说，操作转换一个对象从当前状态到<strong>乐观状态</strong>，也就是，从服务返回的预期结果。转换还能够堆积，一个对象可以经过多次转换。举一个例子来理解下转换：想象一个类<code>Counter</code>有一个属性<code>count</code>。我们可以实现一个转换来增加<code>count</code>属性的值。</p><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/11/Carbon_Optimistic_Mode_Figure-01.gif" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/11/Carbon_Optimistic_Mode_Figure-01.gif" alt="Carbon: Optimistic Mode article figure 1"></a></p><p>图一：在这个简单的例子中，<code>Counter</code>对象每经过一次增加转换，<code>count</code>属性值就会增加一。</p><p>根据业务需求转换既可以是简单的也可以是复杂的。每一个乐观请求都关联一个转换，转换会根据乐观请求返回一个最终的<em>乐观状态</em>。当数据从服务端返回时用户是无感知的，这种方式提供了一种平滑的过渡方案。</p><p>当客户端提交一个乐观请求时，关联在请求上的转换就会立马生效，应用进入乐观状态，从而完成请求。乐观状态会一直被保持直到收到服务端的真实状态，然后同步应用和服务端。</p><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/11/Carbon_Optimistic_Mode_Figure-02a.png" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/11/Carbon_Optimistic_Mode_Figure-02a.png" alt="Carbon: Optimistic Mode article figure 2a"></a></p><p>图 2-1: 普通的计数请求失败</p><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/11/Carbon_Optimistic_Mode_Figure-02b.gif" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/11/Carbon_Optimistic_Mode_Figure-02b.gif" alt="Carbon: Optimistic Mode article figure 2b"></a></p><p>图 2-2: 在无网络的情况下乐观模式使用转换及时更新数据状态，将来有网络的情况下和服务端进行同步。</p><h3 id="乐观流"><a href="#乐观流" class="headerlink" title="乐观流"></a>乐观流</h3><p>我们整个应用都在使用 <a href="https://github.com/ReactiveX/RxJava/wiki/Reactive-Streams" target="_blank" rel="noopener">RX streams</a> 传递数据。应用的每个功能都会随着已发布数据流的状态改变作出响应。这种机制使我们能够使用相同的流轻松地将乐观变换应用于对象的最新状态。为了获得乐观状态，我们结合了数据最后的状态和可用的转换。在将数据发布回流并由功能使用之前，数据已经应用了每个转换。随后业务只需简单的根据数据的乐观状态作出响应。</p><h3 id="依赖请求"><a href="#依赖请求" class="headerlink" title="依赖请求"></a>依赖请求</h3><p>同时也存在一些请求依赖于乐观请求的完成。例如，甚至在后端不知道行程已经开始的情况下发送一个结束行程的请求是不合理的。当我们在等待乐观请求完成的时候，这样的依赖请求将会被放入队列一段时间。如果周期过长，我们会结束这个请求，通知用户网络错误。</p><h2 id="设计挑战"><a href="#设计挑战" class="headerlink" title="设计挑战"></a>设计挑战</h2><p>我们在这个设计中遇到了一些挑战。我们想要支持多个堆叠的乐观请求，允许在没有网络的情况下完成多个步骤。由于和服务器不同步，我们还需要处理错误地进入乐观状态并且必须回滚到先前状态的情况。确保我们可靠地向司机展示最准确的状态需要进行多次迭代，并持续优化。</p><h3 id="兜底转换"><a href="#兜底转换" class="headerlink" title="兜底转换"></a>兜底转换</h3><p>乐观模式开启的情况下，应用程序可能会在乐观请求完成之前收到其他的网络数据。</p><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/11/Carbon_Optimistic_Mode_Figure-03.png" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/11/Carbon_Optimistic_Mode_Figure-03.png" alt="Carbon: Optimistic Mode article figure 3"></a></p><p>图 3: 在这个场景中，我们在收到服务器最新的状态之后又进行了乐观转换。</p><p>我们继续拿上面用到的计数器的例子来说。应用程序使用增加变换把最终的值变成了 2。然而，这个值还没有和服务端同步。在这期间，收到的其他的网络响应可能还是旧的值 1。乐观模式使用转换更新了这个旧值并且维护这个乐观状态。这就确保了应用程序不会在两种状态之前来回切换，避免给用户产生混乱的体验。</p><h3 id="应用重启时如何存活"><a href="#应用重启时如何存活" class="headerlink" title="应用重启时如何存活"></a>应用重启时如何存活</h3><p>所有的乐观请求和最新的乐观状态一起被保存在磁盘里，所以它们能够在应用重启的时候得以保留。考虑这么一种情况，一些请求正在排队和服务器同步，但是用户却杀死了应用。在重新启动的时候，乐观请求和状态会从磁盘中加载。这允许用户在重新启动应用时处于相同的状态。乐观请求排队和服务器同步。</p><h3 id="显示错误"><a href="#显示错误" class="headerlink" title="显示错误"></a>显示错误</h3><p>我们遇到的这个新功能的一个特殊问题是它如何显示错误。乐观模式的请求只应该由于后端中断而失败，并且结果应该是可预测的便于模拟。然而，实践中会出现错误。由于我们使用乐观的流程服务用户，所以一个小错就可能带来很不好的体验。首先，应用程序的状态回滚到之前的乐观状态，不是用户所期望的状态，下个动作可能不太明显。其次，即使之前的状态可能已经无效了，我们也需要用它来接收错误原因来展示。为了处理这些问题，我们在司机端里加入了一个全局处理错误信息的框架，它可以调用内部弹窗框架。</p><p>请求出错的情况总是很少见的。对于经常发生的错误，比如行程太短，我们在手机端上实现了检查，以便更好的处理。</p><h3 id="节省时间"><a href="#节省时间" class="headerlink" title="节省时间"></a>节省时间</h3><p>对司机来说，我们在开始和结束行程上利用乐观模式节省了大量的时间。我们经常可以看到在真实的网络请求完成之前行程已经开始几分钟的情况。截至 2018 年 11 月，我们注意到平均每个乐观操作节省大约 13.5 秒的时间。即使在新司机端的早期阶段，我们每天累计节省司机的时间也超过了一年。</p><h2 id="乐观模式的发展"><a href="#乐观模式的发展" class="headerlink" title="乐观模式的发展"></a>乐观模式的发展</h2><p>在无网络的情况下能够正常运行的能力在 Ubers 的其他应用程序上面使用的也非常好。设计之初是为了加速开始和结束行程的速度，它还被整合到 Uber Eats 中功能中，当使用现金结算时，可以更快的结束。它还能用到类似于这种可以快速响应后续同步到服务端的业务中，比如对乘客或司机的评价，标记消息已读，和收集交付的指纹。</p><h4 id="Uber-司机端系列文章索引"><a href="#Uber-司机端系列文章索引" class="headerlink" title="Uber 司机端系列文章索引"></a>Uber 司机端系列文章索引</h4><ol><li><a href="http://way.xiaojukeji.com/article/13418" target="_blank" rel="noopener">为什么我们决定重构 Uber 司机端</a></li><li><a href="http://way.xiaojukeji.com/article/13454" target="_blank" rel="noopener">使用RIBs重构Uber司机端</a></li><li>新 Uber 司机端是如何克服网络延迟问题的</li><li><a href="https://eng.uber.com/driver-app-cash-payments/" target="_blank" rel="noopener">Scaling Cash Payments in Uber Eats</a></li><li><a href="https://eng.uber.com/carbon-dual-binary-mobile-app/" target="_blank" rel="noopener">How to Ship an App Rewrite Without Risking Your Entire Business</a></li><li><a href="https://eng.uber.com/building-a-scalable-and-reliable-map-interface-for-drivers/" target="_blank" rel="noopener">Building a Scalable and Reliable Map Interface for Drivers</a></li><li><a href="https://eng.uber.com/uber-beacon-bluetooth-mobile-app/" target="_blank" rel="noopener">Engineering Uber Beacon: Matching Riders and Drivers in 24-bit RGB Colors</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;新-Uber-司机端是如何克服网络延迟问题&quot;&gt;&lt;a href=&quot;#新-Uber-司机端是如何克服网络延迟问题&quot; class=&quot;headerlink&quot; title=&quot;新 Uber 司机端是如何克服网络延迟问题&quot;&gt;&lt;/a&gt;新 Uber 司机端是如何克服网络延迟问题&lt;/
      
    
    </summary>
    
      <category term="翻译" scheme="https://hongruqi.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
</feed>
