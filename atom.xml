<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>猛犸象团队博客</title>
  
  <subtitle>2019，行者无疆</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hongruqi.github.io/"/>
  <updated>2019-02-23T06:43:38.599Z</updated>
  <id>https://hongruqi.github.io/</id>
  
  <author>
    <name>猛犸象</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 RIBs 重构 Uber 司机端</title>
    <link href="https://hongruqi.github.io/2019/02/22/%E4%BD%BF%E7%94%A8%20RIBs%20%E9%87%8D%E6%9E%84%20Uber%20%E5%8F%B8%E6%9C%BA%E7%AB%AF/"/>
    <id>https://hongruqi.github.io/2019/02/22/使用 RIBs 重构 Uber 司机端/</id>
    <published>2019-02-21T16:00:00.000Z</published>
    <updated>2019-02-23T06:43:38.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-RIBs-重构-Uber-司机端"><a href="#使用-RIBs-重构-Uber-司机端" class="headerlink" title="使用 RIBs 重构 Uber 司机端"></a>使用 RIBs 重构 Uber 司机端</h1><p><a href="https://eng.uber.com/wp-content/uploads/2018/11/Carbon_architecture_feature_169.png" target="_blank" rel="noopener"><img src="https://eng.uber.com/wp-content/uploads/2018/11/Carbon_architecture_feature_169-696x392.png" alt="Uber新司机端RIBs架构" title="Architecting Uber&#39;s New Driver App in RIBs feature image"></a></p><p><em>本文是 Uber 的客户端工程师团队是如何开发最新版本司机端的系列文章中的第二篇，代号 <a href="https://eng.uber.com/tag/carbon/" target="_blank" rel="noopener">Carbon</a> ，是我们拼车业务的一个核心组件。除了其他新功能之外，司机端 APP 还为超过 300万 司机提供收入，引导他们挣钱。2017年我们结合司机的反馈开始对司机端进行重新设计，并在2018年9月份启动了该项目。</em></p><p>重新编写一个APP会引发关于新架构和新设计相关的许多问题。迄今为止，大多数开发者只关注应用程序如何正常工作。虽然以用户为中心的设计理念已经成为软件开发中的一些主流，但是辨别真实有效的用户需求并不容易。</p><p>一旦决定 <a href="https://eng.uber.com/rewrite-uber-carbon-app/" target="_blank" rel="noopener">重构Uber司机端</a>, 我们必须以广泛多样的用户群里为基准，寻找如何设计更适用的工作流和保留最适用的产品功能。 我们收集全世界各个城市的Uber司机的反馈，将这些反馈作为我们用户体验的重要初衷。</p><p>与此同时，我们也必须考虑到，成百数千的工程师们，他们需要重构APP的同时也要功能迭代。一个经过深思熟虑的APP架构需要帮助工程师，在保证可靠性的同时高效、快速的工作。</p><p>幸运的是，Carbon 在满足这些服务时并没有发生冲突，这些服务包括更实用的应用流程，改善司机体验功能，为开发者提供灵活稳定的架构，事实证明，它们结合的非常好。</p><p>本篇文章，阐述了我们是为了适应新司机端（代码Carbon）如何提出核心需求，并且讨论使用<a href="https://github.com/uber/RIBs" target="_blank" rel="noopener">RIBs架构</a>和插件设计，来满足司机端应用逻辑。</p><h2 id="规模发展"><a href="#规模发展" class="headerlink" title="规模发展"></a>规模发展</h2><p>自2013年发版以来，Uber司机端积累了需要功能。在未来的四年之后Uber司机端将成为司机的核心工具。随着应用程序的日益复杂，Uber确实做到组织化。上百个功能由横跨公司40多个不同子团队开发和维护。截止2017年1月，Android司机端已经拥有由近200个工程师编写出428,685行代码。iOS司机端由200多工程师贡献720,273行代码。更为重要的是，我们的APP安装在超过300万的设备中，每天超过100个国家中的100万个司机使用。</p><p>对于Carbon的成功，我们知道我们需要及时更新所有现有功能（已经一些新功能）的同时，也需要并行更新架构。</p><h3 id="一起建设"><a href="#一起建设" class="headerlink" title="一起建设"></a>一起建设</h3><p>产品开发需要时刻记住用户。为此，我们想和Uber司机一起创建构建我们的应用。在开发的最初阶段，我们在用户调研上投入大量资金。在11个国家，12个城市中采访了500位司机。</p><p><a href="https://www.youtube.com/watch?v=_6gQxnpwdw4" target="_blank" rel="noopener"></a></p><p>这些访谈对象帮我们设计新司机端的用户体验，确定最重要的功能。但是，除非司机在在真实条件下在实际道路中使用APP，否则无法获取完整的用户体验。我们需要一种方法，它可以允收集用户反馈，快递迭代并每周发布新版本。</p><p><a href="https://eng.uber.com/wp-content/uploads/2018/11/Carbon_architecture_Figure_01.png" target="_blank" rel="noopener"><img src="https://eng.uber.com/wp-content/uploads/2018/11/Carbon_architecture_Figure_01.png" alt="Uber司机App的三种设计"></a></p><p>图一：在测试期间，为APP使用最初设计。</p><h3 id="实现可靠性"><a href="#实现可靠性" class="headerlink" title="实现可靠性"></a>实现可靠性</h3><p>最难并且最重要的挑战是，在实际测试中的稳定性。当接触一个新APP，在Alpha和Beta测试阶段可以接受错误和问题。Uber司机端在Beta阶段，真实的司机已经可以在实际道路中可以使用它挣钱了。实现可靠性是Carbon的关键目标。所以，进入首次测试阶段时，我们必须确保Carbon像现有程序一样可靠。</p><h2 id="解耦规模化开发"><a href="#解耦规模化开发" class="headerlink" title="解耦规模化开发"></a>解耦规模化开发</h2><p>阐述了现在工程的限制后，我们采用了分段性方法，将项目分为四个阶段。每个阶段的目标是开启下个阶段的开发。</p><h3 id="第一阶段-基础设施"><a href="#第一阶段-基础设施" class="headerlink" title="第一阶段: 基础设施"></a>第一阶段: 基础设施</h3><p>我们拥有一个通用模板，来描述我们的APP必须包含哪些因素。这个模板包括网络库，存储库，<a href="http://reactivex.io/" target="_blank" rel="noopener">ReactiveX</a>，分析追踪，崩溃上报和我们的自研的应用架构Ribs。利用这个模板，我们构建了具备初始化架构的程序，包括存储能力，网络，崩溃上报和基础组件。然儿，在这个阶段。程序缺少司机业务功能，这仅仅是我们构建特性的框架。</p><h3 id="第二阶段-应用层设施"><a href="#第二阶段-应用层设施" class="headerlink" title="第二阶段: 应用层设施"></a>第二阶段: 应用层设施</h3><p>使用RIBs框架的一个好处是，它如何将业务逻辑作为应用程序体系结构的核心。在Carbon阶段，一个好的起点是为司机定义高标准的用户状态。这将导致我们为RIBs定义一些基础:</p><ul><li><strong>Root</strong>: 当启动应用时，Root启动基于RIBs应用程序的所有必要文件。</li><li><strong>Logged Out</strong>: 如果用户没有有效的会话时，我们需要一个RIBs为用户创建一个账户，登录并且获取有效凭证。</li><li><strong>Logged In</strong>: 一旦用户身份验证通过，分离注销的RIBs，将登录的RIBs添加到有效的会话中</li><li><strong>Active</strong>: 有时一个司机用户可以登录，但是不能做其他操作（他们的账户由于各种原因被封锁）。这个RIBs确保他们有一个有效的会话_并且_允许使用程序。</li></ul><p>我们利用RIBs树图，如下图2所示，说明应用架构。这个简单的树形图展示了，如何使用RIBs组件相互关联。</p><p><a href="https://eng.uber.com/wp-content/uploads/2018/11/Carbon_architecture_Figure_02.gif" target="_blank" rel="noopener"><img src="https://eng.uber.com/wp-content/uploads/2018/11/Carbon_architecture_Figure_02.gif" alt="RIBs数"></a></p><p>图二:RIBs树图向我们展示了组件关联的可视化方法。</p><p>在关注用户阶段，我们可以将UI分离出来。这个方法可以促使从司机中吸取持续反馈建议，并将建议吸纳到设计中。同时促使我们维护用户程序的基本。</p><h3 id="第三阶段-功能框架"><a href="#第三阶段-功能框架" class="headerlink" title="第三阶段: 功能框架"></a>第三阶段: 功能框架</h3><p>在一些基础上，我们重点转移到协作中。在第三阶段，我们的目标是扩大规模，使大约40个团队在同一个APP中可靠无缝的并行工作。基于用户的反馈和设计、产品团队的协作，我们定义出更详细的RIBs组件。</p><ul><li><strong>任务</strong>: 当司机在线和工作时如果体验APP (例如, 导航到乘客位置, 开始行程, 乘客下车, 接另一个单, 等等.).</li><li><strong>行程 (行程规划)</strong>: 司机规划行程的关键地区。在此，他们可以清晰的看到他们需要做的：接驾乘客到送餐。如果它是空的，它会给司机从哪里什么时间提供服务的建议。</li><li><strong>个人中心</strong>: <strong>这是司机管理业务的区域。它包含实际行程之外的所有内容：重要通知，评级，收入等等</strong></li><li><strong>地图</strong>: 在司机端中许多和地图相关的功能，例如导航，热力图，和其他使用新RIBs开发的地图库。这是一个在地图框架上的抽象层。有趣的是，如下图展示。这个地图库在APP中视为非核心功能。这意味着，如果地图功能遇到灾难性问题（当然我们希望永远不要发生！），我们可以禁用它，允许司机继续使用。</li></ul><p>在合并了框架之后，RIBS树结构变大了，如下面的图三所示。</p><p><a href="https://eng.uber.com/wp-content/uploads/2018/11/Carbon_architecture_Figure_04-1.gif" target="_blank" rel="noopener"><img src="https://eng.uber.com/wp-content/uploads/2018/11/Carbon_architecture_Figure_04-1.gif" alt="RIBs树"></a></p><p>图三: 按照我们的定义在RIBs树中增加层级和新的功能框架。</p><p>在我们细分之前, 我们清晰下在使用的RIBs架构中的一些概念。</p><h4 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h4><p>这是一个对象，它直接关联到RIBs生命周期，具有启动/停止生命周期功能方法。换句话说，添加到RIBs的工作者从RIB连接时启动，RIB分离时停止。工作者确保交互(一个RIB的业务逻辑组件单元)不会太大，并且允许更好的分离关注点。(在我们的仓库中可以找到 <a href="https://github.com/uber/RIBs/blob/master/android/libraries/rib-base/src/main/java/com/uber/rib/core/Worker.java" target="_blank" rel="noopener">Android</a> 和 <a href="https://github.com/uber/RIBs/blob/master/ios/RIBs/Classes/Worker/Worker.swift" target="_blank" rel="noopener">iOS</a>)</p><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><p>插件是一种设计模式，插件允许我们用灵活的方式进行特征标记。(进一步了解Uber如果利用插件 <a href="https://eng.uber.com/plugins/" target="_blank" rel="noopener">上一篇文章</a>)。首先我们为集成的核心代码定义一个公用的API，然后开发者可以实现自己的API实例。这是因为他们了解代码由遵守这个架构的特征标记隐形保护。把每个插件点想象成微服务体系中一个服务，然后插件工厂作为该服务的消费者，这样将使得插件和API或者他们之间的契约相似。</p><p>结合RIBs，插件和工作者，可以定义出架构中的核心和非核心部分。核心组件是必须的组件，并且不能被标记成禁用。另一方面，如果非核心组件引入了重大问题或者导致回归，可以被禁用。在上面的图四种，Map和MyHub是非核心组件，他们可以在不关闭应用程序功能的基础上被禁用。</p><p>进一步查看图 4 中 RIBs 树图的细节功能，我们就能看到：如何使用核心 RIBs，Plugins，Workers， 以 worker/plugin 模式去实现 Agenda 的全部功能。Agenda 功能暴露了两个不同的插件点(plugin points): Agenda Worker 和 Agenda Section。 使用 Worker plugin point 集成非用户体验功能，Section plugin point 去扩展用户体验功能。</p><p><a href="https://eng.uber.com/wp-content/uploads/2018/11/Carbon_architecture_Figure_05.gif" target="_blank" rel="noopener"><img src="https://eng.uber.com/wp-content/uploads/2018/11/Carbon_architecture_Figure_05.gif" alt="RIBs树细节"></a></p><p>图四:仔细观察RIBs树的一部分，可以发现集成的多个领域，它允许在灵活添加特性，也允许并行开发。</p><p>使用这个设计模式，我们可以理解许多领域APP。例如一些工程师构建登录和注册界面，其他工程师重点开发非核心RIBs的地图架构。</p><h3 id="第四阶段-全员"><a href="#第四阶段-全员" class="headerlink" title="第四阶段: 全员"></a>第四阶段: 全员</h3><p>第四阶段，其他团队加入我们开放了Carbon的开发。由于想要确保每个功能彼此独立，我们创建到了插件框架，因此特性合并是一个相对顺畅的过程。如有必要，一些小RIBs上升为核心组件，但是我们大部分代码仍然包含在插件中，所以我们的架构中一些部分是可选性的（我们计划在后续章节中讨论一些令人兴奋的新特性）。</p><p><a href="https://eng.uber.com/wp-content/uploads/2018/11/Carbon_architecture_Figure_06.gif" target="_blank" rel="noopener"><img src="https://eng.uber.com/wp-content/uploads/2018/11/Carbon_architecture_Figure_06.gif" alt="RIBs架构到应用接口连接图"></a></p><p>图五: 如动画所示，RIBs生命周期与他们的各自单元相关</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>软件工程的架构是一个通常是在牺牲别的资源条件下去优化团队更为重要的一些指标。虽然我们的方法允许我们优化可靠性、可扩展性和模块化，但是其他方面我们必须妥协。在一个严谨的流程中，我们只允许少量的组件是核心组件。为了维护核心组件的质量，我们拥有一个内部审查团队，他们审查修改核心代码中每个代码。这个流程要求一些工程师投入一些时间去做核心代码审查，这也减慢了其他工程师的提交频率。</p><p>大多数应用开发者熟悉MVP或MVC模型。和他们相比，RIBs好像更冗长。RIBs有更多的组件，需要更多的前期规划。较小的软件开发团队也许不需要采用类似的流程。之前我们已经做完一个重构<a href="https://eng.uber.com/new-rider-app/" target="_blank" rel="noopener">重写我们的乘客端APP</a>，因此我对如何构建Carbon更清晰，我们将我们的学习总结如下：</p><ul><li><p><strong>按规模工作</strong>: 在Uber, _规模_ 既是最高限制也是最有价值资源. 300万司机在使用我们的APP，所以我们不能让他们失望。 同时, Uber作为一个技术组件公司，我们已经发展到数百万工程师一起构建应用程序。_规模_ 是我们从规划到推广决策的关键。</p></li><li><p><strong>RIBs to the rescue</strong>: Carbon通过使用RIBs和插件，我们在以下方面获得成绩:</p><ul><li><strong>模块化:</strong> 每个功能的开发不依赖于其他功能，除非它是核心RIBs。这个架构使得工程师们并行开发更便捷，不比担心影响其他RIBs。</li><li><strong>可扩展性:</strong> 树形结构可以通过添加子节点纵向扩展，可以通过添加兄弟节点横向扩展，也可以通过不同works将业务分离横向扩展。</li><li><strong>可靠性:</strong> 使用插件完成的核心和非核心概念允许我们禁用非核心代码，所以我们以最小损失代价进行快速转移。</li></ul></li><li><strong>共同构建</strong>: 如果没有司机的帮助，以及他们在用户调研和测试阶段给我们的建议，我们不可能做到这一点。</li></ul><h4 id="Index-of-articles-in-Uber-driver-app-series"><a href="#Index-of-articles-in-Uber-driver-app-series" class="headerlink" title="Index of articles in Uber driver app series"></a>Index of articles in Uber driver app series</h4><ol><li><a href="https://eng.uber.com/rewrite-uber-carbon-app/" title="Why We Decided to Rewrite Uber’s Driver App" target="_blank" rel="noopener">Why We Decided to Rewrite Uber’s Driver App</a></li><li>Architecting Uber’s New Driver App in RIBs</li><li><a href="https://eng.uber.com/driver-app-optimistic-mode/" target="_blank" rel="noopener">How Uber’s New Driver App Overcomes Network Lag</a></li><li><a href="https://eng.uber.com/driver-app-cash-payments/" target="_blank" rel="noopener">Scaling Cash Payments in Uber Eats</a></li><li><a href="https://eng.uber.com/carbon-dual-binary-mobile-app/" target="_blank" rel="noopener">How to Ship an App Rewrite Without Risking Your Entire Business</a></li><li><a href="https://eng.uber.com/building-a-scalable-and-reliable-map-interface-for-drivers/" target="_blank" rel="noopener">Building a Scalable and Reliable Map Interface for Drivers</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用-RIBs-重构-Uber-司机端&quot;&gt;&lt;a href=&quot;#使用-RIBs-重构-Uber-司机端&quot; class=&quot;headerlink&quot; title=&quot;使用 RIBs 重构 Uber 司机端&quot;&gt;&lt;/a&gt;使用 RIBs 重构 Uber 司机端&lt;/h1&gt;&lt;p&gt;&lt;a
      
    
    </summary>
    
      <category term="翻译" scheme="https://hongruqi.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Uber 新架构 RIBs 的前世今生</title>
    <link href="https://hongruqi.github.io/2019/02/22/Uber%20RIBs%20%E6%9E%B6%E6%9E%84/"/>
    <id>https://hongruqi.github.io/2019/02/22/Uber RIBs 架构/</id>
    <published>2019-02-21T16:00:00.000Z</published>
    <updated>2019-02-23T06:01:19.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Uber-新架构-RIBs-的前世今生"><a href="#Uber-新架构-RIBs-的前世今生" class="headerlink" title="Uber 新架构 RIBs 的前世今生"></a>Uber 新架构 RIBs 的前世今生</h1><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2016/12/new_rider_app.jpg" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2016/12/new_rider_app.jpg" alt title="new_rider_app"></a></p><h3 id="为什么-Uber-要重构移动端"><a href="#为什么-Uber-要重构移动端" class="headerlink" title="为什么 Uber 要重构移动端"></a>为什么 Uber 要重构移动端</h3><p>Uber 基于一个简单的概念：一键出行。 从最初优享到现在提供的一系列产品，每天在数百个城市协调数百万次乘车。 为了应对和支持2017年及以后的发展，我们迫切的需要重新设计我们的移动端架构。</p><p>但从哪里开始？ 我们决定重新开始。于是我们决定完全重构并重新<a href="https://medium.com/uber-design/designing-the-new-uber-app-16afcc1d3c2e#.wio2h7epr" target="_blank" rel="noopener">设计</a>我们的<a href="https://ride.uber.com/en_US/" target="_blank" rel="noopener">乘客端</a>。 由于不用被之前的设计和代码限制，在重构上我们有很大的发挥空间。<a href="https://newsroom.uber.com/newriderapp/" target="_blank" rel="noopener">结果就是你今天看到的这个时尚的新应用</a>, 它在iOS和Android上实现了新的移动架构。接下来的文章将介绍我们的新移动端架构 Riblets，让你了解为什么我们需要创建这种新架构模式，以及它如何帮助我们达成目标。</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>虽然共享出行仍然是 Uber 背后的驱动理念，但我们的产品已发展成为功能复杂的APP，我们原有的移动架构无法与之匹配。 随着乘客端App的新功能扩展，工程挑战和技术债务不断累积。增加了诸如<a href="https://newsroom.uber.com/us-california/its-a-beautiful-pool-day-in-the-neighborhood/" target="_blank" rel="noopener">拼车</a> ，<a href="https://www.uber.com/info/scheduled-rides/" target="_blank" rel="noopener">预约乘车</a> 和促销车辆视图等功能，导致工程的复杂性逐步升高。 我们的行程模块变得越来越大，难以测试。 加入小变化有可能影响到应用程序的其他部分，使得功能尝试增加额外调试任务，从而抑制了我们快速迭代和功能实验。 为了给所有 Uber 用户的高质量体验，我们需要一种方法，重新找回起点的简单，同时考虑今天的处境和未来的目标。</p><p>对于乘客和 Uber 工程师来说，新的应用程序必须简单。 为了适用于不同的群体，我们的两个主要目标是：持续增加有效的核心用户体验，并且允许在系列产品需求序列中做大胆实验。</p><h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><p>从工程方面来说，我们正在努力使 Uber 的行程主流程的可靠性达到 99.99％。 实现99.99％的可靠性意味着我们每年只能有一个累计小时的停机时间，一周的停机时间为一分钟，每10,000次运行只有一次失败。</p><p>为了实现这一目标，新架构定义并实现了核心和可选代码的框架。 核心代码包括注册，获取，完成或取消行程所需的一切代码。 对核心代码的更改和添加需要经过严格的审核流程。 可选代码可以降低审查力度，可以在不停止核心业务的情况下关闭。 这种代码隔离机制使我们能够尝试新功能，并在异常情况下自动关闭它们，而不会干扰乘车体验。</p><h4 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h4><p>我们需要一个平台，一百个不同的项目团队和数千名工程师可以快速构建高质量的功能，并在乘客端上进行创新，而不会影响核心用户体验。 因此，我们提供了新的移动端架构，具有跨平台兼容性，确保iOS和Android工程师都可以在统一的基础上工作。</p><p>从历史上看，在 iOS 和 Android 上发布最好的应用程序涉及不同的架构、库设计和分析方法。 但是，新架构致力于在两个平台上使用相同的最佳模式和实践。 这给了我们学习两个平台的机会。 由于一个平台的经验教训可以预先解决另一个平台上的问题，从而避免了同样的错误在两个平台重复出现。 因此，iOS 和 Android 工程师可以更轻松地进行协作，并且可以并行处理新功能。</p><p>虽然在某些情况下，平台之间可以也应该是不同的(例如 UI 实现)，但是 iOS 和 Android 移动平台都是从一致性出发。平台共享:</p><ul><li>核心架构</li><li>类名</li><li>业务逻辑单元之间的继承关系</li><li>业务逻辑如何划分</li><li>插件点 (名字, 存在,结构等)</li><li>响应式编程链</li><li>统一平台组件</li></ul><p>为了实现平台之间的这种通用蓝图，我们的新移动架构需要清晰的组织和分离业务逻辑，视图逻辑，数据流和路由。这种架构有助于降低复杂性，简化可测试性，从而提高工程效率和用户可靠性。 我们在其他架构模式上进行了创新以实现此目标。</p><h3 id="从-MVC-到-Riblets"><a href="#从-MVC-到-Riblets" class="headerlink" title="从 MVC 到 Riblets"></a>从 MVC 到 Riblets</h3><p>考虑到我们的两个目标，我们调查了旧架构可以改进的地方，并研究了可行的方案。Uber 旧的代码遵循[MVC 模式]（<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html）。我们调查了其他模式，特别是[VIPER]（https://mutualmobile.com/posts/meet-viper-fast-agile-non-lethal-ios-architecture-framework），我们最终用它来创建" target="_blank" rel="noopener">https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html）。我们调查了其他模式，特别是[VIPER]（https://mutualmobile.com/posts/meet-viper-fast-agile-non-lethal-ios-architecture-framework），我们最终用它来创建</a> Riblets。Riblets 的核心创新是业务逻辑驱动，而不是视图逻辑驱动。 如果您不熟悉 MVC 和 VIPER，请阅读一些[关于现代 iOS 架构模式的文章]（<a href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52#.ba5863nnx），然后回过头来看看在" target="_blank" rel="noopener">https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52#.ba5863nnx），然后回过头来看看在</a> Uber 采用它们的利弊。</p><h4 id="MVC-Model-View-Controller"><a href="#MVC-Model-View-Controller" class="headerlink" title="MVC (Model-View-Controller)"></a>MVC (Model-View-Controller)</h4><p>乘客端应是在大约四年前由少数几个工程师创建的。 虽然 MVC 模式在当时是有意义的，但随着程序的规模越来越大，也就越来越难以管理。 随着业务的增长和团队的扩大， MVC 的弊端越发明显。具体来说，有两大问题：</p><p>首先，成熟的 MVC 架构经常面临<a href="https://www.smashingmagazine.com/2016/05/better-architecture-for-ios-apps-model-view-controller-pattern/" target="_blank" rel="noopener">重量级视图控制器</a>的困境。例如，RequestViewController 刚开始有 300 行代码，由于处理了太多的功能（业务逻辑，数据操作，数据验证，网络逻辑，路由逻辑等），现在超过 3,000 行。它变得难以阅读和维护。</p><p>其次，MVC 架构的更新过程是不易维护和测试的。我们进行了大量实验，为用户推出了新功能。 这些实验归结为 if-else 语句。 每当将 if-else 语句构建在一个具有许多功能函数的类上时，导致几乎无法推理，更不用说测试了。 此外，由于像RequestViewController 和 TripViewController 代码巨大并且快速增长，因此对应用程序进行更新变得更加空难。 想象一下，进行更改并测试嵌套 if-else 实验的每种可能组合将是多么的困难。由于我们需要实验来继续添加新功能并增加 Uber 的业务，因此这种架构不具备可扩展性。</p><h4 id="VIPER"><a href="#VIPER" class="headerlink" title="VIPER"></a>VIPER</h4><p>在考虑 MVC 的替代方案时，我们受到 VIPER 架构的启发。<a href="https://mutualmobile.com/in-the-news/architecting-ios-apps-viper" target="_blank" rel="noopener">适用于</a> iOS 应用程序的<a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="noopener">简洁架构</a>。VIPER 为 MVC 提供了一些关键优化。首先，它提供了更多的抽象。Presenter 桥接视图逻辑和业务逻辑。Interactor 处理纯粹的数据操作和数据验证，包括向服务层发起调用，例如登录或者发单。最后，Router 启动跳转，例如将用户从首页带到确认页。其次，使用 VIPER 方法，Presenter 和 Interactor 是普通对象，因此我们可以进行简单的单元测试。</p><p>但我们也发现了 VIPER 的一些缺点。它是 iOS 独有架构，意味着我们必须为 Android 做出权衡。由于整个应用程序被固定在视图树上，也就意味着状态由视图驱动。 Interactor 必须通过 Presenter 操作应用程序的业务逻辑，因此需要暴露业务逻辑给 Presenter。至此，通过紧密耦合的视图树和业务树，很难实现仅包含业务逻辑或仅包含视图逻辑的业务节点，无法达到解藕的目的。</p><p>虽然 VIPER 对使用的 MVC 模式进行了重大改进，但它并没有完全满足，清晰的模块化定义，和高可扩展性。所以我们在兼顾 VIPER 优势，同时规避其架构模式缺点的基础上，实现了我们自己的架构： Riblets。</p><h3 id="Riblets-Uber-乘客端架构"><a href="#Riblets-Uber-乘客端架构" class="headerlink" title="Riblets: Uber 乘客端架构"></a>Riblets: Uber 乘客端架构</h3><p>在我们的新架构模式中，业务逻辑被分解为小的，可独立测试的单元，每个单元目的明确，遵循单一责任原则。 我们使用 Riblets 作为这些模块化部件，整个应用程序结构为 Riblets 树。</p><h4 id="Riblets-组件"><a href="#Riblets-组件" class="headerlink" title="Riblets 组件"></a>Riblets 组件</h4><p>通过 Riblets，我们将职责分配给六个不同的组件，进一步抽象业务和视图逻辑：</p><p><a href="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2016/12/riblets.png" target="_blank" rel="noopener"><img src="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2016/12/riblets.png" alt></a></p><p>Riblets 与 VIPER 和 MVC 的区别是什么？路由由业务逻辑而非视图逻辑引导。这意味着应用程序由信息流和决策流驱动，而不是 Presenter。在Uber，并非每个业务逻辑都与用户看到的视图相关。不是将业务逻辑集中到 MVC 中的 ViewController 或通过 VIPER 中的 Presenter 操作应用程序状态。我们可以为每个业务逻辑提供不同的 Riblets，这些 Ribltes 可以组合出不同意义的逻辑分组。 Riblet 模式被设计为​​跨平台的，达到统一 Android 和 iOS 架构的目的。</p><p>每个 Riblet 由 <strong>R</strong>outer，<strong>I</strong>nteractor 和 <strong>B</strong>uilder 及其 Component 和可选的 Presenters 和 Views 组成。Router 和 Interactor 处理业务逻辑，而 Presenter 和 View 处理视图逻辑。</p><p>让我们使用车型切换 Riblet 作为示例，确定每个 Riblet 单元负责的内容。</p><p><a href="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2016/12/product_selction.png" target="_blank" rel="noopener"><img src="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2016/12/product_selction.png" alt></a></p><p>新乘客端APP，车型切换功能。</p><h4 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h4><p>Builder 实例化所有主要 Riblet 单元并定义依赖关系。 在车型切换 Riblet 中，此单元定义城市流（特定城市的数据流）依赖关系。</p><h4 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h4><p>Component 获取并实例化 Riblet 的依赖项。 这包括服务，数据流以及其他不是主要 Riblet 单元的内容。 车型切换组件获取并实例化城市流依赖关系，将其与对应的网络事件进行关联，并将其注入到 Interactor。</p><h4 id="Routers"><a href="#Routers" class="headerlink" title="Routers"></a>Routers</h4><p>Routers 通过添加和删除 子Riblets 形成应用程序树，同时驱动组件内 Interactor 的生命周期。 这些决定由外部 Interactor 传递。路由器包含两个业务逻辑：</p><ol><li>添加和删除组件</li><li>子组件间状态切换</li></ol><p>车型切换 Riblet 没有任何子 Riblets。 其父 Riblet 的 Router， 确认 Riblet 负责添加车型切换的 Router 并将其 Views 添加到 View 层次结构中。 然后，一旦选择了车型，车型切换 Router 将停用其 Interactor。</p><h4 id="Interactors"><a href="#Interactors" class="headerlink" title="Interactors"></a>Interactors</h4><p>Interactors 执行业务逻辑：</p><ul><li>调用服务来启动操作，比如请求搭车</li><li>调用服务来获取数据</li><li>决定要转换到下一个的状态。 例如，如果根 Interactor 监听到用户的身份验证令牌过期，它会向其 Router 发送切换到 “欢迎” 状态的请求。</li></ul><p>车型切换 Interactor 包含城市流数据，包括该城市服务的车型，定价信息，预估行程时间和车辆视图。 它将此信息传递给 Presenter。 如果用户从拼车切换到优享，则 Interactor 会从 Presenter 接收此信息。 然后它会收集相关数据传给 View，这样它就可以显示 uberX 车辆和预估行程时间。 简而言之，Interactor 执行随后 View 中显示的所有业务逻辑。</p><h4 id="View-Controller"><a href="#View-Controller" class="headerlink" title="View (Controller)"></a>View (Controller)</h4><p>视图构建和更新UI，包括实例化和布局 UI 组件，处理用户交互，UI 组件数据填充和动画。 车型切换 Riblet 的 View 显示它从 Presenter 接收的数据（车型选项，定价，ETA，地图上的车辆视图）并反馈用户操作（即车型切换）。</p><h4 id="Presenter"><a href="#Presenter" class="headerlink" title="Presenter"></a>Presenter</h4><p>Presenters 管理 Interactors 和 Views 之间的通信。 从 Interactors 到 Views，Presenter 将业务模型转换为 View 可以显示的模型。 对于车型切换，这包括定价数据和车辆视图。 从 Views 到 Interactors，Presenters 将用户交互事件（例如，点击按钮选择车型）转换为 Interactors 中的相应操作。</p><h3 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h3><p>Riblets 只有一个 Router 和 Interactor，但可以有多个 View 部分。仅处理业务逻辑且没有用户界面元素的 Riblet 没有视图部分。 因此，Riblets 可以是单视图（一个 Presenter 和一个 View），多视图（一个 Presenter 和多个 Views，或多个 Presenter 和 Views），或者是无视图（没有 Presenter 和 View）。 这允许业务逻辑树的结构和深度与视图树不同，视图树将具有更平坦的层次结构。 这有助于简化页面切换。</p><p>例如，乘车 Riblet 是一个无视图的 Riblet，用于检查用户是否有有效的行程。如果已经开始行程，它添加行程 Riblet，将行程显示在地图上。如果没有，它将添加请求 Riblet，请求 Riblet 将在屏幕显示，允许用户请求行程。像乘车 Riblet 这样没有视图逻辑的 Riblet，通过分解业务逻辑驱动应用程序，在支持这种新体系结构的模块化方面，发挥了重要作用。</p><h3 id="Riblets-构建应用程序"><a href="#Riblets-构建应用程序" class="headerlink" title="Riblets 构建应用程序"></a>Riblets 构建应用程序</h3><p>Riblets 组成了应用程序树，并且经常需要进行通信以便更新信息或将用户带到下一阶段。 在我们讨论他们如何通信之前，让我们首先了解数据在一个 Riblet 中是如何流动的。</p><h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><p>Interactors 拥有状态的作用范围和业务逻辑。该单元进行服务调用获取数据。 在新架构中，数据是单方向流动的。 它从 Service 到 Model Stream，然后从 Model Stream 到 Interactor。 来自服务器的交互，调度和推送通知可以要求 Service 对 Model Stream 进行更改。Model Stream 生成不可变模型。 这强制要求 Interactors 类必须使用服务层来更改应用程序的状态。</p><p><a href="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2016/12/data_flow.png" target="_blank" rel="noopener"><img src="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2016/12/data_flow.png" alt></a></p><p>示例流程：</p><ul><li><p><strong>从后端服务到视图:</strong> 服务调用（如状态）从后端获取数据。 将数据放置在不可变 Model Stream 上。 Interactor 监听新数通知并将其传递给 Presenter。 Presenter 格式化数据并将其发送给 View。</p></li><li><p><strong>从视图到后端:</strong> 用户点击按钮（如登录），然后 View 将交互传递给 Presenter。 Presenter 在 Interactor 上调用登录方法，该方法调用 Service 进行登录。 返回的令牌由 Service 在数据流上发布。 Interactor 监听数据流，收到通知后 Interactor 切换 Riblet 到首页 Riblet。</p></li></ul><h4 id="Riblets-间通信"><a href="#Riblets-间通信" class="headerlink" title="Riblets 间通信"></a>Riblets 间通信</h4><p><a href="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2016/12/riblet_comms.png" target="_blank" rel="noopener"><img src="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2016/12/riblet_comms.png" alt></a></p><p>当 Interactor 做出业务逻辑决策时，它可能需要通知另一个 Riblet（例如，完成）并发送数据。为实现此目的，做出业务逻辑决策的 Interactor 调用另一个 Riblet 的 Interactor 。</p><p>通常，如果通信是 Riblet 树上，从子 Riblet 传递到父 Riblet 的 Interactor，则该接口被定义为侦听器。侦听器几乎总是由父 Riblet 的 Interactor 实现。如果通信向下传递给子 Riblet，则应将接口定义为代理，并由子 Riblet 的 Interactor 实现。代理仅用于 Riblet 单元之间的同步通信，例如父 Interactor 与子 Interactor 之间的同步。</p><p>特别是对于向下通信，作为代理的替代方法, 父 Riblet 可以选择将可观察的数据流暴露给子 Riblet 的 Interactor。然后，父 Riblet 的 Interactor 可以通过此流将数据发送到子 Riblet 的 Interactor。在大多数用于发送数据的向下通信中，这应该是首选的通信方法。</p><p>例如，车型切换 Interactor 确定已选择车型时，它会调用其侦听器以传递所选的车辆视图 ID。侦听器由确认 Interactor实现。然后，确认 Interactor 存储车辆视图 ID，以便可以在服务请求中发送，调用其 Router 分离车型切换 Riblet。</p><p>通过以上方式构建 Riblets 内部和 Riblets 之间的数据流通信，我们能够确保在正确的页面正确的时间出现正确的数据。因为 Riblets 基于业务逻辑形成应用程序树，所以我们可以通过业务逻辑（而不是视图逻辑）来路由通信。这对我们的业务意义重大，并最终有助于代码隔离，防止应用程序开发变得过于复杂。</p><h3 id="回到起点"><a href="#回到起点" class="headerlink" title="回到起点"></a>回到起点</h3><p>当我们重新开始乘客端时，希望提高乘客体验的可靠性和为未来的应用程序开发建立标准规范。创建新架构对于实现这两个目标至关重要。</p><h4 id="如何提高乘车体验的可靠性"><a href="#如何提高乘车体验的可靠性" class="headerlink" title="如何提高乘车体验的可靠性 ?"></a>如何提高乘车体验的可靠性 ?</h4><p>Riblets 有明确的职责划分，因此测试更加简单。每个 Riblet 都是可独立测试的。通过更充分的测试，当推出更新时，我们可以对应用的可靠性更有信心。由于每个 Riblet 只负责一个任务，因此很容易将 Riblet 及其依赖项分离到核心代码和可选代码中。通过对核心代码进行更严格的审查，我们可以对核心流程的可用性更有信心。</p><p>我们提供了核心流程全局回滚到可用状态的能力。所有可选代码都具备开关能力，如果部分功能有问题，可以将其关闭。在最糟糕的情况下，我们可以关闭全部可选代码，保留默认的核心流程。由于我们在核心代码上有超高的标准，可以确保我们的核心流程始终有效。</p><h4 id="如何为开发建立标准规范"><a href="#如何为开发建立标准规范" class="headerlink" title="如何为开发建立标准规范 ?"></a>如何为开发建立标准规范 ?</h4><p>Riblets 帮助我们尽可能缩小和分离功能。清晰的分离业务和视图逻辑，将有助于防止我们的代码库变得过于复杂并使其易于工作。由于新架构与平台无关，因此 iOS 和 Android 工程师可以轻松了解对方如何开发，从一方的错误中吸取教训，并共同推动 Uber 向前发展。由于 Riblets 帮助我们将可选代码与核心代码分开，因此实验将不太容易对核心体验产生附带影响。我们将能够在 Riblet 架构中将新功能作为插件进行尝试，而不必担心它们可能会意外地将 uberX 和 uberPOOL 体验置于bug 的风险之中。</p><p>由于 Riblets 加强了抽象和责任分离，并且有明确的数据流和通信路径，因此持续开发变得很容易。这种架构将在未来几年内为我们服务。</p><h3 id="星辰大海"><a href="#星辰大海" class="headerlink" title="星辰大海"></a>星辰大海</h3><p>我们的新架构使我们为未来的发展做好了准备。最新的重构意味着完全重做乘客端的代码，重新实现以前存在的内容，执行用户研究，案例研究，A/B 测试以及编写新功能。最重要的是，我们希望进行全球推广，以便更快地将新应用程序交付给用户，因此我们从设计，功能，本地化，设备和测试角度考虑了全球变化。 虽然已经投放市场，但我们新架构下的工作才刚刚开始。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Uber-新架构-RIBs-的前世今生&quot;&gt;&lt;a href=&quot;#Uber-新架构-RIBs-的前世今生&quot; class=&quot;headerlink&quot; title=&quot;Uber 新架构 RIBs 的前世今生&quot;&gt;&lt;/a&gt;Uber 新架构 RIBs 的前世今生&lt;/h1&gt;&lt;p&gt;&lt;a
      
    
    </summary>
    
      <category term="翻译" scheme="https://hongruqi.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
  <entry>
    <title>为什么我们决定重构 Uber 司机端</title>
    <link href="https://hongruqi.github.io/2019/02/21/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E5%86%B3%E5%AE%9A%E9%87%8D%E6%9E%84%20Uber%20%E5%8F%B8%E6%9C%BA%E7%AB%AF/"/>
    <id>https://hongruqi.github.io/2019/02/21/为什么我们决定重构 Uber 司机端/</id>
    <published>2019-02-20T16:00:00.000Z</published>
    <updated>2019-02-23T06:30:54.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么我们决定重构-Uber-司机端"><a href="#为什么我们决定重构-Uber-司机端" class="headerlink" title="为什么我们决定重构 Uber 司机端"></a>为什么我们决定重构 Uber 司机端</h1><p><a href="https://eng.uber.com/wp-content/uploads/2018/10/Carbon_rewrite_feature_image_lrg.png" target="_blank" rel="noopener"><img src="https://eng.uber.com/wp-content/uploads/2018/10/Carbon_rewrite_feature_image_lrg-696x417.png" alt="Why We Decided to Rewrite Uber&#39;s Driver App" title="Driver App Rewrite: Why - feature image"></a></p><p><strong>本文是 Uber 的客户端工程师团队是如何开发最新版本司机端的系列文章中的第一篇，代号 <a href="https://eng.uber.com/tag/carbon/" target="_blank" rel="noopener">Carbon</a> ，是我们拼车业务的一个核心组件。除了其他新功能之外，司机端 APP 还为超过 300万 司机提供收入，引导他们挣钱。2017年我们结合司机的反馈开始对司机端进行重新设计，并在2018年9月份启动了该项目。</strong></p><p>2017年初，我们决定对司机端进行重构。这就是 StackOverflow 的 CEO Joel Spolsky <a href="https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/" target="_blank" rel="noopener">曾经</a> 说过的“任何一家软件公司都可能犯下的一个巨大的错误”的决定。</p><p>重构风险极高，需要集中大量资源，花费大量时间才能给用户带来收益。这次重要的重构，除了设计师、PM、数据分析师、运营、法务和市场之外，有几百名工程师参与。实际上，我们花费了一年半的时间才完成并推广到全球。</p><p>我们的情况是一个所有部门的工程师都面临的一个极端问题。如果你是一个正在准备编写或者准备重构某些代码或者一个功能的工程师，你或许会问：“我们有多少开发的时间？”，如果你在一个大的部门下面的一个小团队里面，你或许会问：“对一个没有开发的一个功能，是否值得做这么大的改变？”，一个出色的的工程师和一个出色的团队在准备接受重构的挑战的之前将会认真的研究一下这些广泛的问题。</p><p>因此，虽然重构过程中会涉及一些重要的技术决策（后续文章会有涉及），但需要综合技术考虑和广泛的业务问题来决定。虽然这些问题很难回答，但针对上述问题还是需要一个好的答案来向你的团队或者部门证明重构是合理的。</p><p>最后，这些决策不是凭空而来的。我们之所以决定重构 APP，并不是基于理论架构思维（“我们的代码可能会更好，如果我们……”），而是需要长达三个月的集中研究数百页的文档和广泛的跨组织的支持。在下面的章节中，我们将探讨重构 Uber 司机端的决定和我们在这个过程中发现了什么。</p><h2 id="奠定基础"><a href="#奠定基础" class="headerlink" title="奠定基础"></a>奠定基础</h2><p>重构的需要并不总是自然而然地来自于对新体系结构的简单认识。重构的代价是巨大的，虽然工程组织经常想要重构代码，但是工程师的时间还需要做新需求，而不是一遍又一遍的重构同一个功能。对于司机端来说，有以下三个趋势有助于推动重构的决定：</p><h3 id="技术债务"><a href="#技术债务" class="headerlink" title="技术债务"></a>技术债务</h3><p>首先，司机端本身存在技术债务。这些债务是优步快速增长的结果，也是产品需求变化的结果（下一节讨论）。不仅如此， 技术债务还来自于修复以前的技术债务：应用本身陷入了多次持续迁移，使得功能看起来越来越复杂。</p><p>值得指出的是司机端存在的技术债务不只是理论上的。由于持续的中断和维护成本导致开发人员生产力下降，我们看到了真正的业务影响。2016 年底，我们不得不暂停 APP 的开发，以修复多个功能退化。在我们解决这些问题之前，开发和启动新功能都变得非常困难。</p><p>任何中断对于我们司机端来说都是一个巨大的问题，因为用户依赖它谋生。我们认为，任何事都不能让可用时长低于 99.99% ，然而我们经常发布在应用核心流程中出现严重问题的版本。</p><h3 id="产品挑战"><a href="#产品挑战" class="headerlink" title="产品挑战"></a>产品挑战</h3><p>我们面临一个最大的问题就是司机端之前的版本无法很好地适用新的业务场景。早期只是简单的按照优选轿车去设计和迭代的司机端，但是现在我们的业务已经发展到还包含拼车、特价车和服务于市场线下现金交易体验等等。</p><p>我们发现除了打车业务，司机还需要其他的功能来管理他们的资产和私人业务。例如，收入和透明的评分对司机的体验至关重要，而在优步司机端的早期版本中这方面投资不足。我们需要提供类似这样功能的可扩展性，来提升产品体验。</p><p><a href="https://eng.uber.com/wp-content/uploads/2018/10/Figure_1_Carbon_rewrite.png" target="_blank" rel="noopener"><img src="https://eng.uber.com/wp-content/uploads/2018/10/Figure_1_Carbon_rewrite-1024x759.png" alt="Two screenshots of the previous driver app"></a></p><p>图一：司机端之前的版本中，底部的功能标签超出了之前的预期（左）。地图超负荷的承载了许多业务大头针和线路图（右）也超出了之前的预期。</p><p>我们在 2015年 和 2016年 采取了一些初步的步骤来减少这些痛点，发布了一个更新版本。不幸的是，我们为不同的团队设计了一些 UI ，而不是围绕司机的需求和工作流程设计。如果你在这段时间仔细看了我们的 UI ，你就会发现主页下面有四个标签：收入、评分、设置和首页。每个功能标签都变得越来越臃肿，并且收入和评分标签经常为了需求改变意图，而违背了设计初衷。</p><p>我们从 APP 的迭代中得到的教训，以及向着我们长期的产品规划，实际上已经促使我们彻底重新思考司机端应该如何寻找我们的司机合作伙伴。即使重构不是必然的，也需要重新设计。</p><h3 id="工程对齐"><a href="#工程对齐" class="headerlink" title="工程对齐"></a>工程对齐</h3><p>我们的研发团队预先在新的方向做了一些投入。特别是，伴随着 2016年 <a href="https://eng.uber.com/new-rider-app/" target="_blank" rel="noopener">乘客端的重构</a> 我们引进了一个新的移动端架构，我们叫做 <a href="https://github.com/uber/RIBs/wiki" target="_blank" rel="noopener">RIBs</a>（<a href="https://github.com/MindorksOpenSource/iOS-Viper-Architecture" target="_blank" rel="noopener">VIPER</a> 架构的一个演进），来帮助我们处理日益增长的规模。它能够解决在司机端的大多数问题：框架的可扩展性、强大的应用架构和有说服力的内存管理模块。我们在 2017年 开源了 RIBs 架构。</p><p>随着 RIBs 架构确实改进了我们的乘客端，同时它也代表了我们移动端组织一个新的方向。未来我们的核心平台将会主要投入在 RIBs 架构上。相比使用标准化的 RIBs 架构而言，每个应用都使用自己的架构将会花费更多的资金。</p><h2 id="决策过程"><a href="#决策过程" class="headerlink" title="决策过程"></a>决策过程</h2><p>拿到新的 UI 设计和一个新的架构，我们本质上有三个不同的做法：不使用 RIBs 架构重新设计司机端、让现有的司机端去适配 RIBs 架构和基于 RIBs 架构完全对司机端重构。</p><h3 id="不使用-RIBs-架构"><a href="#不使用-RIBs-架构" class="headerlink" title="不使用 RIBs 架构"></a>不使用 RIBs 架构</h3><p>第一个方法就是我们不使用 RIBs 架构重新设计。原因是我们考虑到迁移 RIBs 架构是资源密集型。虽然 RIBs 引入了大量新的代码库，但也是构建应用的一种新方式：将业务逻辑和显示逻辑解耦。RIBs 架构很有说服力，但浸入性非常强。</p><p>首先，我们考虑现有的应用是否能够处理我们正在考虑的主要的产品变更。我们发现，由于一部分逻辑在视图控制器里，导致许多业务逻辑和视图展示层是强耦合的。这也就意味着 UI 层面的重新设计必然会牵扯到许多业务逻辑的修改。</p><p>其次，正如前面所说，现有的司机端架构一些问题需要解决。这些问题部分正好与 app 的逻辑有关，有一些地方（特别是 Android ）都用一个模式开发是移动开发者的一个通病：不同版本的 MVC，都存在臃肿的视图控制器问题，我们大部分的核心代码都写在一个几千行的控制器文件里。因此，我们不愿意把现有架构变得更糟，变得越来越复杂和难以维护。</p><p>最后，虽然旧版本司机端的架构曾经是完美的，但是长远战略考虑适配 RIBs 架构能够避免在优步不同 app 的架构分歧。一种强有力的架构，能够给我们的平台带来双倍的收益，在一个团队（比如乘客端）写的代码还能在另一个团队（比如司机端）复用。</p><p>如果适配 RIBs，我们该怎么做呢？</p><h3 id="适配"><a href="#适配" class="headerlink" title="适配"></a>适配</h3><p>许多团队喜欢小心翼翼地迁移，这样能够允许他们在系统的架构变更的时候继续开发新功能。在大多数情况下这种方法是完美有效的，在这里我们讨论下优步这样做出现的一些问题。</p><p>首先，我们分析了过去几年在优步实施的十个主要的适配，发现它们的失败率很高。正如他们所说，我们将要开始适配一个基础库，但是彻底失败了。新功能是基于新的库开发的，一些旧的功能也适配了，但是基础库里面仍然有一些遗留代码在运行。</p><p>在进一步调查研究之后，我们发现司机端的许多技术债务的根本原因是这样的适配引起的。例如，我们有竞争条件因为我们的应用程序的发布订阅模式在安卓上是一分为二的。我们核心的应用架构最初是利用安卓的<code>fragments</code>，后来部分适配了内部框架。这种不完整的适配导致适配层和一般开发者的困惑。这些不完整的架构推进将会最后导致运行中断直接影响到我们的用户。</p><p>其次，我们经常发现在适配时造成大量的不稳定。我们有许多次宕机都是由于打算改善底层应用框架，例如网络协议。从技术上讲，这些不会对我们的用户造成直接的影响，但是最终会影响 app 的核心功能。</p><p>最后，在我们的经验中，甚至连继续开发功能的承诺都没有实现。如果一个团队依赖一个正在进行的适配，则经常会被阻塞直到适配工作完成。它还导致：回滚适配通常意味着我们还必须回滚大量的功能。</p><p>因此，当我们对是否进行完整的产品重新设计和采用 RIBs 架构评估后，不完整的适配或无止境的适配层极大的增加了应用程序的不稳定性的风险太高了。</p><h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p>在某种程度上，我们作出这个决定是通过否定（其他选项，不使用 RIBs 架构和适配，是不合理的），但是重构有决定的好处，它提高了我们做最后决定的信心。</p><p>第一，重构能够提高我们对重新设计 app 的生产力，而不需要受先理解以前是怎么工作的。也就意味着它的设计可以更加通用。</p><p>第二，选择重构也意味着我们的架构将会更加清晰，因为它将从一开始就会有一个令人信服的策略方向。如果我们选择适配，我们可能会被出于方便重用或者便利的遗留代码所卡住。</p><p>第三，对 app 的重构会促使我们走到画板面前更加完整的思考我们想要的产品方向。结果，app 中的某些主要框架将被重构。</p><p>对于一个工程师来说，重构是一个挑战自我的机会，我们迫不及待的要开始了。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>值得强调的是重构司机端的决定并不是基于“如果我们能重做就会更好”这样的想法。事实上，一些工程师肯能会惊讶的听到，即使在重构之后，我们发布的 app 不仅使用了新的功能和新的架构，甚至还有一点新的技术债务。</p><p>也就是说，你不可能把事情处理的非常完美。阅读了这篇文章的工程师应该对“适配不合理，重构才能写出完美的代码”这个结论质疑。相反，重要的是要意识到重构应该是在非常具体的组织，业务和技术需求下决定的。</p><p>如果我们没有在数月之前产出一个新的手机架构，或许不会重构。如果我们没有一个产品团队来调研的话，或许不会重构。如果优步之前的适配工作非常成功的话，我们或许不会重构。当然，促使我们重构的原因不是说重构一定是非常好的，甚至不是一个好主意。</p><p>反而，司机端的重构来自于想要为我们的用户创建一个更可靠和更强的产品体验，同时，在这个版本也增强了我们团队的能力。在做这个决定的过程中或许没有创建一个最佳抽象层那么兴奋，但它是成功的、完全的改进了手机应用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么我们决定重构-Uber-司机端&quot;&gt;&lt;a href=&quot;#为什么我们决定重构-Uber-司机端&quot; class=&quot;headerlink&quot; title=&quot;为什么我们决定重构 Uber 司机端&quot;&gt;&lt;/a&gt;为什么我们决定重构 Uber 司机端&lt;/h1&gt;&lt;p&gt;&lt;a hre
      
    
    </summary>
    
      <category term="翻译" scheme="https://hongruqi.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Uber Eats 支持现金支付</title>
    <link href="https://hongruqi.github.io/2019/02/20/Uber%20Eats%20%E6%94%AF%E6%8C%81%E7%8E%B0%E9%87%91%E6%94%AF%E4%BB%98/"/>
    <id>https://hongruqi.github.io/2019/02/20/Uber Eats 支持现金支付/</id>
    <published>2019-02-19T16:00:00.000Z</published>
    <updated>2019-02-23T06:46:09.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Uber-Eats-支持现金支付"><a href="#Uber-Eats-支持现金支付" class="headerlink" title="Uber Eats 支持现金支付"></a>Uber Eats 支持现金支付</h1><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/12/Carbon_Cash_feature_image.png" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/12/Carbon_Cash_feature_image-696x522.png" alt="Scaling Cash Payments in Uber Eats - feature_image" title="Scaling Cash Payments in Uber Eats - feature_image"></a></p><p>本文是 Uber 的客户端工程师团队讲述了如何开发最新版本司机端<a href="https://eng.uber.com/tag/carbon/" target="_blank" rel="noopener">系列</a>文章中的第四篇，该系列代号 Carbon ，是我们共享出行业务的核心。包括其它功能在内，Uber 司机端使得超过 300 万名司机可以查看费用、里程以及收益情况。2017 年我们结合司机的反馈开始对司机端进行重新设计，并在 2018 年 9 月份启动了该项目。 </p><p>Uber 作为全球性公司，努力使其服务保证可用。所以要利用技术做到功能本地化。其中关键的一项工作是使用户可以选择最有效的付款方式，无论是信用卡，借记卡，或者是当地特殊的支付方式，例如现金支付。</p><p>对于 Uber 的大部分市场来说，其出行业务和外卖业务所使用的普遍支付方式并不是信用卡和借记卡。直到 2016 年，这些线上支付方式是主要支持的类型，这使得那些只用现金支付的用户很难去使用我们的服务。首次<a href="https://eng.uber.com/india-payments/" target="_blank" rel="noopener">支持现金支付</a>是在孟买，这里的乘客只有少部分有信用卡。所以他们很欢迎使用现金支付，接着我们在印度，拉丁美洲，非洲也支持了这种方式。</p><p>然而，直到 2017 年 9 月，外卖服务才支持现金支付，首次支持的城市也是孟买。迟到 2 年的原因是: 外卖三方市场的复杂性，它包括餐厅，配送员和食客。</p><p>克服这项挑战，即要改变操作流程又要支持新的技术。尤其<a href="https://www.uber.com/newsroom/new-driver-app/" target="_blank" rel="noopener">我们新的司机端</a>( Carbon )支持扩展现金支付的能力。通过这些创新服务，我们能够给全球更多的用户提供外卖服务。</p><h2 id="现金收款的挑战"><a href="#现金收款的挑战" class="headerlink" title="现金收款的挑战"></a>现金收款的挑战</h2><p>在出行业务支持现金支付的城市，司机留下现金，然后从线上支付的订单中去支付 Uber 的费用。这种情况下，智能派单系统保证司机接到足够的线上支付订单，以此来支付之前属于 Uber 的现金单费用。司机非常乐意在行程结束时能够及时收取现金，同时这项功能对那些没有信用卡的用户也是非常重要的。</p><p>对于拥有三方市场的外卖业务来说，大部分属于餐厅的现金需要配送员去收取。并且，对于信用卡，借记卡使用率不高的地区，派发足够多线上支付的订单去抵消未收付的现金是不太现实的。比起让配送员把现金送回餐厅，我们需要一个可持续的方法在食客和餐厅之间进行现金转移。</p><p>首先我们尝试了第三方的现金收款服务，例如有合作关系的便利店，传统的银行存款，转账。这种方法的问题在于：支持 Uber 外卖的城市并不都支持这些服务，并且限制了现金支付的地方，需要配送员停下来去完成那些不属于配送过程中的任务。</p><p>理想中的现金收款方法需要适用于现在和将来所有支持外卖服务的地区，并且方便于配送员操作。更进一步，当现金支付的地区不具备可靠的网络环境，现金交换操作能够完全离线完成。</p><h2 id="我们新的方法"><a href="#我们新的方法" class="headerlink" title="我们新的方法"></a>我们新的方法</h2><p>产品方案很新颖：<strong>利用所有餐厅作为一个现金流动的分布式网络</strong>。配送员带着之前订单的现金去往有合作关系的餐厅，然后用现金去支付订单，这与食客的支付方式无关。为了避免取餐过程中不必要的冲突，支付金额与订单金额相等，因为收到不等的金额会给餐厅的出纳造成混乱。餐厅还是能保持所有现金收入，并且乐于看到及时付款。 Uber 将会从后续的线上订单中扣除配送和预约。</p><p>这个机制运行的不错，它在当前和未来的外卖市场都能进行扩展，并且操作集成到了每次配送中，使现金支付成为配送过程中的常规组成部分。我们下一个挑战是：<strong>确保餐厅欠款的收集能够离线完成</strong>.幸运的是，新司机端中的离线功能能够覆盖一些 Case，例如司机在网络情况差的地方结束订单。这个功能与我们现金支付的需求很吻合。</p><h2 id="利用乐观模式"><a href="#利用乐观模式" class="headerlink" title="利用乐观模式"></a>利用乐观模式</h2><p>在 Uber 运营的许多新兴市场，可靠的网络环境是不能保障的。之前的司机应用在整个行程中需要可靠的网络环境，这给我们的司机和配送员带来了令人沮丧的体验。例如，司机必须将乘客带到一个网络环境良好的地方才能结束订单。对于配送员来说，情况可能更糟，地下或建筑物内的交付和配送受网络环境影响更大。</p><p>新司机端的众多新功能中有一个是<a href="https://eng.uber.com/driver-app-optimistic-mode/" target="_blank" rel="noopener">乐观模式(Optimistic Mode)</a>,它允许功能在无网情况下使用。当开启的时候，无论网络请求是否成功，应用的状态会立马更新并保持响应。失败的请求会被记录，缓存，并在网络恢复连接后进行重试。不管实际网络延时情况，应用能快速响应，用户能够正常操作。使用乐观模式，行程可以在弱网或无网情况下开始和结束。对于外卖服务，配送员可以在无网情况下完成整个餐厅现金收付流程。</p><h2 id="餐厅欠款收集功能"><a href="#餐厅欠款收集功能" class="headerlink" title="餐厅欠款收集功能"></a>餐厅欠款收集功能</h2><p>如果希望餐厅能无缝从配送员那收集欠款，需要新版的 Android/iOS 司机端和餐厅端(使用 <a href="https://eng.uber.com/ubereats-react-native/" target="_blank" rel="noopener">React Native</a> 编写 )，以及新版的后端服务。我们构建了一个新的微服务( microservice )去支持餐厅的现金流服务，它的客户端( clients )有以下几个职责：</p><ul><li>决定餐厅现金支付的资格。</li><li>计算建议支付的现金总额。</li><li>使用状态机来维持现金支付流程中的状态。</li><li>在手机端和餐厅端中显示格式化后的数据。</li></ul><p>如图 1 所示，现金流包含以下几个状态:</p><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/12/Carbon_Cash_Figure-01.png" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/12/Carbon_Cash_Figure-01.png" alt="Graph of Uber Eats payment flow"></a></p><p>图 1: 映射现实世界中配送员如何在餐厅结算现金欠款机制的现金流状态机模型。</p><p> 在调度中时，配送员会默认选择完成现金支付的操作，之后的主动操作是需要网络连接时完成。如图 2，在配送开始时，会认为配送员是处于网络状态良好的环境中，否则，他们不会收到派送信息。之后我们会把流程结束的完整信息发送过去，这样后续操作不需要网络一直连接，并且会提醒餐厅可能是现金支付，如图 3 所示。配送员可能会退出现金支付页面并继续之后的派送流程，这时乐观模式( Optimistic Mode )会把失败请求存储到磁盘上。网络恢复连接后，会通知后端有临时跳过现金支付的决定。</p><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/12/Carbon_Cash_Figure-02.png" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/12/Carbon_Cash_Figure-02-175x300.png" alt="Mobile interface payment due"></a></p><p>图 2:配送应用上显示需要支付的金额和暂时跳过的选项，</p><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/12/Carbon_Cash_Figure-03.png" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/12/Carbon_Cash_Figure-03-1024x768.png" alt="App screen for restaurant"></a></p><p>图 3:取餐时餐厅收到可选现金支付的信息</p><p>服务支持配送员设置他们能支付的金额，如果配送员手上没有足够支付的金钱或者希望之后派送时再支付，这个功能会非常有用。然而，我们没有开启此功能，更多考虑的是餐厅会收到现金总额与订单总额不符的体验。在当前实践中，如果配送员选择完成现金支付，之后会进入支付状态交换，这时现金总额会自动设置为订单总额。</p><p>离线情况下我们如何进行现金支付交换呢？需要餐厅和配送员都能承认现金支付是令人安心的，可以预防潜在的欺诈。在双方确认后，不能依赖网络请求来提供及时通信，因此我们利用四位数验证码。</p><p>调度过程中，我们同时给司机端和餐厅端提供完成流程所需要的所有信息。如图 4，餐厅得到了一个随机生成的验证码，在现金交换时配送员会被提示去请求它。</p><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/12/Carbon_Cash_Figure-04.png" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/12/Carbon_Cash_Figure-04-1024x768.png" alt="App screen showing four digit sync code"></a></p><p>图 4:在调度时，餐厅得到一个四位验证码。</p><p>相反地，发给手机端的是此验证码<a href="https://en.wikipedia.org/wiki/SHA-2" target="_blank" rel="noopener">SHA256加盐</a>后的 Hash 值，然后在输入餐厅得到的验证码时，会和该验证码的加盐 hash 值进行比对。一旦成功，配送员可以继续完成现金交换流程，并开始下一次配送。hash 值相等性验证发生在线下。为了避免作弊，会限制频率和最大尝试次数。 此外，如果现金支付操作没有完成，验证码会在合理时间内到期。如果发现事务不一致，Uber 会进一步调查，可能会禁止平台内任何有不良行为的用户。</p><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/12/Carbon_Cash_Figure-05.gif" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/12/Carbon_Cash_Figure-05.gif" alt="Mobile screen showing payment flow"></a></p><p>图 5: 配送员输入验证码进行hash和验证。</p><p>如上图 5 所示，一旦验证码输入成功，配送员和餐厅应用会同时显示一个预填充确认的页面。如果网络又出现错误，乐观模式( Optimistic Mode )会缓存失败请求到磁盘，并在网络恢复时重试。配送员支付行为被记录为可信，餐厅的余额根据之后的线上收益进行调整，至此现金支付结束。</p><h2 id="伴随现金支付前进"><a href="#伴随现金支付前进" class="headerlink" title="伴随现金支付前进"></a>伴随现金支付前进</h2><p>虽然乐观模式( Optimistic Mode )设计的初衷是为了 Carbon 的核心出行流程，但是它为这套全新功能的实现提供了可能。Uber 的工程师和设计师团队在开发新功能时摆脱了网络环境的限制。由于现金交接需要多方的高度信任，所以仅依靠餐厅去核实现金交易是行不通的。同时，配送员网络连接状态可能阻塞行程的进行，从而停留在验证的流程中。乐观模式( Optimistic Mode )完美解决了这个问题，它允许现金交接操作在离线环境中进行，并稍后在网络连接恢复时通知后端事务。</p><p>认识到离线操作的价值后，其他的 Carbon 开发团队都是用了乐观模式( Optimistic Mode ),而且 Uber 的移动端网络组在框架中拓展了此功能。这些努力使得 Uber 应用摆脱了网络环境的依赖，成为能离线响应多方市场的应用。</p><h4 id="Index-of-articles-in-Uber-driver-app-series"><a href="#Index-of-articles-in-Uber-driver-app-series" class="headerlink" title="Index of articles in Uber driver app series"></a>Index of articles in Uber driver app series</h4><ol><li><a href="https://eng.uber.com/rewrite-uber-carbon-app/" target="_blank" rel="noopener">Why We Decided to Rewrite Uber’s Driver App</a></li><li><a href="https://eng.uber.com/driver-app-ribs-architecture/" target="_blank" rel="noopener">Architecting Uber’s New Driver App in RIBs</a></li><li><a href="https://eng.uber.com/driver-app-optimistic-mode/" target="_blank" rel="noopener">How Uber’s New Driver App Overcomes Network Lag</a></li><li>Uber Eats 支持现金支付</li><li><a href="https://eng.uber.com/carbon-dual-binary-mobile-app/" target="_blank" rel="noopener">How to Ship an App Rewrite Without Risking Your Entire Business</a></li><li><a href="https://eng.uber.com/building-a-scalable-and-reliable-map-interface-for-drivers/" target="_blank" rel="noopener">Building a Scalable and Reliable Map Interface for Drivers</a></li><li><a href="https://eng.uber.com/uber-beacon-bluetooth-mobile-app/" target="_blank" rel="noopener">Engineering Uber Beacon: Matching Riders and Drivers in 24-bit RGB Colors</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Uber-Eats-支持现金支付&quot;&gt;&lt;a href=&quot;#Uber-Eats-支持现金支付&quot; class=&quot;headerlink&quot; title=&quot;Uber Eats 支持现金支付&quot;&gt;&lt;/a&gt;Uber Eats 支持现金支付&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https
      
    
    </summary>
    
      <category term="翻译" scheme="https://hongruqi.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Uber 指示灯：帮助乘客快速寻找车辆</title>
    <link href="https://hongruqi.github.io/2019/02/19/Uber%20%E6%8C%87%E7%A4%BA%E7%81%AF%EF%BC%9A%E5%B8%AE%E5%8A%A9%E4%B9%98%E5%AE%A2%E5%BF%AB%E9%80%9F%E5%AF%BB%E6%89%BE%E8%BD%A6%E8%BE%86/"/>
    <id>https://hongruqi.github.io/2019/02/19/Uber 指示灯：帮助乘客快速寻找车辆/</id>
    <published>2019-02-18T16:00:00.000Z</published>
    <updated>2019-02-23T06:33:28.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Uber-指示灯：帮助乘客快速寻找车辆"><a href="#Uber-指示灯：帮助乘客快速寻找车辆" class="headerlink" title="Uber 指示灯：帮助乘客快速寻找车辆"></a>Uber 指示灯：帮助乘客快速寻找车辆</h1><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2019/02/Uber_Beacon_feature_image.jpg" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2019/02/Uber_Beacon_feature_image-696x522.jpg" alt="Uber Beacon app screen" title="Connecting Drivers and Riders with Uber Beacon feature image"></a></p><p><strong>本文是 Uber 的客户端工程师团队讲述了如何开发最新版本司机端系列文章中的第七篇，该系列代号 <a href="https://eng.uber.com/tag/carbon/" target="_blank" rel="noopener">Carbon</a> ，是我们共享出行业务的核心。包括其它功能在内，Uber 司机端使得超过 300 万名司机可以查看费用、里程以及收益情况。2017 年我们结合司机的反馈开始对司机端进行重新设计，并在 2018 年 9 月份启动了该项目。</strong></p><p>由于技术和物理因素，接驾对于乘客和司机来说都是一个特别难的痛点。技术方面，我们需要司乘两端达成相对的同步。物理方面，例如在一个夜间拥挤的街道，司机、乘客将彼此很难找寻到对方。对于平台来说，帮助乘客轻松辨识车辆是成功开启愉快行程的关键。</p><p><a href="https://eng.uber.com/uber-beacon/" target="_blank" rel="noopener">指示灯</a> 是我们应用程序进入现实世界的一种扩展，这是一个给司乘 2 方提供直观颜色匹配的设备，乘客可以选择光谱中的任何颜色进行设置。在黑暗和暴风雨的夜晚，选择一种颜色照亮司机车辆的挡风玻璃，可以让你更快速方便的找寻到车辆。事实上推动这种体验的工程设计并不简单。接下来让我们深入了解一下如何利用我们的 APP 实现这种体验。</p><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2019/02/Uber_Beacon_animgif.gif" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2019/02/Uber_Beacon_animgif.gif" alt="Animation showing how Uber Beacon works"></a></p><p>乘客通过指示灯功能来选择一种颜色，然后将其传输给汽车上的指示灯设备，这样乘客就可以快速方便的知道哪辆车是来接他的。</p><h2 id="足迹"><a href="#足迹" class="headerlink" title="足迹"></a>足迹</h2><p>指示灯的大部分功能是在我们司机端 APP 上使用。实现需要使用 2 组资源：Beacon SDK：负责通过蓝牙跟指示灯设备进行通信。<a href="https://eng.uber.com/driver-app-ribs-architecture/" target="_blank" rel="noopener">RIBs架构</a> 中的一系列功能模块利用 Beacon SDK 实现司机端的功能。</p><h3 id="Beacon-SDK"><a href="#Beacon-SDK" class="headerlink" title="Beacon SDK"></a>Beacon SDK</h3><p>Beacon SDK 几乎实现了指示灯设备的所有用户体验功能，它利用蓝牙实现了司机端 APP 和指示灯设备之间连接跟数据沟通的功能。在设计 Beacon SDK 时，我们遵循了三个原理：</p><ul><li><strong>跨平台</strong></li><li><strong>应用独立性</strong></li><li><strong>响应式接口</strong></li></ul><h4 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h4><p>因为 Uber 的移动端架构是跨平台的，同时支持 iOS 跟安卓设备，所以 Beacon SDK 的架构设计也必须是跨平台的。在跨平台方面之后，我们可以更快速的迭代并提供给其他团队更方便的接入方式。</p><h4 id="应用独立性"><a href="#应用独立性" class="headerlink" title="应用独立性"></a>应用独立性</h4><p>SDK 开发最关键的原则是去掉 SDK 对应用的依赖。随着我们逐步开发新司机端 APP，这点显得尤其重要。SDK 的独立性使得我们在新旧司机端 APP 同时开发中可以通过迭代 SDK 的方式同步进行，避免中断。</p><h4 id="响应式接口"><a href="#响应式接口" class="headerlink" title="响应式接口"></a>响应式接口</h4><p>为了兼容 Uber 移动端响应式编程架构，在设计 Beacon SDK 时，必须暴露<a href="http://reactivex.io/documentation/observable.html" target="_blank" rel="noopener">可观察对象(Observable)</a>。使用这个 SDK 的工程师可以直接通过观察反应的方式与指示灯进行交互。使用这个 SDK 的工程师可以直接通过观察反应的方式与指示灯进行交互。蓝牙 API 的使用复杂性被抽象掉了。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>我们设计的 Beacon SDK 具有一系列的管理器对象（Manager），其中每个管理器负责指示灯功能的一部分，例如连接、LED 控制、无线下载（OTA）更新和传感器。每组管理器负责与指示灯设备的某个功能互通，司机端 APP 控制这些的管理器来操作指示灯设备。</p><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2019/02/Uber_Beacon_Figure_1.png" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2019/02/Uber_Beacon_Figure_1-1024x631.png" alt="Tree diagram showing how the core Beacon layer in the driver app connect to Beacon"></a></p><p>图 1：Beacon 被分解成多个逻辑管理器，管理器用来反映 Beacon 状态并提供特定功能。</p><p>管理器（Manager）定义了接口，SDK 提供了对应接口的实现。这些管理器封装了蓝牙 API 将命令从司机端传递到指示灯设备。</p><h3 id="工作者（Workers）"><a href="#工作者（Workers）" class="headerlink" title="工作者（Workers）"></a>工作者（Workers）</h3><p>由于 Beacon SDK 并没有提供专用的用户界面，因此几乎所有的 Beacon 功能都是通过 worker 提供的。Worker 是本质上是没有专用UI组件的交互者，因此逻辑与 APP 中的视图无关。在需要使用指定功能时，Carbon 将 worker 添加到 RIB 树中实现，当从 RIB 树中移除时，worker 被分离且被垃圾回收。</p><p>每个 worker 都依赖于一个或多个 Beacon SDK 管理器（Manager）。 管理器被添加给 RIB 里面的 Worker 对象。当一个 worker 被实例化时，worker 会添加由上游范围提供的管理器对象。通过这种方式，Beacon 的管理器可以在所有 worker 之间共享，并且 worker 不负责这些管理器的生命周期。</p><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2019/02/Uber_Beacon_Figure_2.png" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2019/02/Uber_Beacon_Figure_2-1024x873.png" alt="RIBs tree for driver app showing plugin points for Beacon"></a></p><p>图 2：在 Carbon 的 RIB 树的这一小节中，Beacon 的 Workers 都在 Active 和 Online 的时候才会生效。管理器在 Active 时被添加依赖并提供给下游 Workers。</p><p>RIB 树让我们根据 worker 是否使用 Beacon 功能来决定是启用还是禁用插件点（plugin points）。如果禁用 Beacon，插件点则禁用；如果 worker 不被创建，那么就不会初始化 Beacon SDK 的管理器，从根本上消除了 Beacon 运行时的内存空间。</p><p>如果启用 Beacon 功能，我们需要遵循协议，worker 才会被添加到 RIB 树中。例如 Beacon Alert 管理器，它是在应用内提供例如“低电量”或“指示灯未找到”这种提示窗的管理器。想象一下当司机在家的时候打开 APP 查看他们的收入，此时司机的状态是离线状态，因为司机并没有开始接单；此时司机并没有使用指示灯的需求，因此不需要收到类似的弹窗。我们只会在司机在路上接乘客的时候（在线时）才会接入 Beacon Alert 管理器，因为这个时候提示功能才有意义。</p><h2 id="颜色匹配"><a href="#颜色匹配" class="headerlink" title="颜色匹配"></a>颜色匹配</h2><p>有了 Beacon 框架，我们可以在司机端 APP 中实现颜色匹配功能。</p><p>以下流程都必须严格依赖司机端已连接到指示灯设备且此时是在线状态。当司机在线时，Beacon 的功能 worker 会添加到 RIB 树上，才能使用司机端的 Beacon 功能更新服务器。随着司机端的在线与离线，我们会相应的更新状态。当司机端断线时，后端会自动关闭该功能。</p><p>当司机端接到乘客的订单后，乘客端的 APP 就会收到司机的名字、车辆信息以及他们是否具有指示灯的能力。如果具有指示灯功能，我们会在乘客端 APP 中展示指示灯的图标。乘客端 APP 会自动给服务器发送之前选择过的颜色（如乘客从未选择颜色，则随机选择一种颜色），然后通知给司机端 APP 所选颜色。</p><p>在等待接驾时，乘客可以通过点击指示灯图标进入颜色选择页面（某些特定颜色因为安全合规被移除，例如红色、蓝色），在这里乘客可以选择任何他们中意的颜色。每当乘客选中了一个颜色，就会把这个色值传递给后端，后端又通知给司机端 APP。</p><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2019/02/Uber_Beacon_Figure_3.png" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2019/02/Uber_Beacon_Figure_3-1024x342.png" alt="Diagram of data flow between rider app, backend, and driver app"></a></p><p>图 3：当司机端与指示灯连接成功后，就会被通知给后端，当乘客匹配到这个车辆，乘客就可以选择一种指示灯颜色。</p><p>在司机端这边，当司机在线时，有个 Beacon Color Worker 一直在监听颜色变化的通知。当收到了一个新颜色，就会本地存储一份。这样，如果司机接受了多个调度，例如拼车场景，我们会记录每个被接驾的乘客所设置的颜色。</p><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2019/02/Uber_Beacon_Figure_4.png" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2019/02/Uber_Beacon_Figure_4-1024x487.png" alt="Diagram showing data flow from multiple rider apps to backend"></a></p><p>图 4：行程中有很多个拼车乘客，我们会存储这些乘客每个选择的颜色。</p><p>当后端通知我们已经在去接某个乘客路上时，我们会给 Beacon 控制颜色的管理器发送一条指令（-通过技术手段获得所匹配乘客选择的色值），告诉他显示这个乘客所选中的颜色。同时在接驾过程中，车辆会不断更新显示乘客之后更改的任何颜色，保持乘客端跟司机端的同步。</p><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2019/02/Uber_Beacon_Figure_5.png" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2019/02/Uber_Beacon_Figure_5-1024x400.png" alt="Diagram showing data flow from backend to driver app to Beacon"></a></p><p>图 5：当乘客被接驾时，我们会检索他们所选择的最后一种颜色。</p><h2 id="软硬件的结合"><a href="#软硬件的结合" class="headerlink" title="软硬件的结合"></a>软硬件的结合</h2><p>优步一直在寻找优化用户体验的方法。软硬件结合的方式将平台能力扩展到现实世界是一种自然的进步。软硬件结合的方式将平台能力扩展到现实世界带来了新的令人兴奋的挑战，优步指示灯只是如何在这个领域进行创新的一个例子。这也是优步的移动工程师最激动人心的时刻。</p><h4 id="Index-of-articles-in-Uber-driver-app-series"><a href="#Index-of-articles-in-Uber-driver-app-series" class="headerlink" title="Index of articles in Uber driver app series"></a>Index of articles in Uber driver app series</h4><ol><li><a href="http://way.xiaojukeji.com/article/13418" target="_blank" rel="noopener">为什么我们决定重构 Uber 司机端</a></li><li><a href="http://way.xiaojukeji.com/article/13454" target="_blank" rel="noopener">使用RIBs重构Uber司机端</a></li><li><a href="https://eng.uber.com/driver-app-optimistic-mode/" target="_blank" rel="noopener">新 Uber 司机端是如何克服网络延迟问题的</a></li><li><a href="https://eng.uber.com/driver-app-cash-payments/" target="_blank" rel="noopener">Scaling Cash Payments in Uber Eats</a></li><li><a href="https://eng.uber.com/carbon-dual-binary-mobile-app/" target="_blank" rel="noopener">How to Ship an App Rewrite Without Risking Your Entire Business</a></li><li><a href="https://eng.uber.com/building-a-scalable-and-reliable-map-interface-for-drivers/" target="_blank" rel="noopener">Building a Scalable and Reliable Map Interface for Drivers</a></li><li>Uber指示灯：帮助乘客快速寻找车辆</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Uber-指示灯：帮助乘客快速寻找车辆&quot;&gt;&lt;a href=&quot;#Uber-指示灯：帮助乘客快速寻找车辆&quot; class=&quot;headerlink&quot; title=&quot;Uber 指示灯：帮助乘客快速寻找车辆&quot;&gt;&lt;/a&gt;Uber 指示灯：帮助乘客快速寻找车辆&lt;/h1&gt;&lt;p&gt;&lt;a
      
    
    </summary>
    
      <category term="翻译" scheme="https://hongruqi.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
  <entry>
    <title>新 Uber 司机端是如何克服网络延迟问题</title>
    <link href="https://hongruqi.github.io/2019/02/19/%E6%96%B0%20Uber%20%E5%8F%B8%E6%9C%BA%E7%AB%AF%E6%98%AF%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98/"/>
    <id>https://hongruqi.github.io/2019/02/19/新 Uber 司机端是如何克服网络延迟问题/</id>
    <published>2019-02-18T16:00:00.000Z</published>
    <updated>2019-02-23T06:45:24.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="新-Uber-司机端是如何克服网络延迟问题"><a href="#新-Uber-司机端是如何克服网络延迟问题" class="headerlink" title="新 Uber 司机端是如何克服网络延迟问题"></a>新 Uber 司机端是如何克服网络延迟问题</h1><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/11/Carbon_Optimistic_Mode_feature_image.jpg" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/11/Carbon_Optimistic_Mode_feature_image-696x392.jpg" alt="Carbon: Optimistic Mode article feature image" title="Carbon: Optimistic Mode article feature image"></a></p><p><strong>本文是 Uber 的客户端工程师团队讲述了如何开发最新版本司机端系列文章中的第三篇，该系列代号 <a href="https://eng.uber.com/tag/carbon/" target="_blank" rel="noopener">Carbon</a> ，是我们共享出行业务的核心。包括其它功能在内，Uber 司机端使得超过 300 万名司机可以查看费用、里程以及收益情况。2017 年我们结合司机的反馈开始对司机端进行重新设计，并在 2018 年 9 月份启动了该项目。</strong></p><p>城市建筑和无线数据技术的竞争意味着在城市中存在一些手机没有信号的黑色区域。这种黑色区域景区更为常见，导致网络质量和阻塞程度频繁的变化。这些问题尤其影响着那些接送乘客的司机们。</p><p>可以举一个合适的例子来说明这种问题。假设一个司机到达了非常拥挤的班加罗尔机场终点。乘客想支付现金，司机需要在应用里面操作完成订单来查看最终的金额。把车停在路边，司机端却无法联网。乘客匆忙赶飞机，不能联网就意味着司机就不能结束行程并查看最终的金额。司机可能会继续开下去，增加了额外的时间，也可能增加了行程花费，给司机和乘客都带来了不便。</p><p>为了处理这种网络覆盖漏洞和预防这类事件的发生，我们提出了 —— 乐观模式。新版本的司机端可以离线操作，这样司机就可以在没有网络的情况下用最后一次服务端的预估数据来结束行程。乐观模式下司机端可以任何网络下正常工作，极大的提高了司机和乘客的体验。</p><h2 id="乐观模式组件"><a href="#乐观模式组件" class="headerlink" title="乐观模式组件"></a>乐观模式组件</h2><p>我们之前的司机端版本中支持一些离线能力来收集失败的请求，一旦网络恢复就会上传到服务器进行整理。虽然这种功能有助于预防一些显示错误，但是不能智能的更新应用状态，不能将多个功能堆积在一起，也不能夸会话持久化状态。我们为新版本的司机端开发了下面这个组件来处理这些问题。</p><h3 id="乐观请求"><a href="#乐观请求" class="headerlink" title="乐观请求"></a>乐观请求</h3><p>司机端的任何组件都可以通过提交一个乐观请求来开始流转。一个乐观请求能够序列化储存到磁盘，对于一个普通的网络请求来说占用的内存非常小，并且每一个乐观请求都对应一个乐观转换。</p><h3 id="乐观转换"><a href="#乐观转换" class="headerlink" title="乐观转换"></a>乐观转换</h3><p>乐观模式的核心是转换，换句话说，操作转换一个对象从当前状态到<strong>乐观状态</strong>，也就是，从服务返回的预期结果。转换还能够堆积，一个对象可以经过多次转换。举一个例子来理解下转换：想象一个类<code>Counter</code>有一个属性<code>count</code>。我们可以实现一个转换来增加<code>count</code>属性的值。</p><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/11/Carbon_Optimistic_Mode_Figure-01.gif" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/11/Carbon_Optimistic_Mode_Figure-01.gif" alt="Carbon: Optimistic Mode article figure 1"></a></p><p>图一：在这个简单的例子中，<code>Counter</code>对象每经过一次增加转换，<code>count</code>属性值就会增加一。</p><p>根据业务需求转换既可以是简单的也可以是复杂的。每一个乐观请求都关联一个转换，转换会根据乐观请求返回一个最终的<em>乐观状态</em>。当数据从服务端返回时用户是无感知的，这种方式提供了一种平滑的过渡方案。</p><p>当客户端提交一个乐观请求时，关联在请求上的转换就会立马生效，应用进入乐观状态，从而完成请求。乐观状态会一直被保持直到收到服务端的真实状态，然后同步应用和服务端。</p><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/11/Carbon_Optimistic_Mode_Figure-02a.png" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/11/Carbon_Optimistic_Mode_Figure-02a.png" alt="Carbon: Optimistic Mode article figure 2a"></a></p><p>图 2-1: 普通的计数请求失败</p><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/11/Carbon_Optimistic_Mode_Figure-02b.gif" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/11/Carbon_Optimistic_Mode_Figure-02b.gif" alt="Carbon: Optimistic Mode article figure 2b"></a></p><p>图 2-2: 在无网络的情况下乐观模式使用转换及时更新数据状态，将来有网络的情况下和服务端进行同步。</p><h3 id="乐观流"><a href="#乐观流" class="headerlink" title="乐观流"></a>乐观流</h3><p>我们整个应用都在使用 <a href="https://github.com/ReactiveX/RxJava/wiki/Reactive-Streams" target="_blank" rel="noopener">RX streams</a> 传递数据。应用的每个功能都会随着已发布数据流的状态改变作出响应。这种机制使我们能够使用相同的流轻松地将乐观变换应用于对象的最新状态。为了获得乐观状态，我们结合了数据最后的状态和可用的转换。在将数据发布回流并由功能使用之前，数据已经应用了每个转换。随后业务只需简单的根据数据的乐观状态作出响应。</p><h3 id="依赖请求"><a href="#依赖请求" class="headerlink" title="依赖请求"></a>依赖请求</h3><p>同时也存在一些请求依赖于乐观请求的完成。例如，甚至在后端不知道行程已经开始的情况下发送一个结束行程的请求是不合理的。当我们在等待乐观请求完成的时候，这样的依赖请求将会被放入队列一段时间。如果周期过长，我们会结束这个请求，通知用户网络错误。</p><h2 id="设计挑战"><a href="#设计挑战" class="headerlink" title="设计挑战"></a>设计挑战</h2><p>我们在这个设计中遇到了一些挑战。我们想要支持多个堆叠的乐观请求，允许在没有网络的情况下完成多个步骤。由于和服务器不同步，我们还需要处理错误地进入乐观状态并且必须回滚到先前状态的情况。确保我们可靠地向司机展示最准确的状态需要进行多次迭代，并持续优化。</p><h3 id="兜底转换"><a href="#兜底转换" class="headerlink" title="兜底转换"></a>兜底转换</h3><p>乐观模式开启的情况下，应用程序可能会在乐观请求完成之前收到其他的网络数据。</p><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/11/Carbon_Optimistic_Mode_Figure-03.png" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2018/11/Carbon_Optimistic_Mode_Figure-03.png" alt="Carbon: Optimistic Mode article figure 3"></a></p><p>图 3: 在这个场景中，我们在收到服务器最新的状态之后又进行了乐观转换。</p><p>我们继续拿上面用到的计数器的例子来说。应用程序使用增加变换把最终的值变成了 2。然而，这个值还没有和服务端同步。在这期间，收到的其他的网络响应可能还是旧的值 1。乐观模式使用转换更新了这个旧值并且维护这个乐观状态。这就确保了应用程序不会在两种状态之前来回切换，避免给用户产生混乱的体验。</p><h3 id="应用重启时如何存活"><a href="#应用重启时如何存活" class="headerlink" title="应用重启时如何存活"></a>应用重启时如何存活</h3><p>所有的乐观请求和最新的乐观状态一起被保存在磁盘里，所以它们能够在应用重启的时候得以保留。考虑这么一种情况，一些请求正在排队和服务器同步，但是用户却杀死了应用。在重新启动的时候，乐观请求和状态会从磁盘中加载。这允许用户在重新启动应用时处于相同的状态。乐观请求排队和服务器同步。</p><h3 id="显示错误"><a href="#显示错误" class="headerlink" title="显示错误"></a>显示错误</h3><p>我们遇到的这个新功能的一个特殊问题是它如何显示错误。乐观模式的请求只应该由于后端中断而失败，并且结果应该是可预测的便于模拟。然而，实践中会出现错误。由于我们使用乐观的流程服务用户，所以一个小错就可能带来很不好的体验。首先，应用程序的状态回滚到之前的乐观状态，不是用户所期望的状态，下个动作可能不太明显。其次，即使之前的状态可能已经无效了，我们也需要用它来接收错误原因来展示。为了处理这些问题，我们在司机端里加入了一个全局处理错误信息的框架，它可以调用内部弹窗框架。</p><p>请求出错的情况总是很少见的。对于经常发生的错误，比如行程太短，我们在手机端上实现了检查，以便更好的处理。</p><h3 id="节省时间"><a href="#节省时间" class="headerlink" title="节省时间"></a>节省时间</h3><p>对司机来说，我们在开始和结束行程上利用乐观模式节省了大量的时间。我们经常可以看到在真实的网络请求完成之前行程已经开始几分钟的情况。截至 2018 年 11 月，我们注意到平均每个乐观操作节省大约 13.5 秒的时间。即使在新司机端的早期阶段，我们每天累计节省司机的时间也超过了一年。</p><h2 id="乐观模式的发展"><a href="#乐观模式的发展" class="headerlink" title="乐观模式的发展"></a>乐观模式的发展</h2><p>在无网络的情况下能够正常运行的能力在 Ubers 的其他应用程序上面使用的也非常好。设计之初是为了加速开始和结束行程的速度，它还被整合到 Uber Eats 中功能中，当使用现金结算时，可以更快的结束。它还能用到类似于这种可以快速响应后续同步到服务端的业务中，比如对乘客或司机的评价，标记消息已读，和收集交付的指纹。</p><h4 id="Uber-司机端系列文章索引"><a href="#Uber-司机端系列文章索引" class="headerlink" title="Uber 司机端系列文章索引"></a>Uber 司机端系列文章索引</h4><ol><li><a href="http://way.xiaojukeji.com/article/13418" target="_blank" rel="noopener">为什么我们决定重构 Uber 司机端</a></li><li><a href="http://way.xiaojukeji.com/article/13454" target="_blank" rel="noopener">使用RIBs重构Uber司机端</a></li><li>新 Uber 司机端是如何克服网络延迟问题的</li><li><a href="https://eng.uber.com/driver-app-cash-payments/" target="_blank" rel="noopener">Scaling Cash Payments in Uber Eats</a></li><li><a href="https://eng.uber.com/carbon-dual-binary-mobile-app/" target="_blank" rel="noopener">How to Ship an App Rewrite Without Risking Your Entire Business</a></li><li><a href="https://eng.uber.com/building-a-scalable-and-reliable-map-interface-for-drivers/" target="_blank" rel="noopener">Building a Scalable and Reliable Map Interface for Drivers</a></li><li><a href="https://eng.uber.com/uber-beacon-bluetooth-mobile-app/" target="_blank" rel="noopener">Engineering Uber Beacon: Matching Riders and Drivers in 24-bit RGB Colors</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;新-Uber-司机端是如何克服网络延迟问题&quot;&gt;&lt;a href=&quot;#新-Uber-司机端是如何克服网络延迟问题&quot; class=&quot;headerlink&quot; title=&quot;新 Uber 司机端是如何克服网络延迟问题&quot;&gt;&lt;/a&gt;新 Uber 司机端是如何克服网络延迟问题&lt;/
      
    
    </summary>
    
      <category term="翻译" scheme="https://hongruqi.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
</feed>
