<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false,"dimmer":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="JavaScript 算法 介绍传统的 面试过程 通常以最基本的如何编写 手机屏幕页面 问题为开始，然后通过全天的 现场工作 来检验 编码能力 和 文化契合 度。 几乎无一例外，决定性的因素还是 编码能力。 毕竟，工程师是靠一天结束之时产出可使用的软件来获得报酬的。一般来说，我们会使用 _白板_ 来测试这种编码能力。比获得正确答案更重要的是清晰明了的思考过程。编码和生活一样，正确的答案不总是显而易">
<meta property="og:type" content="article">
<meta property="og:title" content="猛犸象翻译组">
<meta property="og:url" content="https://hongruqi.github.io/2019/03/25/JavaScript 算法/index.html">
<meta property="og:site_name" content="猛犸象翻译组">
<meta property="og:description" content="JavaScript 算法 介绍传统的 面试过程 通常以最基本的如何编写 手机屏幕页面 问题为开始，然后通过全天的 现场工作 来检验 编码能力 和 文化契合 度。 几乎无一例外，决定性的因素还是 编码能力。 毕竟，工程师是靠一天结束之时产出可使用的软件来获得报酬的。一般来说，我们会使用 _白板_ 来测试这种编码能力。比获得正确答案更重要的是清晰明了的思考过程。编码和生活一样，正确的答案不总是显而易">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://cdn-images-1.medium.com/max/800/1*CMYOFHdAKR7pNWE2F-zIHA.jpeg">
<meta property="og:image" content="https://cdn-images-1.medium.com/max/800/1*-j3Q4EiyBgc1tDTR5uKTnQ.png">
<meta property="og:image" content="https://cdn-images-1.medium.com/max/800/1*7ErHjLrOGhdkmMm_nQfo-g.png">
<meta property="og:updated_time" content="2019-03-25T12:50:05.180Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="猛犸象翻译组">
<meta name="twitter:description" content="JavaScript 算法 介绍传统的 面试过程 通常以最基本的如何编写 手机屏幕页面 问题为开始，然后通过全天的 现场工作 来检验 编码能力 和 文化契合 度。 几乎无一例外，决定性的因素还是 编码能力。 毕竟，工程师是靠一天结束之时产出可使用的软件来获得报酬的。一般来说，我们会使用 _白板_ 来测试这种编码能力。比获得正确答案更重要的是清晰明了的思考过程。编码和生活一样，正确的答案不总是显而易">
<meta name="twitter:image" content="https://cdn-images-1.medium.com/max/800/1*CMYOFHdAKR7pNWE2F-zIHA.jpeg">



  <link rel="alternate" href="/atom.xml" title="猛犸象翻译组" type="application/atom+xml">




  <link rel="canonical" href="https://hongruqi.github.io/2019/03/25/JavaScript 算法/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title> | 猛犸象翻译组</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">猛犸象翻译组</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">2019，行者无疆</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hongruqi.github.io/2019/03/25/JavaScript 算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="猛犸象">
      <meta itemprop="description" content="不积跬步，无以致千里；不积小流，无以成江海。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="猛犸象翻译组">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-25 17:57:11 / 修改时间：20:50:05" itemprop="dateCreated datePublished" datetime="2019-03-25T17:57:11+08:00">2019-03-25</time>
            

            
              

              
            
          </span>

          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/03/25/JavaScript 算法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/03/25/JavaScript 算法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2019/03/25/JavaScript 算法/" class="leancloud_visitors" data-flag-title>
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="JavaScript-算法"><a href="#JavaScript-算法" class="headerlink" title="JavaScript 算法"></a>JavaScript 算法</h1><p><img src="https://cdn-images-1.medium.com/max/800/1*CMYOFHdAKR7pNWE2F-zIHA.jpeg" alt></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>传统的 <strong>面试过程</strong> 通常以最基本的如何编写 <em>手机屏幕页面</em> 问题为开始，然后通过全天的 <em>现场工作</em> 来检验 <em>编码能力</em> 和 <em>文化契合</em> 度。 几乎无一例外，决定性的因素还是 <strong>编码能力</strong>。 毕竟，工程师是靠一天结束之时产出可使用的软件来获得报酬的。一般来说，我们会使用 _白板_ 来测试这种编码能力。比获得正确答案更重要的是清晰明了的思考过程。编码和生活一样，正确的答案不总是显而易见的，但是好的论据通常是足够好的。 _有效_ 的 _推理_ 能力标志着学习，适应和发展的潜力。最好的工程师总是在成长，最好的公司总是在不断创新。</p>
<p><strong>算法挑战</strong> 是有效的锻炼能力的方法，因为总有不止一种的方法来解决它们。这为决策和演算决策提供了可能性。当解决算法问题的时候，我们应该挑战自我，从多个角度来看 <em>问题的定义</em> ，然后权衡各种方式的 _益处_  和 _缺陷_ 。通过足够的联系，我们甚至可以一瞥宇宙的真理； <em>没有“完美”的解决方案</em> 。</p>
<p>真正掌握 <strong>算法</strong> 就是去理解 <strong>数据</strong> 和 <strong>结构</strong> 之间的关系。数据结构和算法之间的关系，就如同“阴”之于“阳”， <em>玻璃杯</em> 之于 _水_ 。没有玻璃杯，水就无法被承载。没有数据结构，我们就没有可以用于逻辑的对象。没有水，玻璃杯会因为缺乏物质而变空。没有算法，对象就无法被转化或者“消费”。</p>
<p><em>关于数据结构深入分析，可以参考：</em> <a href="https://medium.com/siliconwat/data-structures-in-javascript-1b9aed0ea17c" target="_blank" rel="noopener"><em>Data Structures in JavaScript</em></a>_:_</p>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>应用于代码中，一个算法只是一个把确定的 <em>数据结构</em> 的 <strong>输入</strong> 转化为一个确定的 <em>数据结构</em> 的 <strong>输出</strong> 的 <code>function</code> 。算法 _内在_ 的 <strong>逻辑</strong> 决定了如何转换。首先，输入和输出应该被 _明确_ 定义为 <strong>单元测试</strong>。这需要完全的理解手头的问题，这是不容小觑的，因为彻底分析问题可以无需编写任何代码，就自然地解决问题。</p>
<p>一旦彻底掌握问题的领域，就可以开始对解决方案进行 <strong>头脑风暴</strong> 。 <em>需要哪些变量？需要多少循环以及哪些类型的循环？有没有巧妙的内置的方法可以提供帮助？需要考虑哪些边缘情况？</em> 复杂和重复的逻辑只会徒增阅读和理解的难度。 <em>帮助函数可以被抽象或者抽离吗？</em> 算法通常需要是可扩展的。 <em>随着输入规模的增加，函数将如何执行？</em> <em>是否应该有某种缓存机制？</em> 而性能优化（时间）通常需要牺牲内存空间（增加内存消耗）。</p>
<blockquote>
<p>为了使问题更具体，让我们来绘制一个 <strong>图表</strong> ！</p>
</blockquote>
<p>当解决方案中的高级结构开始出现时，我们就可以开始写 <strong>伪代码</strong> 了。为了给面试官留下真正的印象，<br>请 _优先_ 考虑代码的重构和 <strong>复用</strong> 。有时，行为类似的函数可以合并成一个可以接受额外参数的更通用的函数。其他时候，去参数化会更好。保持函数的 <strong>纯净</strong> 以便于测试和维护也是很有先见之明的。换言之，设计算法时，将 <strong>架构</strong> 和 <strong>设计模式</strong> 纳入到你的考虑范围内。</p>
<blockquote>
<p>如果有任何不清楚的地方，请 _提问_ 以便说明！</p>
</blockquote>
<h4 id="Big-O（算法的复杂度）"><a href="#Big-O（算法的复杂度）" class="headerlink" title="Big O（算法的复杂度）"></a>Big O（算法的复杂度）</h4><p>为了估算算法运行时的复杂度，在计算算法所需的 <em>操作次数</em> 之前，我们通常把 <em>输入大小</em> 外推至无穷来估算算法的可扩展性。在这种最坏情况的运行时上限情况下，我们可以忽略系数以及附加项，只保留主导函数的因子。因此，只需要几种类型就可以描述几乎所有的可扩展算法。</p>
<p>最优最理想的算法，是在时间和空间维度以 _常数_ 速率变化。这就是说它完全不关心输入大小的变化。次优的算法是对时间或空间以 _对数_ 速率变化，再次分别是 _线性_ ， <em>线性对数</em> ， _二次_ 和 _指数_ 型。最糟糕的是对时间或空间以 _阶乘_ 速率变化。在 <strong>Big-O</strong> 表示法中：</p>
<ol>
<li><strong>常数</strong>: O(1)</li>
<li><strong>对数</strong>: O(log n)</li>
<li><strong>线性</strong>: O(n)</li>
<li><strong>线性对数</strong>: O(n log n)</li>
<li><strong>二次</strong>: O(n²)</li>
<li><strong>指数</strong>: O(2^n)</li>
<li><strong>阶乘</strong>: O(n!)</li>
</ol>
<p><img src="https://cdn-images-1.medium.com/max/800/1*-j3Q4EiyBgc1tDTR5uKTnQ.png" alt></p>
<p>图表: <a href="http://bigocheatsheet.com/" target="_blank" rel="noopener">http://bigocheatsheet.com</a></p>
<p>当我们考虑算法的时间和空间复杂性之间的权衡时，Big-O <em>渐近分析</em> 是不可或缺的工具。然而，Big O 忽略了在实际实践中可能有影响的常量因素。此外，优化算法的时间和空间复杂性可能会增加现实的开发时间或对代码可读性产生负面影响。在设计算法的结构和逻辑时，对真正可忽略不计的东西的直觉同样重要。</p>
<h4 id="Arrays（数组）"><a href="#Arrays（数组）" class="headerlink" title="Arrays（数组）"></a>Arrays（数组）</h4><p>最干净的算法通常会利用语言中固有的 _标准_ <strong>对象</strong>。可以说计算机科学中最重要的是<code>Arrays</code>。在JavaScript中，没有其他对象比数组拥有更多的实用工具方法。值得记住的数组方法是： <code>sort</code>， <code>reverse</code>， <code>slice</code>， 以及 <code>splice</code>。数组从 <em>第0个索引</em> 开始插入数组元素。这意味着最后一个数组元素的位置是 <code>array.length — 1</code>。数组是 _索引_ (推入) 的最佳选择，但对于 _插入_, _删除_ (不弹出), 和 _搜索_ 等动作非常糟糕。在 JavaScript 中, 数组可以 _动态_ 增长。</p>
<p>对应的 <strong>Big O</strong> :</p>
<ul>
<li><strong>索引</strong>: O(1)</li>
<li><strong>插入</strong>: O(n)</li>
<li><strong>删除</strong>: O(n)</li>
<li><strong>暴力搜索</strong>: O(n)</li>
<li><strong>优化搜索</strong>: O(log n)</li>
</ul>
<p>这些 <code>Array</code> 方法在代码中的示例：</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="xPGmVX" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Arrays in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/xPGmVX/" target="_blank" rel="noopener"><br>  Arrays in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<p>完整的阅读 MDN 有关 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noopener"><strong><em>Arrays</em></strong></a> 的文档也是值得的。</p>
<p>类似数组的还有 <code>Sets</code> 和 <code>Maps</code>. 在 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" target="_blank" rel="noopener">set</a> 中，元素一定是 _唯一_ 的。在 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank" rel="noopener">map</a> 中，元素由字典式关系的 _键_ 和 _值_ 组成。当然，<code>Objects</code> (and their literals) 也可以储存键值对，但键必须是 <code>strings</code> 类型。</p>
<blockquote>
<p><strong>Object</strong> Object构造函数创建一个对象包装器<br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noopener">developer.mozilla.org</a></p>
</blockquote>
<h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>与 <code>Arrays</code> 密切相关的是使用循环 <strong>遍历</strong> 它们。在 JavaScript 中，我们可以用 _五种_ 不同的 <em>控制结构</em> 来迭代。可定制化程度最高的是 <code>for</code> 循环，我们几乎可以用它以任何顺序来遍历数组 _索引_ 。如果无法确定 <em>迭代次数</em> ，我们可以使用 <code>while</code> 和 <code>do while</code> 循环，直到遇到一个满足确定条件的情况。对于任何对象，我们可以使用 <code>for in</code> 和 <code>for of</code> 循环来分别迭代它的“键”和“值”。要同时获取“键”和“值”，我们可以使用它的 <code>entries()</code> 方法。我们可以通过 <code>break</code>语句随时 <em>中断循环</em>  <code>break</code>, 或者使用 <code>continue</code> 语句 _跳到_ 。在大多数情况下，通过 <code>generator</code> 函数来控制迭代是最好的选择。</p>
<p>原生的遍历所有数组项的方法是： <code>indexOf</code>， <code>lastIndexOf</code>， <code>includes</code>， <code>fill</code> 和 <code>join</code>。 另外，我们可以为以下方法提供 <code>回调函数</code> ： <code>findIndex</code>， <code>find</code>， <code>filter</code>， <code>forEach</code>， <code>map</code>， <code>some</code>， <code>every</code> 和 <code>reduce</code>。</p>
<p>这些 <code>Array</code> 方法在代码中的示例：</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="JOdwKM" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Objects in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/JOdwKM/" target="_blank" rel="noopener"><br>  Objects in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>在一篇开创性的论文 <a href="https://en.wikipedia.org/wiki/Church%E2%80%93Turing_thesis" target="_blank" rel="noopener">Church-Turing Thesis</a> 中，证明了任何迭代函数都可以用递归函数重写，反之亦然。有时，递归方法更简洁，更清晰，更优雅。就用这个 <code>factorial</code> 阶乘迭代函数来举例：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const **<span class="built_in">factorial</span>** = number =&gt; &#123;  </span><br><span class="line">  <span class="built_in">let</span> <span class="built_in">product</span> = <span class="number">1</span>;  </span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">let</span> i = <span class="number">2</span>; i &lt;= number; i++) &#123;  </span><br><span class="line">    <span class="built_in">product</span> *= i;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="built_in">return</span> <span class="built_in">product</span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用 <code>recursive</code> 递归函数来写，只需要 _一行_ 代码！</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> **factorial** = <span class="function"><span class="params">number</span> =&gt;</span> &#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">number</span> &lt; <span class="number">2</span> ? <span class="number">1</span> : <span class="built_in">number</span> * factorial(<span class="built_in">number</span> - <span class="number">1</span>);  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所有递归函数都有一个 <em>通用模式</em> 。它们总是由一个调用自身的 <em>递归部分</em> 和一个不调用自身的 <em>基本情形</em> 组成。当一个函数调用自己的时候，它就会将一个新的 <code>执行上下文</code> 推送到 <code>执行堆栈</code> 里。这种情况会一直持续进行下去，直到遇到 <em>基本情形</em> ，然后 _堆栈_ 逐个弹出展开成 <em>各个上下文</em>。因此，草率的依赖递归会导致可怕的运行时 <code>堆栈溢出</code> 错误。</p>
<p><code>factorial</code> 阶乘函数的代码示例:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="vWXNPN" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Factorial in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/vWXNPN/" target="_blank" rel="noopener"><br>  Factorial in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<p>终于，我们准备好接受任何算法挑战了！😉</p>
<h3 id="热门的算法问题"><a href="#热门的算法问题" class="headerlink" title="热门的算法问题"></a>热门的算法问题</h3><p>在本节中，我们将按照难度顺序浏览22个 <em>经常被问到的</em> 算法问题。我们将讨论不同的方法和它们的利弊以及运行中的时间复杂性。最优雅的解决方案通常会利用特殊的 “技巧” 或者敏锐的洞察力。记住这一点，让我们开始吧！</p>
<h4 id="1-反转字符串"><a href="#1-反转字符串" class="headerlink" title="1. 反转字符串"></a>1. 反转字符串</h4><p>把一个给定的 <code>一串字符</code> 当作 _输入_ ，编写一个函数，将传入字符串 _反转_ 字符顺序后返回。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"String Reversal"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should reverse string**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">reverse</span>(<span class="string">"Hello World!"</span>), <span class="string">"!dlroW olleH"</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>:</p>
<p>如果我们知道“技巧”，那么解决方案就不重要了。技巧就是意识到我们可以使用 _数组_ 的内置方法 <code>reverse</code> 。首先，我们对 <em>字符串</em> 使用 <code>split</code> 方法生成一个 <em>字符数组</em> ，然后我们可以用 <code>reverse</code> 方法，最后用 <code>join</code> 方法将字符数组重新组合回一个 <em>字符串</em>。这个解决方案可以用一行代码来完成！虽然不那么优雅，但也可以借助最新的语法和帮助函数来解决问题。使用新的 <code>for of</code> 循环迭代字符串中的每一个字符，可以展示出我们对最新语法的熟悉情况。或者，我们可以用数组的 <code>reduce</code> 方法，它使我们不再需要保留临时基元。</p>
<p>对于给定的字符串的每个字符都要被“访问”一次。虽然这中访问会多次发生，但是 _时间_ 可以被归一化为 _线性_ 时间。并且因为没有单独的内部状态需要被保存，因此 _空间_ 是 _恒定_ 的。</p>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="VryYBp" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="String Reversal in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/VryYBp/" target="_blank" rel="noopener"><br>  String Reversal in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="2-回文"><a href="#2-回文" class="headerlink" title="2. 回文"></a>2. 回文</h4><p>_回文_ 是指一个 <code>单词</code> 或 <code>短语</code> <em>正向和反向</em> 阅读都是一样的。写一个函数来验证给定输入值是否是回文。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Palindrome"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should return true**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">isPalindrome</span>(<span class="string">"Cigar? Toss it in a can. It is so tragic"</span>), true)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should return false**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">isPalindrome</span>(<span class="string">"sit ad est love"</span>), false)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>:</p>
<p>这里的关键点是意识到：我们基于在前一个问题中学到的东西来解决。除此之外，我们需要返回一个 <code>布尔</code> 值。这就像对 <em>原始字符串</em> 返回 <em>三重等式</em> 检查一样简单。我们还可以在 _数组_ 上使用新的 <code>every</code> 方法来检查 <em>第一个</em> 和 <em>最后一个</em> 字符是否按顺序 <em>以中心为对称点</em> 匹配。然而，这会使检查次数超过必要次数的两倍。与前一个问题类似，这个问题的时间和空间的运行时复杂性都 是相同的。</p>
<p>如果我们想扩展我们的功能以测试整个 _短语_ 怎么办？我们可以创造一个 <em>帮助函数</em> ，它对 <code>字符串</code> 使用 <strong>正则表达式</strong> 和 <code>replace</code> 方法来剔除非字母字符。如果不允许使用正则表达式，我们就创造一个由 <em>可接受字符</em> 组成的 <code>数组</code> 用作过滤器。</p>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="EwBeKq" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Palindrome in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/EwBeKq/" target="_blank" rel="noopener"><br>  Palindrome in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="3-整数反转"><a href="#3-整数反转" class="headerlink" title="3. 整数反转"></a>3. 整数反转</h4><p>给定一个 <code>整数</code>， _反转_ 数字的顺序。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Integer Reversal"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should reverse integer**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">reverse</span>(<span class="number">1234</span>), <span class="number">4321</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">reverse</span>(<span class="name">-1200</span>), <span class="number">-21</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>:</p>
<p>这里的技巧是先把数字通过内置的 <code>toString</code> 方法转化为一个 <code>字符串</code> 。然后，我们可以简单的复用 <em>反转字符串</em> 的算法逻辑。在数字反转之后，我们可以使用全局的 <code>parseInt</code> 函数将字符串转换回整数，并使用 <code>Math.sign</code> 来处理数字的符号。这种方法可以简化为一行代码！</p>
<p>由于我们复用了 <em>反转字符串</em> 的算法逻辑，这个算法的时间和空间的运行时复杂度也与之前相同。</p>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="RjxxZK" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Integer Reversal"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/RjxxZK/" target="_blank" rel="noopener"><br>  Integer Reversal</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="4-Fizz-Buzz"><a href="#4-Fizz-Buzz" class="headerlink" title="4. Fizz Buzz"></a>4. Fizz Buzz</h4><p>给定一个 <code>数字</code> 作为输入值, 打印出从 1 到给定数字的所有整数。 但是，当整数可以被 2 整除时，打印出“Fizz”; 当它可以被3整除时，打印出“Buzz”; 当它可以同时被2和3整除时，打印出“Fizz Buzz”。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Fizz Buzz"</span>, () =&gt; &#123;  </span><br><span class="line"> beforeEach(() =&gt; (<span class="name">output</span> = fizzBuzz(<span class="number">30</span>)))<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should output number**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">output</span>\[<span class="number">0</span>\], <span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should output Fizz**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">output</span>\[<span class="number">1</span>\], <span class="string">"Fizz"</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should output Buzz**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">output</span>\[<span class="number">2</span>\], <span class="string">"Buzz"</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should output Fizz Buzz**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">output</span>\[<span class="number">5</span>\], <span class="string">"Fizz Buzz"</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>:</p>
<p>当我们意识到 <em>模运算符</em> 可用于检查可分性(是否能被整除)时，这个经典算法的挑战就变得非常简单了。模运算符对两个数字求余，返回两数相除的余数。因此我们可以简单的遍历每个整数，检查它们对2、3整除的余数是否等于 <code>0</code>。这展现了我们的数学功底，因为我们知道当一个数可以同时被 <code>a</code> 和 <code>b</code>整除时，它也可以被它们的 <em>最小公倍数</em> 整除。</p>
<p>同样，这个算法的时间和空间的运行时复杂度也与之前相同，因为每一个整数都被访问和检查过一次但不需要保存内部状态。</p>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="PJgewe" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Fizz Buzz in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/PJgewe/" target="_blank" rel="noopener"><br>  Fizz Buzz in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="5-最常见字符"><a href="#5-最常见字符" class="headerlink" title="5. 最常见字符"></a>5. 最常见字符</h4><p>给定一个由字符组成的 <code>字符串</code>，返回字符串中 <em>出现频次最高</em> 的 <code>字符</code> 。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Max Character"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should return max character**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">max</span>(<span class="string">"Hello World!"</span>), <span class="string">"l"</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>:</p>
<p>这里的技巧是创建一个表格，用来记录遍历字符串时每个字符出现的次数。这个表格可以用 <code>对象字面量</code> 来创建，用 <code>字符</code> 作为对象字面量的 _键_ ，用字符出现的 <code>次数</code> 作为 _值_ 。然后，我们遍历表格，通过一个保存每个键值对的 _临时_ <code>变量</code> 来找到出现频次最大的字符。</p>
<p>虽然我们使用了两个独立的循环来遍历两个不同的输入值（ <em>字符串</em> 和 <em>字符映射</em> ），但时间复杂度仍然是 _线性_ 的。虽然循环是对于字符串，但最终，字符映射的大小会有一个极限，因为任何一种语言的字符都是 _有限_ 个的。出于同样的原因，虽然要保存内部状态，但不管输入字符串如何增长，空间复杂度也是 _恒定_ 的。临时基元在大尺度上看也是可以忽略不计的。</p>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="qVppxO" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Max Character"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/qVppxO/" target="_blank" rel="noopener"><br>  Max Character</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="6-Anagrams"><a href="#6-Anagrams" class="headerlink" title="6. Anagrams"></a>6. Anagrams</h4><p>Anagrams是包含 <em>相同字符</em> 的 <code>单词</code> 或 <code>短语</code> 。写一个检查此功能的 <code>函数</code>。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Anagrams"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should implement anagrams**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">anagrams</span>(<span class="string">"hello world"</span>, <span class="string">"world hello"</span>), true)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">anagrams</span>(<span class="string">"hellow world"</span>, <span class="string">"hello there"</span>), false)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">anagrams</span>(<span class="string">"hellow world"</span>, <span class="string">"hello there!"</span>), false)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>:</p>
<p>一种显而易见的方法是创建一个 <em>字符映射</em> ，该映射计算每个输入字符串的字符数。之后，我们可以比较映射来看他们是否相同。创建字符映射的逻辑可以抽离成一个 <em>帮助函数</em> 从而更方便的复用。为了更缜密，我们应该首先把字符串中所有非字符删掉，然后把剩下的字符变成小写。</p>
<p>正如我们所见，字符映射具有 _线性_ 时间复杂度和 _恒定_ 的空间复杂度。更确切地说，这种方法对于时间具有 <code>O(n + m)</code> 复杂度，因为检查了两个不同的字符串。</p>
<p>另一种更优雅的方法是我们可以简单的对输入值 <code>排序</code> ，然后检查它们是否相等！然而，它的缺点是排序通常需要 _线性_ 时间。</p>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="wPyZGo" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Anagrams"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/wPyZGo/" target="_blank" rel="noopener"><br>  Anagrams</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="7-元音"><a href="#7-元音" class="headerlink" title="7. 元音"></a>7. 元音</h4><p>给定一个 <code>字符串</code> 类型的单词或短语， _计算_ <code>元音</code> 的个数.</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Vowels"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should count vowels**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">vowels</span>(<span class="string">"hello world"</span>), <span class="number">3</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>:</p>
<p>最简单的办法是使用 <em>正则表达式</em> 取出所有的元音字母，然后计算它们的数量。如果不允许使用正则表达式，我们可以简单的遍历每一个字符，检查它是否是原因字母。不过首先要把字符串转化为 _小写_ 。</p>
<p>两种方法都是 _线性_ 时间复杂度和 _恒定_ 空间复杂度，因为每一个字符都需要被检查一次，而临时基元可以忽略不计。</p>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="gXzXEy" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Vowels"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/gXzXEy/" target="_blank" rel="noopener"><br>  Vowels</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="8-数组块"><a href="#8-数组块" class="headerlink" title="8. 数组块"></a>8. 数组块</h4><p>对于一个给定 <code>大小</code> 的 <code>数组</code> ，将数组 _元素_ 分割成一个给定大小的 _数组_ 类型的 <code>列表</code> 。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Array Chunking"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should implement array chunking**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.deepEqual(chunk(\[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>\], <span class="number">2</span>), \[\[<span class="number">1</span>, <span class="number">2</span>\], \[<span class="number">3</span>, <span class="number">4</span>\]\]);  </span><br><span class="line">  assert.deepEqual(chunk(\[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>\], <span class="number">3</span>), \[\[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>\], \[<span class="number">4</span>\]\]);  </span><br><span class="line">  assert.deepEqual(chunk(\[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>\], <span class="number">5</span>), \[\[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>\]\]);  </span><br><span class="line"> &#125;);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>:</p>
<p>一个显而易见的方法是保持一个对最后一个“块”的引用，并在遍历数组元素时检查其大小来判断是否应该向最后一个块中放元素。更优雅的解决方案是使用内置的 <code>slice</code> 方法。这样就不需要“引用”，从而使代码更清晰。这可以通过 <code>while</code> 循环或 <code>for</code> 循环来实现，该循环以给定大小的step递增。</p>
<p>这些算法都具有 _线性_ 时间复杂度，因为每个数组项都需要被访问一次。它们也都有 _线性_ 的空间复杂度，因为需要保存一个内在的 “块” 类型数组，该数组大小会随着输入值变化而变化。</p>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="BmYVMM" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Array Chunking"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/BmYVMM/" target="_blank" rel="noopener"><br>  Array Chunking</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="9-反转数组"><a href="#9-反转数组" class="headerlink" title="9. 反转数组"></a>9. 反转数组</h4><p>给定一个任意类型的 <code>数组</code> ， _反转_ 数组的顺序。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Reverse Arrays"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should reverse arrays**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.deepEqual(reverseArray(\[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>\]), \[<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>\]);  </span><br><span class="line">  assert.deepEqual(reverseArray(\[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>\]), \[<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>\]);  </span><br><span class="line"> &#125;);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>:</p>
<p>当然最简单的解决办法是使用内置的 <code>reverse</code> 方法。但这也太赖皮了！如果不允许使用这种方法，我们可以简单循环数组的一般，并 _交换_ 数组的开头和结尾的元素。这意味着我们要在内存里暂存 _一个_ 数组元素。为了避免这种对暂存的需要，我们可以对数组对称位置的元素使用 <em>结构赋值</em> 。</p>
<p>虽然只遍历了输入数组的一半，但时间复杂度仍然是 _线性_ 的，因为 Big O 近似地忽略了系数。</p>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="eezgYy" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Reverse Arrays in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/eezgYy/" target="_blank" rel="noopener"><br>  Reverse Arrays in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="10-反转单词"><a href="#10-反转单词" class="headerlink" title="10. 反转单词"></a>10. 反转单词</h4><p>给定一个 <code>词组</code>， _反转_ 词组中每个单词的字符顺序。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Reverse Words"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should reverse words**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">reverseWords</span>(<span class="string">"I love JavaScript!"</span>), <span class="string">"I evol !tpircSavaJ"</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>:</p>
<p>我们可以使用split方法创建单个单词的数组。然后对每一个单词，我们使用 <em>反转字符串</em> 的逻辑来反转它的字符。另一种方法是 _反向_ 遍历每个单词，并将结果存储在临时变量中。无论哪种方式，我们都需要暂存所有反转的单词，最后再把它们拼接起来。</p>
<p>由于每一个字符都被遍历了一遍，并且所需的临时变量大小与输入字符串成比例，所以时间和空间复杂度都是 _线性_ 的。</p>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="RjRoYd" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Reverse Words in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/RjRoYd/" target="_blank" rel="noopener"><br>  Reverse Words in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="11-首字母大写转换"><a href="#11-首字母大写转换" class="headerlink" title="11. 首字母大写转换"></a>11. 首字母大写转换</h4><p>给定一个 <code>词组</code>，对每一个单词进行 <em>首字母大写</em> 。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Capitalization"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should capitalize phrase**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">capitalize</span>(<span class="string">"hello world"</span>), <span class="string">"Hello World"</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>:</p>
<p>一种解决方法是遍历每个字符，当遍历字符的前一个字符是 _空格_ 时，就对当前字符使用 <code>toUpperCase</code> 方法使其变成大写。由于 <strong>字符串文字</strong> 在 JavaScript 中是 <em>不可变</em> 的，所以我们需要使用适当的大写转化方法重建输入字符串。这种方法要求我们始终将第一个字符大写。另一种更简洁的方法是将输入字符串 <code>split</code> 成一个 <em>由单词组成的数组</em> 。然后，遍历这个数组，将每个元素第一个字符大写，最后将单词重新连接在一起。出于相同的不可变原因，我们需要在内存里保存一个 <em>临时数组</em> 来保存被正确大写的单词。</p>
<p>两种方式都是 _线性_ 的时间复杂度，因为每个字符串都被遍历了一次。它们也都是 _线性_ 的空间复杂度，因为保存了一个临时变量，该变量与输入字符串成比例增长。</p>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="NwMvNN" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Capitalization"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/NwMvNN/" target="_blank" rel="noopener"><br>  Capitalization</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="12-恺撒密码"><a href="#12-恺撒密码" class="headerlink" title="12. 恺撒密码"></a>12. 恺撒密码</h4><p>给定一个 <code>短语</code>， 通过将每个字符 _替换_ 成字母表向前或向后移动一个给定的 <code>整数</code> 的新字符。如有必要，移位应绕回字母表的开头或结尾。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Caesar Cipher"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should shift to the right**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">caesarCipher</span>(<span class="string">"I love JavaScript!"</span>, <span class="number">100</span>), <span class="string">"E hkra FwrwOynelp!"</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">it(<span class="string">"**Should shift to the left**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">caesarCipher</span>(<span class="string">"I love JavaScript!"</span>, <span class="number">-100</span>), <span class="string">"M pszi NezeWgvmtx!"</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>:</p>
<p>首先，我们需要创建一个 <em>字母表字符</em> 组成的 <code>数组</code> ，以便计算移动字符的结果。这意味着我们要在遍历字符之前先把 <code>输入字符串</code> 转化为小写。我们很容易用常规的 <code>for</code> 循环来跟踪当前索引。我们需要构建一个包含每次迭代移位后的字符的 <code>新字符串</code> 。注意，当我们遇到非字母字符时，应该立即将它追加到我们的结果字符串的末尾，并使用 <code>continue</code> 语句跳到下一次迭代。有一个关键点事要意识到我们可以使用 <code>模运算符</code> 模拟当移位超过26时，循环计数到字母表数组的开头或结尾的行为。最后，我们需要在将结果追加到结果字符串之前检查原始字符串中的大小写。</p>
<p>由于需要访问每一个输入字符串的字符，并且需要根据输入字符串新建一个结果字符串，因此这个算法的时间和空间复杂度都是 _线性_ 的。</p>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="JOKboJ" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Caesar Cipher in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/JOKboJ/" target="_blank" rel="noopener"><br>  Caesar Cipher in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="13-Ransom-Note"><a href="#13-Ransom-Note" class="headerlink" title="13. Ransom Note"></a>13. Ransom Note</h4><p>给定一个 <code>magazine段落</code> 和一个 <code>ransom段落</code>，判断 <em>magazine段落</em> 中是否包含每一个 <em>ransom段落</em> 中的单词 。</p>
<p>const <strong>magazine</strong> =<br> “<em>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum</em>“;</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Ransom Note"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should return true**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">ransomNote</span>(<span class="string">"sit ad est sint"</span>, magazine), true)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">it(<span class="string">"**Should return false**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">ransomNote</span>(<span class="string">"sit ad est love"</span>, magazine), false)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">it(<span class="string">"**Should return true**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">ransomNote</span>(<span class="string">"sit ad est sint in in"</span>, magazine), true)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">it(<span class="string">"**Should return false**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">ransomNote</span>(<span class="string">"sit ad est sint in in in in"</span>, magazine), false)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>:</p>
<p>显而易见的做法是把magazine段落和ransom段落分拆成由单个单词组成的 _数组_ ，然后检查每个ransom单词是否存在于magazine段落中。然而，这种方法的时间复杂度是 _二次_ 的，或者说是 <code>O(n * m)</code> 的，这说明这种方法性能不好。如果我们首先创建一个magazine段落的单词表格，然后检查ansom段落中的每个词是否存在于这张表格中，我们就可以实现 _线性_ 时间复杂度。这是因为在 <em>映射对象</em> 中的查找总是可以在 _恒定_ 时间内完成。但是我们将会牺牲空间复杂度，因为需要把映射对象保存在内存里。</p>
<p>在代码中，这意味着我们需要创建每个magazine段落中单词的计数，然后检查 “hash 表格” 是否包含正确数量的ransom单词。</p>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="gGNzde" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Ransom Note in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/gGNzde/" target="_blank" rel="noopener"><br>  Ransom Note in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>


<h4 id="14-平均值，中位数和Mode-出现次数最多的数字"><a href="#14-平均值，中位数和Mode-出现次数最多的数字" class="headerlink" title="14. 平均值，中位数和Mode(出现次数最多的数字)"></a>14. 平均值，中位数和Mode(出现次数最多的数字)</h4><p>给定一个数字组成的 <code>数组</code> ，计算这些数的 <em>平均值</em> ， <em>中位数</em> 和 <em>Mode</em> 。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const **stat1** = new Stats(\[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>\])<span class="comment">;  </span></span><br><span class="line">const **stat2** = new Stats(\[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>\])<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">"Mean"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should implement mean**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">Stats</span>.round(<span class="name">stat1</span>.mean()), <span class="number">3.43</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">Stats</span>.round(<span class="name">stat2</span>.mean()), <span class="number">2.5</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">"Median"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should implement median**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">stat1</span>.median(), <span class="number">4</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">stat2</span>.median(), <span class="number">2.5</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">"Mode"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should implement mode**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.deepEqual(<span class="name">stat1</span>.mode(), \[<span class="number">4</span>, <span class="number">5</span>\])<span class="comment">;  </span></span><br><span class="line">  assert.deepEqual(<span class="name">stat2</span>.mode(), \[\])<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>:</p>
<p>从难度方面讲，找到数字集合 <em>平均值</em> 的算法是最简单的。统计学上， <code>平均值</code> 的定义是数字集合的 _和_ 除以数字集合的 _数量_ 。因此，我们可以简单的使用数组的 <code>reduce</code> 方法来对它求和，然后除以它的 <code>长度</code>。这个算法的运行时复杂度对时间是 _线性_ 的，对空间是  _恒定_ 的。因为每一个数字在遍历的过程中都需要被求和但不需要在内存里保存变量。</p>
<p>找到集合 <em>中位数</em> 的算法困难度是中等的。首先，我们需要给数组排序，但如果集合的长度是基数，我们就需要额外的逻辑来处理中间的两个数字。这种情况下，我们需要返回这两个数字的 <em>平均值</em> 。这个算法因为需要排序，所以具有 <em>线性对数</em> 时间复杂度，同时因为需要内存来保持排序的数组，所以具有 _线性_ 的空间复杂度。</p>
<p>找到 <em>mode</em> 的算法是最为复杂的。由于 <code>mode</code> 被定义为最常出现的一个或多个数字，我们需要在内存中维护一个 <em>频率表</em> 。更复杂的是，如果每个值出现的次数都相同，则没有mode。这意味着在代码中，我们需要创建一个 <em>哈希映射</em> 来计算每一个“数”出现的频率；然后遍历这个映射来找到最高频的一个或多个数字，当然也可能没有mode。因为每个数字都需要在内存中保留和计数，所以这个算法具有 _线性_ 的时间和空间复杂度。</p>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="ooLrpR" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Mean, Median, Mode in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/ooLrpR/" target="_blank" rel="noopener"><br>  Mean, Median, Mode in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="15-多重求和"><a href="#15-多重求和" class="headerlink" title="15. 多重求和"></a>15. 多重求和</h4><p>给定一组数字，返回满足“两数字之和等于给定 <code>和</code> ”的 <em>所有组合</em> 。每个数字可以被使用不止一次。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Two Sum"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should implement two sum**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.deepEqual(twoSum(\[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>\], <span class="number">4</span>), \[\[<span class="number">2</span>, <span class="number">2</span>\], \[<span class="number">3</span>, <span class="number">1</span>\]\]);  </span><br><span class="line"> &#125;);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>:</p>
<p>显而易见的解决方案是创建 <em>嵌套循环</em> ，该循环检查每一个数字与同组中其他数字。那些满足求和之后满足给定和的组合可以被推入到一个 <em>结果数组</em> 中。然而，这种嵌套会引起 _指数_ 型的时间复杂度，这对于大输入值而言非常不适用。</p>
<p>一个讨巧的办法是在我们遍历输入数组时维护一个包含每个数字的 “对应物” 的数组，同时检查每个数字的对应物是否已经存在。通过维护这样的数组，我们牺牲了空间效率来获得 _线性_ 的时间复杂度。</p>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="aVmbpj" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Two Sum in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/aVmbpj/" target="_blank" rel="noopener"><br>  Two Sum in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="16-利润最大化"><a href="#16-利润最大化" class="headerlink" title="16. 利润最大化"></a>16. 利润最大化</h4><p>给定一组按照时间顺序给出的股票价格，找到 _最低_ <code>买入价</code> 和 _最高_ <code>卖出价</code> 使得 <em>利润最大化</em> 。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Max Profit"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should return minimum buy price and maximum sell price**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.deepEqual(maxProfit([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]), [<span class="number">1</span>, <span class="number">5</span>]);  </span><br><span class="line">  assert.deepEqual(maxProfit([<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>]), [<span class="number">1</span>, <span class="number">5</span>]);  </span><br><span class="line">  assert.deepEqual(maxProfit([<span class="number">2</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>]), [<span class="number">2</span>, <span class="number">10</span>]);</span><br><span class="line">  assert.deepEqual(maxProfit([<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">11</span>]), [<span class="number">1</span>, <span class="number">11</span>]);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>:</p>
<p>同样，我们可以构建 <em>嵌套循环</em> ，该循环检查买入价和卖出价的每种可能组合，看看哪一对产生最大的利润。实际操作中我们不能在购买之前出售，所以不是每个组合都需要被检查。具体而言，对于给定的买入价格，我们可以忽略卖出价格之前的所有价格。因此，该算法的时间复杂度优于 _二次_ 型。</p>
<p>不过稍微考虑一下，我们可以对价格数组只使用一次循环来解决问题。关键点是要意识到卖价绝不应低于买入价; 如果是这样，我们应该以较低的价格购买股票。就是说在代码中，我们可以简单的维护一个 <em>临时布尔值</em> 来表示我们应该在下一次迭代时更改买入价格。这种优雅的方法只需要一个循环，因此具有 _线性_ 的时间复杂度和 _恒定_ 的空间复杂度。</p>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="dZOyer" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Max Profit in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/dZOyer/" target="_blank" rel="noopener"><br>  Max Profit in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>


<h4 id="17-Sieve-of-Eratosthenes"><a href="#17-Sieve-of-Eratosthenes" class="headerlink" title="17. Sieve of Eratosthenes"></a>17. Sieve of Eratosthenes</h4><p>对于给定的 <code>数字</code> ，找到从零到该数字之间的所有 _素数_ 。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Sieve of Eratosthenes"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should return all prime numbers**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.deepEqual(<span class="name">primes</span>(<span class="number">10</span>), \[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>\])<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>:</p>
<p>乍一看，我们可能想要遍历每个数字，只需使用模数运算符来检查所有可能的可分性。然而，很容易想到这种方法非常低效，时间复杂度比二次型还差。值得庆幸的是，地理学的发明者 <em>Eratosthenes of Cyrene</em> 还发现了一种有效的识别素数的方法。</p>
<p>在代码中，第一步是创建一个与给定数字一样大的数组，并将其每个元素初始化为 <code>true</code> 。换句话说，数组的 _索引_ 代表了所有可能的素数，并且每个数都被假定为 <em>true</em> 。然后我们建立一个 <code>for</code> 循环来遍历从 2 到给定数字的 <em>平方根</em> 之间的数，使用数组的 <em>键插值</em> 来把每个被遍历数的小于给定数的倍数对应的元素值设为 <em>false</em> 。根据定义，任何整数的乘积都不能是素数，这里忽略0和1，因为它们不会影响可分性。最后我们可以简单的筛掉所有 _假值_ ，以得出所有素数。</p>
<p>通过牺牲空间效率来维护一个内部的 “hash表”，这个Eratosthenes的 _筛子_ 在时间复杂度上会优于 _二次_ 型，或者说是 <code>O(n * log (log n))</code>。</p>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="NwbWqP" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Sieve of Eratosthenes in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/NwbWqP/" target="_blank" rel="noopener"><br>  Sieve of Eratosthenes in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="18-斐波那契通项公式"><a href="#18-斐波那契通项公式" class="headerlink" title="18. 斐波那契通项公式"></a>18. 斐波那契通项公式</h4><p>实现一个返回给定 <code>索引</code> 处的 <em>斐波纳契数</em> 的 <code>函数</code>。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Fibonacci"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should implement fibonacci**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">fibonacci</span>(<span class="number">1</span>), <span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">fibonacci</span>(<span class="number">2</span>), <span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">fibonacci</span>(<span class="number">3</span>), <span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">fibonacci</span>(<span class="number">6</span>), <span class="number">8</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">fibonacci</span>(<span class="number">10</span>), <span class="number">55</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>:</p>
<p>由于斐波纳契数是前两者的总和，最简单的方法就是使用 _递归_ 。斐波纳契数列假定前两项分别是1和1; 因此我们可以基于这个事实来创建我们的 <em>基本情形</em> 。对于索引大于2的情况，我们可以调用自身函数的前两项。虽然看着很优雅，这个递归方法的效率却非常糟糕，它具有 _指数_ 型的时间复杂度和 _线性_ 的空间复杂度。因为每个函数调用都需要调用堆栈，所以内存使用以指数级增长，如此一来它会很快就会崩溃。</p>
<p>迭代的方法虽然不那么优雅，但是时间复杂度却更优。通过循环，建立一个完整的斐波纳契数列前N项目(N为给定索引值)，这可以达到 _线性_ 的时间和空间复杂度。</p>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="JObPvJ" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Fibonacci in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/JObPvJ/" target="_blank" rel="noopener"><br>  Fibonacci in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="19-Memoized-Fibonacci"><a href="#19-Memoized-Fibonacci" class="headerlink" title="19. Memoized Fibonacci"></a>19. Memoized Fibonacci</h4><p>给斐波纳契数列实现一个 _高效_ 的递归函数。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Memoized Fibonacci"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should implement memoized fibonacci**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">fibonacci</span>(<span class="number">6</span>), <span class="number">8</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">fibonacci</span>(<span class="number">10</span>), <span class="number">55</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>:</p>
<p>由于斐波纳契数列对自己进行了冗余的调用，因此它可以戏剧性的从被称为 <em>记忆化</em> 的策略中获益匪浅。换句话说，如果我们在调用函数时 _缓存_ 所有的输入和输出值，则调用次数将减少到 _线性_ 时间。当然，这意味着我们牺牲了额外的内存。</p>
<p>在代码中，我们可以在函数本身内部实现 <em>记忆化</em> 技术，或者我们可以将它抽象为高阶效用函数，该函数可以装饰任何 <em>记忆化</em> 函数。</p>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="LObPvQ" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Memoized Fibonacci in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/LObPvQ/" target="_blank" rel="noopener"><br>  Memoized Fibonacci in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="20-画楼梯"><a href="#20-画楼梯" class="headerlink" title="20. 画楼梯"></a>20. 画楼梯</h4><p>对于给定长度的 <code>步幅</code> ，使用 _#_ and <em>‘ ’</em> 打印出一个 “楼梯” 。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Steps"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should print steps**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">steps</span>(<span class="number">3</span>), <span class="string">"#  \\n## \\n###\\n"</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">_steps</span>(<span class="number">3</span>), <span class="string">"#  \\n## \\n###\\n"</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>:</p>
<p>关键的见解是要意识到，当我们向下移动步幅时，<code>#</code> 的数量会不断 _增加_ ，而 ‘ ‘ 的数量会相应 _减少_ 。如果我们有 <code>n</code> 步要移动，全局的范围就是 <code>n</code> 行 <code>n</code> 列。这意味着运行时复杂度对于时间和空间都是 _二次_ 型的。</p>
<p>同样，我们发现这也可以使用递归的方式来解决。除此之外，我们需要传递 <em>额外的参数</em> 来代替必要的临时变量。</p>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="KyRvxX" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Staircase"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/KyRvxX/" target="_blank" rel="noopener"><br>  Staircase</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="21-画金字塔"><a href="#21-画金字塔" class="headerlink" title="21. 画金字塔"></a>21. 画金字塔</h4><p>对于给定数量的 <code>阶层</code> ，使用 _#_ 和 <em>‘ ‘</em> 打印出 “金字塔”。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Pyramid"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should print pyramid**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.equal(<span class="name">pyramid</span>(<span class="number">3</span>), <span class="string">"  #  \\n ### \\n#####\\n"</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">_pyramid</span>(<span class="number">3</span>), <span class="string">"  #  \\n ### \\n#####\\n"</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>:</p>
<p>这里的关键时要意识到当金字塔的高度是 <code>n</code> 时，宽是 <code>2 * n — 1</code>。然后随着我们往底部画时，只需要以中心对称不断 _增加_ _#_ 的数量，同时相应 _减少_ <em>‘ ‘</em> 的数量。由于该算法以 <code>2 * n  -  1</code> * <code>n</code> 遍历构建出一个金字塔，因此它的运行时时间复杂度和空间复杂度都是 <code>二次</code> 型的。</p>
<p>同样，我们可以发现这里的递归调用可以使用之前的方法：需要传递一个 <em>附加变量</em> 来代替必要的临时变量。</p>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="zPjPBB" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Pyramid"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/zPjPBB/" target="_blank" rel="noopener"><br>  Pyramid</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="22-螺旋方阵"><a href="#22-螺旋方阵" class="headerlink" title="22. 螺旋方阵"></a>22. 螺旋方阵</h4><p>创建一个给定 <code>大小</code> 的 _方阵_ ，使方阵中的元素按照 <em>螺旋顺序</em> 排列。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Matrix Spiral"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should implement matrix spiral**"</span>, () =\&gt; &#123;  </span><br><span class="line">  assert.deepEqual(spiral(<span class="number">3</span>), \[\[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>\], \[<span class="number">8</span>, <span class="number">9</span>, <span class="number">4</span>\], \[<span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>\]\]);  </span><br><span class="line"> &#125;);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>:</p>
<p>虽然这是一个很复杂的问题，但技巧其实只是对 <em>当前行</em> 和 <em>当前列</em> 的 _开头_ 以及 _结尾_ 的位置分别创建一个 <code>临时变量</code> 。这样，我们就可以按螺旋方向 _递增_ 遍历 <code>起始行</code> 和 <code>起始列</code> 并 _递减_ 遍历 <code>结束行</code> 和 <code>结束列</code> 直至方阵的中心。</p>
<p>因为该算法迭代地构建给定大小的 <em>正方形</em> 矩阵，它的运行时复杂度对时间和空间都是 _二次_ 型的。</p>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="mqKrZJ" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Matrix Spiral"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/mqKrZJ/" target="_blank" rel="noopener"><br>  Matrix Spiral</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h3 id="数据结构算法"><a href="#数据结构算法" class="headerlink" title="数据结构算法"></a>数据结构算法</h3><p>既然数据结构式构建算法的 “砖瓦” ，那么非常值得深入探索常见的数据结构。</p>
<p><em>再一次，想要快速的高层次的分析，请查看:</em></p>
<blockquote>
<p><strong>Data Structures in JavaScript</strong><br><em>For Frontend Software Engineers</em><br><a href="https://medium.com/siliconwat/data-structures-in-javascript-1b9aed0ea17c" target="_blank" rel="noopener">medium.com</a></p>
</blockquote>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>给定两个 <code>队列</code> 作为输入，通过将它们“编织”在一起来创建一个 _新_ 队列。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Weaving with Queues"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should weave two queues together**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const one = new Queue()<span class="comment">;  </span></span><br><span class="line">  one.enqueue(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  one.enqueue(<span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  one.enqueue(<span class="number">3</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  const two = new Queue()<span class="comment">;  </span></span><br><span class="line">  two.enqueue(<span class="string">"one"</span>)<span class="comment">;  </span></span><br><span class="line">  two.enqueue(<span class="string">"two"</span>)<span class="comment">;  </span></span><br><span class="line">  two.enqueue(<span class="string">"three"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  const result = weave(<span class="name">one</span>, two)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">result</span>.dequeue(), <span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">result</span>.dequeue(), <span class="string">"one"</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">result</span>.dequeue(), <span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">result</span>.dequeue(), <span class="string">"two"</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">result</span>.dequeue(), <span class="number">3</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">result</span>.dequeue(), <span class="string">"three"</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">result</span>.dequeue(), undefined)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>:</p>
<p><code>队列</code> 类至少需要有一个 <code>入列（enqueue）</code> 方法，一个 <code>出列（dequeue）</code> 方法，和一个 <code>peek</code> 方法。然后，我们使用 <code>while</code> 循环，该循环判断 <em>peek</em> 是否存在，如果存在，我们就让它执行 _出列_ ，然后 _入列_ 到我们的新 <code>队列</code> 中。</p>
<p>这个算法的时间和空间复杂度都是 <code>O(n + m)</code> 没因为我们需要迭代两个不同的集合，并且要存储它们。 </p>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="japeQZ" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Weaving with Queues"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/japeQZ/" target="_blank" rel="noopener"><br>  Weaving with Queues</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h4><p>使用两个 _堆栈_ 实现 <code>Queue</code> 类。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Queue from Stacks"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should implement queue using two stacks**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const queue = new Queue()<span class="comment">;  </span></span><br><span class="line">  queue.enqueue(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  queue.enqueue(<span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  queue.enqueue(<span class="number">3</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">queue</span>.peek(), <span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">queue</span>.dequeue(), <span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">queue</span>.dequeue(), <span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">queue</span>.dequeue(), <span class="number">3</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">queue</span>.dequeue(), undefined)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>:</p>
<p>我们可以从一个初始化两个堆栈的 <em>类构造函数</em> 开始。因为在 _堆栈_ 中，最 _后_ 插入的记录会最 _先_ 被取出，我们需要循环到最后一条记录执行 “出列” 或者 “peek” 来模仿 _队列_ 的行为：最 _先_ 被插入的记录会最 _先_ 被取出。我们可以通过使用第二个堆栈来 _临时_ 保存第一个堆栈中所有的元素直到结束。在 “peek” 或者 “出列” 之后，我们只要把所有内容移回第一个堆栈即可。对于 “入列” 一个记录，我们可以简单的把它push到第一个堆栈即可。</p>
<p>虽然我们使用两个堆栈并且需要循环两次，但是该算法在时间和空间复杂度上仍然是渐近 _线性_ 的。<br>Though we use two stacks and need to loop twice, this algorithm is still asymptotically <em>linear</em> in time and space.</p>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="js,result" data-user="thonly" data-slug-hash="bYjmXY" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Queue from Stacks"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/bYjmXY/" target="_blank" rel="noopener"><br>  Queue from Stacks</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>单向链表通常具有以下功能：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Linked List"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should implement insertHead**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">chain</span>.head.data, <span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should implement size**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">chain</span>.size(), <span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should implement getHead**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">chain</span>.getHead().data, <span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should implement getTail**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">chain</span>.getTail().data, <span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should implement clear**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  chain.clear()<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">chain</span>.size(), <span class="number">0</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should implement removeHead**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  chain.removeHead()<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">chain</span>.size(), <span class="number">0</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should implement removeTail**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  chain.removeTail()<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">chain</span>.size(), <span class="number">0</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should implement insertTail**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertTail(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">chain</span>.getTail().data, <span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should implement getAt**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">chain</span>.getAt(<span class="number">0</span>).data, <span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should implement removeAt**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  chain.removeAt(<span class="number">0</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">chain</span>.size(), <span class="number">0</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should implement insertAt**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertAt(<span class="number">0</span>, <span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">chain</span>.getAt(<span class="number">0</span>).data, <span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should implement forEach**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  chain.forEach((<span class="name">node</span>, index) =&gt; (<span class="name">node</span>.data = node.data + index))<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">chain</span>.getTail().data, <span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should implement iterator**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  for (<span class="name">let</span> node of chain) node.data = node.data + <span class="number">1</span><span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">chain</span>.getTail().data, <span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="qVyLWm" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Linked List"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/qVyLWm/" target="_blank" rel="noopener"><br>  Linked List</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<p><strong>挑战 #1: 中点</strong></p>
<p>在不使用计数器的情况下，返回链表的 <em>中间值</em> </p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Midpoint of Linked List"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should return midpoint of linked list**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">3</span>)<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">4</span>)<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">5</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">midpoint</span>(<span class="name">chain</span>).data, <span class="number">3</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>:</p>
<p>这里的技巧是同时进行 _两次_ 链表遍历，其中一次遍历的速度是另一次的 _两倍_。当快速的遍历到达结尾的时候，慢速的就到达了中点！</p>
<p>这个算法的时间复杂度是 _线性_ 的，空间复杂度是 _恒定_ 的。</p>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="OOoQGb" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Midpoint of Linked List"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/OOoQGb/" target="_blank" rel="noopener"><br>  Midpoint of Linked List</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<p><strong>Challenge #2: 循环</strong></p>
<p>在不保留节点引用的情况下，检查链表是否为 _循环_ 。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Circular Linked List"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should check for circular linked list**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">3</span>)<span class="comment">;  </span></span><br><span class="line">  chain.head.next.next.next = chain.head<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">circular</span>(<span class="name">chain</span>), true)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>:</p>
<p>很多的链表功能都基于链表有 _明确_ 的结束节点这个断言。因此，确保链表不是循环的这一点很重要。这里的技巧也是同时进行两次遍历，其中一次遍历的速度是另一次的两倍。如果链表是循环的，那么最终，较快的循环将与较慢的循环重合。这样我们就可以返回 <code>true</code>。否则，遍历会遇到结束点，我们就可以返回 <code>false</code>。</p>
<p>这个算法同样具有 _线性_ 时间复杂度和 _恒定_ 空间复杂度。</p>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="xPajLd" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Circular Linked List"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/xPajLd/" target="_blank" rel="noopener"><br>  Circular Linked List</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<p><strong>Challenge #3: From Tail</strong></p>
<p>在不使用计数器的情况下，返回链表距离链表末端给定 <code>步数</code> 的节点的 _值_ 。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"From Tail of Linked List"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should step from tail of linked list**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const chain = new LinkedList()<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">3</span>)<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">4</span>)<span class="comment">;  </span></span><br><span class="line">  chain.insertHead(<span class="number">5</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">fromTail</span>(<span class="name">chain</span>, <span class="number">2</span>).data, <span class="number">3</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>:</p>
<p>这里的技巧和之前类似，我们同时遍历链表两次。不过，在这个问题中，速度“快”的遍历比速度“慢”的遍历 _早_ <code>给定步数</code> 开始。然后，我们以相同的速度沿着链表向下走，直到更快的一个到达终点。这时，慢的遍历刚好到达距离结尾正确距离的位置。</p>
<p>这个算法同样具有 _线性_ 时间复杂度和 _恒定_ 空间复杂度。</p>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="GOXdQY" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="From Tail of Linked List"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/GOXdQY/" target="_blank" rel="noopener"><br>  From Tail of Linked List</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>树型结构通常具有以下功能：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Trees"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should add and remove nodes**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const root = new Node(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  root.add(<span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">root</span>.data, <span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">root</span>.children\[<span class="number">0</span>\].data, <span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  root.remove(<span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  assert.equal(<span class="name">root</span>.children.length, <span class="number">0</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should traverse by breadth**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const tree = new Tree()<span class="comment">;  </span></span><br><span class="line">  tree.root = new Node(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  tree.root.add(<span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  tree.root.add(<span class="number">3</span>)<span class="comment">;  </span></span><br><span class="line">  tree.root.children\[<span class="number">0</span>\].add(<span class="number">4</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  const numbers = \[\]<span class="comment">;  </span></span><br><span class="line">  tree.traverseBF(<span class="name">node</span> =&gt; numbers.push(<span class="name">node</span>.data))<span class="comment">;  </span></span><br><span class="line">  assert.deepEqual(<span class="name">numbers</span>, \[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>\])<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"> it(<span class="string">"**Should traverse by depth**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const tree = new Tree()<span class="comment">;  </span></span><br><span class="line">  tree.root = new Node(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  tree.root.add(<span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  tree.root.add(<span class="number">3</span>)<span class="comment">;  </span></span><br><span class="line">  tree.root.children\[<span class="number">0</span>\].add(<span class="number">4</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  const numbers = \[\]<span class="comment">;  </span></span><br><span class="line">  tree.traverseDF(<span class="name">node</span> =&gt; numbers.push(<span class="name">node</span>.data))<span class="comment">;  </span></span><br><span class="line">  assert.deepEqual(<span class="name">numbers</span>, \[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>\])<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="mqzwye" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Trees"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/mqzwye/" target="_blank" rel="noopener"><br>  Trees</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<p><strong>Challenge #1: 树的广度</strong></p>
<p>对于给定的 <code>树</code> ，返回每个级别的 _广度_ 。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Width of Tree Levels"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should return width of each tree level**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const root = new Node(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  root.add(<span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  root.add(<span class="number">3</span>)<span class="comment">;  </span></span><br><span class="line">  root.children\[<span class="number">1</span>\].add(<span class="number">4</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  assert.deepEqual(<span class="name">treeWidths</span>(<span class="name">root</span>), \[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>\])<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>:</p>
<p>一个树可以通过 <code>堆栈</code> 对其所有的 _切片_ 进行 <em>深度优先</em> 的遍历，也可以通过 <code>队列</code> 的帮助对其所有的 _层级_ 进行 <em>广度优先</em> 的遍历。由于我们是想要计算每个级别的多有节点的个数，我们需要以 <em>深度优先</em> 的方式，借助 <code>队列</code> 对其进行 <em>广度优先</em> 的遍历。这里的技巧是往队列中插入一个特殊的 <code>标记</code> 来使我们知道当前的级别被遍历完成，所以我们就可以 _重置_ <code>计数器</code> 给下一个级别使用。</p>
<p>这种方法具有 _线性_ 的时间和空间复杂度。尽管我们的 <code>计数器</code> 是一个数组，但是它的大小永远不会比线性更大。</p>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="LOgLgp" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Width of Tree Levels"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/LOgLgp/" target="_blank" rel="noopener"><br>  Width of Tree Levels</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<p><strong>Challenge #2: 树的高度</strong></p>
<p>对于给定的 <code>树</code> ，返回它的 _高度_ （树的最大层级）。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Height of Tree"</span>, () =&gt; &#123;  </span><br><span class="line"> it(<span class="string">"**Should return max number of levels**"</span>, () =\&gt; &#123;  </span><br><span class="line">  const root = new Node(<span class="number">1</span>)<span class="comment">;  </span></span><br><span class="line">  root.add(<span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line">  root.add(<span class="number">3</span>)<span class="comment">;  </span></span><br><span class="line">  root.children\[<span class="number">1</span>\].add(<span class="number">4</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  assert.deepEqual(<span class="name">treeHeight</span>(<span class="name">root</span>), <span class="number">2</span>)<span class="comment">;  </span></span><br><span class="line"> &#125;)<span class="comment">;  </span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>:</p>
<p>我们可以直接复用第一个挑战问题的逻辑。但是，在这个问题中，我们要在遇到 <code>“reset”</code>的时候增加我们的 <code>计数器</code> 。这两个逻辑几乎是相同的，所以这个算法也具有 _线性_ 的时间和空间复杂度。这里，我们的 <code>计数器</code> 只是一个整数，因此它的大小更可以忽略不计。</p>
<p><strong>代码</strong>:</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="wpKEQe" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Height of Tree"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/wpKEQe/" target="_blank" rel="noopener"><br>  Height of Tree</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h4><p>请等待后续补充! (谢谢)</p>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>我们可以使用许多种算法对数据集合进行排序。幸运的是，面试官只要求我们了解基础知识和第一原则。例如，最佳算法可以达到 _恒定_ 空间复杂度和 _线性_ 时间复杂度。本着这种精神，我们将按照困难度由简到难效率由低到高的顺序分析最受欢迎的几个算法。</p>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>这个算法是最容易理解的，但效率是最差的。它将每一个元素和其他所有元素做 _比较_ ， _交换_ 顺序，直到较大的元素 “冒泡” 到顶部。这种算法需要 _二次_ 型的时间和 _恒定_ 的空间。</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="POGzYM" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Bubble Sort in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/POGzYM/" target="_blank" rel="noopener"><br>  Bubble Sort in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>和冒泡排序一样，每一个元素都要与其他所有元素做比较。不同的是，这里的操作不是交换，而是 “拼接” 到正确的顺序中。事实上，它将保持重复项目的原始顺序。这种“贪婪”算法依然需要 _二次_ 型的时间和 _恒定_ 的空间。</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="YEGMxq" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Insertion Sort in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/YEGMxq/" target="_blank" rel="noopener"><br>  Insertion Sort in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>当循环遍历集合时，该算法查找并“选择”具有 <em>最小值</em> 的索引，并将起始元素与索引位置的元素交换。算法也是需要 _二次_ 型的时间和 _恒定_ 的空间。</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="MOzoPq" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Selection Sort in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/MOzoPq/" target="_blank" rel="noopener"><br>  Selection Sort in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>该算法递归的选择一个元素作为 _轴_ ，迭代集合中其他元素，将所有更小的元素向左边推，将所有更大的元素向右边推，直到所有元素都被正确排序。该算法具有 _二次_ 时间复杂度和 _对数_ 空间复杂度，因此在实践中它通常是 <em>最快度</em> 的。因此，大多数编程语言内置都用该算法进行排序。</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="GOjZqB" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Quick Sort in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/GOjZqB/" target="_blank" rel="noopener"><br>  Quick Sort in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>虽然这是效率最高的算法之一，但这种算法却难以理解。它需要一个 _递归_ 部分，将一个集合分成单个单元；并且需要一个 _迭代_ 部分，它将单个单元按正确的顺序重新组合在一起。这个算法需要 <em>线性对数</em> 时间和 _线性_ 空间。</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="jaMrBB" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Merge Sort in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/jaMrBB/" target="_blank" rel="noopener"><br>  Merge Sort in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p>如果我们用某种方式知道了 <em>最大值</em> ，我们就可以用这个算法在 _线性_ 时间和空间里对集合排序！最大值让我们创建该大小的数组来 _计算_ 每个 <em>索引值</em> 出现的次数。然后，只需将所有具有 _非零_ 计数的索引位置的元素提取到结果数组中。通过对数组进行 <em>恒定时间</em> 查找，这个类似哈希的算法是最有效的算法。</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="xPPKyz" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Counting Sort in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/xPPKyz/" target="_blank" rel="noopener"><br>  Counting Sort in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="其他的排序算法"><a href="#其他的排序算法" class="headerlink" title="其他的排序算法"></a>其他的排序算法</h4><p><img src="https://cdn-images-1.medium.com/max/800/1*7ErHjLrOGhdkmMm_nQfo-g.png" alt></p>
<p>图表: <a href="http://bigocheatsheet.com/" target="_blank" rel="noopener">http://bigocheatsheet.com</a></p>
<h3 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h3><p>最糟糕的算法需要搜索集合中的每个项目，需要花费 <code>O(n)</code> 时间。如果某个集合已经被排序，那么每次迭代只需要一半的检查次数，花费 <code>O(log n)</code> 时间，这对于非常大的数据集来说是一个巨大的性能提升。</p>
<h4 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h4><p>当一个集合被排序时，我们可以 _遍历_ 或 _递归_ 地检查我们的被检索值和中间项，丢弃一半我们想要的值不在的部分。事实上，我们的目标可以在 _对数_ 时间和 _恒定_ 空间情况中被找到。</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="NwRrZv" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Binary Search in JavaScript"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/NwRrZv/" target="_blank" rel="noopener"><br>  Binary Search in JavaScript</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>另一种排序集合的方法是从中生成一个 <em>二叉搜索树</em> (BST) 。对一个 BST 的搜索和二分搜索一样高效。以类似的方式，我们可以在每次迭代中丢弃一半我们知道不包含期望值的部分。事实上，另一种对集合进行排序的方法是按 _顺序_ 对这棵树进行 深度优先 遍历！</p>
<p>BST 的创建发生在 _线性_ 时间和空间中，但是搜索它需要 _对数_ 时间和 _恒定_ 空间。</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="yPRPgj" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Binary Search Tree"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/yPRPgj/" target="_blank" rel="noopener"><br>  Binary Search Tree</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<p>要验证二叉树是否为BST，我们可以递归检查每个左子项是否总小于根（最大可能），并且每个右子项总大于 <em>每个根</em> 上的根（最小可能）。这种歌方法需要 _线性_ 时间和 _恒定_ 空间。</p>
<p></p><p class="codepen" data-height="600" data-theme-id="0" data-default-tab="result" data-user="thonly" data-slug-hash="ooaoPb" data-preview="true" style="height: 600px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;" data-pen-title="Validate a Binary Search Tree"><br>  <span>See the Pen <a href="https://codepen.io/thonly/pen/ooaoPb/" target="_blank" rel="noopener"><br>  Validate a Binary Search Tree</a> by Thon Ly (<a href="https://codepen.io/thonly" target="_blank" rel="noopener">@thonly</a>)<br>  on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</span><br></p><p></p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在现代Web开发中，<strong>函数</strong> 是Web体验的核心。<strong>数据结构</strong> 被函数接受和返回，而 <strong>算法</strong> 则决定了内部的机制。算法的数据结构的数量级由 <em>空间复杂度</em> 描述，计算次数的数量级由 <em>时间复杂度</em> 描述。在实践中，运行时复杂性表示为 <strong>Big-O</strong> 符号，可帮助工程师比较所有可能的解决方案。最有效的运行时是 _恒定_ 时间，不依赖于出入值的大小；最低效的方法需要运算 _指数_ 时间和空间。真正掌握算法和数据结构是指可以同时 _线性_ 和 _系统_ 的推理。</p>
<p>理论上说，每一个问题都具有 <strong>迭代</strong> 和 <strong>递归</strong> 的解决方案。迭代算法是从底部开始 _动态_ 的接近解决方案。递归算法是从顶部开始分解 <em>重复的子问题</em> 。通常，递归方案更直观且更易于实现，但是迭代方案更容易理解，且对内存需求更小。通过 <em>一流的函数</em> 和 <em>控制流</em> 结构，JavaScript 天然支持这两种方案。通常来说，为了达到更好的性能会牺牲一些空间效率，或者需要牺牲性能来减少内存消耗。正确的平衡两者，需要根据实际上下为和环境来决定。值得庆幸的是，大多数面书馆都更关注 <em>计算推理过程</em> 而不是结果。</p>
<p>为了给你的面试官留下深刻的印象，要尽量寻找机会利用 <strong>架构设计</strong> 和 <strong>设计模式</strong> 来提升 <em>可复用性</em> 和 <em>可维护性</em> 。如果你正在寻找一个资深职位，对基础知识和第一原则的掌握与系统级设计的经验同样重要。不过，最好的公司也会评估 <em>文化契合</em> 度。因为没有人是完美的，所以合适的团队是必不可少的。更重要的是，这世上的一些事是不可能凭一己之力达到的。大家共同创造的东西往往是最令人满意和最有意义的。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/22/使用 RIBs 重构 Uber 司机端/" rel="next" title="使用 RIBs 重构 Uber 司机端">
                <i class="fa fa-chevron-left"></i> 使用 RIBs 重构 Uber 司机端
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">猛犸象</p>
              <p class="site-description motion-element" itemprop="description">不积跬步，无以致千里；不积小流，无以成江海。</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JavaScript-算法"><span class="nav-number">1.</span> <span class="nav-text">JavaScript 算法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#介绍"><span class="nav-number">2.</span> <span class="nav-text">介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#引言"><span class="nav-number">2.0.1.</span> <span class="nav-text">引言</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Big-O（算法的复杂度）"><span class="nav-number">2.0.1.1.</span> <span class="nav-text">Big O（算法的复杂度）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Arrays（数组）"><span class="nav-number">2.0.1.2.</span> <span class="nav-text">Arrays（数组）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#迭代"><span class="nav-number">2.0.1.3.</span> <span class="nav-text">迭代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#递归"><span class="nav-number">2.0.1.4.</span> <span class="nav-text">递归</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#热门的算法问题"><span class="nav-number">2.0.2.</span> <span class="nav-text">热门的算法问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-反转字符串"><span class="nav-number">2.0.2.1.</span> <span class="nav-text">1. 反转字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-回文"><span class="nav-number">2.0.2.2.</span> <span class="nav-text">2. 回文</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-整数反转"><span class="nav-number">2.0.2.3.</span> <span class="nav-text">3. 整数反转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Fizz-Buzz"><span class="nav-number">2.0.2.4.</span> <span class="nav-text">4. Fizz Buzz</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-最常见字符"><span class="nav-number">2.0.2.5.</span> <span class="nav-text">5. 最常见字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-Anagrams"><span class="nav-number">2.0.2.6.</span> <span class="nav-text">6. Anagrams</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-元音"><span class="nav-number">2.0.2.7.</span> <span class="nav-text">7. 元音</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-数组块"><span class="nav-number">2.0.2.8.</span> <span class="nav-text">8. 数组块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-反转数组"><span class="nav-number">2.0.2.9.</span> <span class="nav-text">9. 反转数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-反转单词"><span class="nav-number">2.0.2.10.</span> <span class="nav-text">10. 反转单词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-首字母大写转换"><span class="nav-number">2.0.2.11.</span> <span class="nav-text">11. 首字母大写转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-恺撒密码"><span class="nav-number">2.0.2.12.</span> <span class="nav-text">12. 恺撒密码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-Ransom-Note"><span class="nav-number">2.0.2.13.</span> <span class="nav-text">13. Ransom Note</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-平均值，中位数和Mode-出现次数最多的数字"><span class="nav-number">2.0.2.14.</span> <span class="nav-text">14. 平均值，中位数和Mode(出现次数最多的数字)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-多重求和"><span class="nav-number">2.0.2.15.</span> <span class="nav-text">15. 多重求和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-利润最大化"><span class="nav-number">2.0.2.16.</span> <span class="nav-text">16. 利润最大化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-Sieve-of-Eratosthenes"><span class="nav-number">2.0.2.17.</span> <span class="nav-text">17. Sieve of Eratosthenes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-斐波那契通项公式"><span class="nav-number">2.0.2.18.</span> <span class="nav-text">18. 斐波那契通项公式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-Memoized-Fibonacci"><span class="nav-number">2.0.2.19.</span> <span class="nav-text">19. Memoized Fibonacci</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-画楼梯"><span class="nav-number">2.0.2.20.</span> <span class="nav-text">20. 画楼梯</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21-画金字塔"><span class="nav-number">2.0.2.21.</span> <span class="nav-text">21. 画金字塔</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-螺旋方阵"><span class="nav-number">2.0.2.22.</span> <span class="nav-text">22. 螺旋方阵</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构算法"><span class="nav-number">2.0.3.</span> <span class="nav-text">数据结构算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#队列"><span class="nav-number">2.0.3.1.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆栈"><span class="nav-number">2.0.3.2.</span> <span class="nav-text">堆栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链表"><span class="nav-number">2.0.3.3.</span> <span class="nav-text">链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#树"><span class="nav-number">2.0.3.4.</span> <span class="nav-text">树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#图表"><span class="nav-number">2.0.3.5.</span> <span class="nav-text">图表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序算法"><span class="nav-number">2.0.4.</span> <span class="nav-text">排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#冒泡排序"><span class="nav-number">2.0.4.1.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#插入排序"><span class="nav-number">2.0.4.2.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#选择排序"><span class="nav-number">2.0.4.3.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快速排序"><span class="nav-number">2.0.4.4.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#归并排序"><span class="nav-number">2.0.4.5.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计数排序"><span class="nav-number">2.0.4.6.</span> <span class="nav-text">计数排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他的排序算法"><span class="nav-number">2.0.4.7.</span> <span class="nav-text">其他的排序算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#搜索算法"><span class="nav-number">2.0.5.</span> <span class="nav-text">搜索算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#二分搜索"><span class="nav-number">2.0.5.1.</span> <span class="nav-text">二分搜索</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉搜索树"><span class="nav-number">2.0.5.2.</span> <span class="nav-text">二叉搜索树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">2.0.6.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">猛犸象</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.0.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.0"></script>

  <script src="/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.0"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.0"></script>




  
  <script src="/js/src/scrollspy.js?v=7.0.0"></script>
<script src="/js/src/post-details.js?v=7.0.0"></script>



  


  <script src="/js/src/bootstrap.js?v=7.0.0"></script>


  
  
  

<script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script>



<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'VbVsL6RlJwrgcd33OqP52lMA-gzGzoHsz',
    appKey: 'jhnIXVhcAInOvmIJHRdvFtzP',
    placeholder: '评论',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false
  });
</script>




  


  




  
  
  <script>
    
    function addCount(Counter) {
      var $visitors = $('.leancloud_visitors');
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', '/classes/Counter/' + counter.objectId, JSON.stringify({ time: { '__op': 'Increment', 'amount': 1 } }))
            
              .done(function() {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.time + 1);
              })
            
              .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
              })
          } else {
            
              var $element = $(document.getElementById(url));
              $element.find('.leancloud-visitors-count').text('Counter not initialized! More info at console err msg.');
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .fail(function ({ responseJSON }) {
          console.log('LeanCloud Counter Error: ' + responseJSON.code + ' ' + responseJSON.error);
        });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + 'VbVsL6RlJwrgcd33OqP52lMA-gzGzoHsz')
        .done(function({ api_server }) {
          var Counter = function(method, url, data) {
            return $.ajax({
              method: method,
              url: 'https://' + api_server + '/1.1' + url,
              headers: {
                'X-LC-Id': 'VbVsL6RlJwrgcd33OqP52lMA-gzGzoHsz',
                'X-LC-Key': 'jhnIXVhcAInOvmIJHRdvFtzP',
                'Content-Type': 'application/json',
              },
              data: data
            });
          };
          
            addCount(Counter);
          
        });
    });
  </script>



  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
